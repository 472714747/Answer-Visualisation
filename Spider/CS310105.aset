<?xml version="1.0"?>
<!DOCTYPE setOfAnswerPapers SYSTEM "answer.dtd">
<!-- serialize from mancs.caa.core at Thu Jan 19 11:48:25 GMT 2006 -->
<setOfAnswerPapers markingFinalised="true" allImages="true">
	<comment>
		Server completed aggregation at Mon Jan 24 12:31:33 GMT 2005
		
		The following students were recorded as taking the exam, but final submissions are not included for some reason:
		et1
	</comment>
	<answerPaper studentId="1" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="42" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						striker is a small change from the class footballer and will not implement anything different from any of the other positions. perametisation will probably be the best solution.
						Wayne will not be any different from other players(just better). Other players will score goals and do the same as him.
						
						public class Footballer{
						Position pos;
						String name;
						long wage;
						string club;}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						There is no need to extend arraylist when you can just create an instance of it and use it just the same. the advantage of this is that the methods of ArrayList that we don&apos;t need won&apos;t be in the TrafficQueue class. This is good because traffic isn&apos;t going to move out of order. If we did extend ArrayList someone could acess the get method to access any car in any order they wanted.
						Implementing the way below also means that we can change the storage type without affecting the way a client will see the class.
						public class TrafficQueue{
						List queue;
						
						public TrafficQueue{ queue = new ArrayList()}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Although it seems like CameraPhone is closely linked with both camera and phone it doesn&apos;t need to inherit from both of them. The best way would problably be to make CameraPhone extend mobilePhone and to delegate the function of the camera to the DigitalCamera class.
						This also means that if a company want continue the production of the phone but improve the camera facilites they can do that without affecting much of the code.
						
						public class CameraPhone extends MobilePhone {
						DigitalCamera DC;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Book doesn&apos;t need to extend copyable when it can just implement the all the copy functions using delegation. It shouldn&apos;t extend inforamtion source eihter as some books are fictional and not the best places to get reliable information.
						
						public class Book implements InformationSource Copyable
						{ .... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						NoAnswerProvided is a property of a question rather than a new class. If a boolean variable called Answered was put int the Answer class then we could use that instead of creating a seperate class. This would mean that we would need to check explicity that a question was answered but would remove the need to create a seperate NoAnswerProvided object for every question.
						NoAnswerRequired is also a property. This could be used with noanswer provided. Instead of creating a new object each time set the Answered boolean to False. This would mean that no unneccessary objects where created. However &quot;strong&quot; encapsulation would be needed to stop people from changing the Answered boolean from outside the question object.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a pattern of communication classes or objects which can be customised to fit a general problem in a particular context
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The composite design pattern will turn the exam into a tree and allow us to treat every single node the same. All the exam questions could inherit from an abstract super class question which would have the abstract method getQuestion().
						Since all nodes can will either directly or indirectly inherit from this class they will all understand the call getQuestion(). which means that the java applet can call getQuestion on every node and produce a result suitable to the object it received. The composite pattern also allows us the use any type of storage that we choose without affecting how the user sees the result. We can also use this pattern to help create composite questions. It allows us to treat all types of questions the same, so that an array or list of questions can contain any number of different types of questions.
						If we are likely to switch and change questions we could also include backwards pointers ( if we want to remove a question or change the layout of a set of questions). With these extra pointers we can change things more easily but adding/removing questions will be slower because we have to set all the pointers.
						One of the problems with this is when different nodes need different diffent calls. e.g. multiple choice question requires a set of answers. This means that we have to explictly check that a question is multiple choice before we can call getMultiAnswers().
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						The proxy design pattern would be used because the examanees will be spread across the world and will ne to interact with the program as if it was on their computer. This is where the remote proxy pattern comes it. It will take answers from the user and pass them to the markers computer with as much transparency as possible
						
						Oberver pattern can be used to watch for users taking the exam. It will look out for people requesting the exam and will set it up so that the user can sit it. It can then help us to watch for changes in their answers which could help us back the answers up. It can then be used to watch the &quot;finish Exam&quot; button to take all the answers from the user and send them to the marker.
						
						An object creational pattern could also be used. This is so that if we change the style of the exam qusetions (E.G. add a new type of question) that the rest of the program can remain the same and cope witht this new style of question. for example adding a question which involves drawing a graph into an exam which had only had text based answers. all answers are created as objects and can be treated as such. So all answer objects will understand getAnswer() and can pass it back to the main program without having to change the program.
						
						The factory method could aslo be used to help get answers and marks from the different type of question. This is so that all the quesitons and answers can be given the same calls. These calls can then be dynamically binded at run time to give the correct method for the call and objects given. This is good because not all questions will be the same and getAnwser needs to work for all of them. It would need to return an object suitable for the question give. e.g. a multiple choice question will give a different answer object than a directed graph object.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts would provide people with the knowledge that when they use the classes correctly(i.e. they uphold the pre-condition) that they will get the correct answer. This means they need not explicitly check every answer that gets returned to them. Or they can delegate a call to one of my classes and be sure that it willl get handled correctly.
							My classes can also act on all the information they have been given because it will be correct (if the caller upheld the pre-condition). This means that it doesn&apos;t need to explicitly check for all the possible errors everytime it is called.
							This means that my classes are bound to a contract with their caller. Both my class and the caller can be sure that if the pre-condition is upheld then the post condtion will be too. Design-by-contract also allows us to reason about the correctness of a program. A program(or method) is correct if it returns the post-condition everytime the pre-condition is met.
							
							definitons
							pre: Expression;
							
							the expression will give a boolean result to whether the precondtion is up held.
							E.G.
							input&gt;= 15;
							If the call passes input of 10 then it has broken the contract and can&apos;t expect the class to return the correct answer.
							If the call passes 16. It has upheld it&apos;s part and WILL get the right answer.
							
							post: Expression;
							This will give a boolean expression which can be resolved based on the values.
							E.G.
							output &gt;= 20;
							This means that it will give an answer over 20 when it&apos;s precondition has been upheld.
							
							Inv: x&gt;=0
							This means that when ever the class is in a steady  state(&quot;stable&quot;) then it should hold that x will be more than 0. This means that it will be upheld before and after every method call in the program.
							
							full example program
							public void do(int input)
							{
							pre: input&gt;=15;
							x++
							output = input + 5;
							post: output&gt;=20;
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							class Stack{
							invairiant: next_empty &gt;= 0; next_empty &lt;= stack.length; if(stack_empty) then (next_empty == 0);
							public void push ( int num)
							{
							Pre: stack_not_full;
							stack [next_empty] = num;
							next_empty++;
							Post: stack_updated;
							}
							public int pop()
							{
							pre: stack_not_empty
							next_empty --;
							return stack[next_empty];
							post: stack[next_empty] returned
							}
							}
							The push method would expect to be called only if there is enough space in the stack to fit another item. This means that the stack method doesn&apos;t explicitly have to check whether the stack is full. The push method is bound to making sure that the stack is correctly updated when any call satifies the pre condition.
							The pop method expects the caller to check that the stack isn&apos;t empty before it is called. This means that the pop method need not check whether the stack is empty and can get the next item and return it without the checks.It is bound to the fact that it will update the stack and return the correct answer when the precondition is met.
							The invairiant should ensure that the stack never overflows or a call is never made to an empty stack. IT should be upheld in every &quot;stable&quot; state and should help stop the production of exceptions. The invairiant will hold accross the class.
							
							class SqRoot
							{
							public static float root(int in)
							{
							pre: in &gt; 0 ;
							result = the square root of in;
							return result;
							post: result == SqRoot of in;
							}
							}
							
							This method assumes that the caller of root has checked to see whether the number to be square rooted is possitve. This means that the root function doesn&apos;t need to check whether it is going to create an imaginary number, so that it can perform exactly the same calculation no matter what number it is passed. It is bound to returning the correct answer when the input number is more that 0.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						class findAllRoots{
						Stack stk;
						
						main
						{
						while(stack_not_empty);
						{
						num = stk.pop();
						if ( num &gt;= 0)
						{
						result = SqRoot.root(num);
						println(&quot;the Square root of &quot; + num + &quot; = &quot; + result);
						}
						}
						}
						}
						The benifit for the program is that it can be shaw that it will get an answer back from the stack because the stack is bound to that fact. The stack is bound because this program checks to make sure that there is at least one item left in the stack, so it upholds the stacks pre condition.
						The program also checks to make sure that the number to be used is positive (or 0) which means that it upholds the precondition for SqRoot. This means that SqRoot is bound to the fact that it will return the correct answer. This means that once the program completes it&apos;s two checks it can be sure without checking that it has been given the correct result.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="2" examId="CS310105" timeTaken="7187" isSubmission="true" allImages="true">
		<compositea marksAwarded="46" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This provides a good use of inheritance, as we see that there is no such thing as a generic footballer.  However we can have specific football players, such as the different posistions.  Defender and Striker passes the &apos;is-a&apos; test as every instance of a defender is an instance of a Footballer.  However every instnace of WayneRooney is not an instance of a Striker.
						
						WayneRooney is a mutable object, with changing states over time.  Whenever WayneRooney does something we do not create another instance of WayneRooney.  This ensures that there is only ever 1 instance of wayne rooney irrelevant of the roles he might play.  Although he is a striker scoring a goal, we do not create a second WayneRooney to make a tackle.  We therefore make WayneRooney an instance of Striker that extends Footballer.
						public abstract class Footballer { .. }
						public class Striker extends Footballer { … }
						public class Defender extends Footballer { .. }
						public class Main(){
						Striker wayneRooney = new Striker(); ... }
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Inheritance should only be used as a last resort after parameterisation and delegation.  A Queue has certain properties that the last object in, will be the last object out, it cannot be accessed by an index.  This then fails the &apos;is-a&apos; test.  Every instance of a TrafficQueue is not an instance of an ArrayList.  However if really desired for a particular implementation we could delegate use of this ArrayList to the TrafficQueue client:
						public class TrafficQueue{
						List storageOfQueue = null;
						TrafficQueue(){
						storageOfQueue = new ArrayList();
						}  }
						This also allows easy development in the future if the TrafficQueue whishes to be described via a queue, or HashMap etc.  The add() and remove() operations could also make use of any of the corresponding generic container add() and reomve() methods.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						If this was in Java we must first state that CameraPhone use of multiple inheritance is illegal Java.
						We must first look at the fact that a CameraPhones number one functionallity is a mobile phone, and taking photos seecond.  This is an important distinction we must make for the inheritance hierarchy.  If we had access to the sorce code we could first attempt to parameterise the MobilePhone class so that it can make use to develop a specfic CameraPhone, however i feel this is not quite right, as the camera functionality is still a small add-on to the MobilePhones intended use.  I would have an instance of the MobilePhone class, and if it were a CameraPhone, then the DigitalCamera class could delegate its camera functionality to it, via a DigitalCamera instance varible within the phone.  The camera is within the phone!
						
						public class MobilePhone extends PersonalElectronicEquipment {
						DigitalCamera cameraInPhone = null;
						MobilePhone(){
						cameraInPhone = new DigitalCamera()
						}
						image takePhoto{
						return cameraInPhone.takePhoto();
						}
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I feel that there is some good and bad use of inheritance here.  Every instance of a book is definatley an instance of an InformationSource and whould extend InformationSource properties and add some of its own.  However a book is not a Copyable, every instance of a Book is not an instance of Copyable, it fails the &apos;is-a&apos; test.  We could say the a book could be copied though.  It has the function to be copied, so could implement this behaviour if required.  To me this is a clear case of Interface Inheritance.  If the book wants to be copyable, it must implement the copyable methods, hence implement the copyable interface.
						
						public interface Copyable{
						public abstract Object copy();
						}
						public class Book extends InformationSource, implements Copyable{
						...
						public Object copy(){ ... }
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Although this passes the &apos;is-a&apos; test, every instance of the TextAnswer is an instance of an Answer, i feel this inheritance is unneeded as the subclasses will add no or very little functionality.  This problem could clearly be solved by parameterisation.  We could parameterise the Answer class to be specific to each type of argument.  In the end an answer is an answer irrelevant of what type of answer it is.  We can parameterise the Answer class to take the question number and the form of the answer.  A method could then transform the different answeres into a string (for example) format which can then be compared with model answeres by human for text question and by the system for the other types.
						
						public class Answer{
						//either a, b, c, d,e etc
						Answer(int questionNumber, MCQ selection){ ... }
						//a text answer
						Answer(int questionNumber, string answer){ ... }
						//no answer given, but a boolean stating if an answer was required for that question
						Answer(int questionNumber, boolean required){ ... }
						...
						}
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design pattern is a pattern of communicating objects and/or classes in a customizable way for a general problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The Composite design pattern is where different objects within a class hierarchy can be grouped together and then classed as objects themselves (composite objects).  A classic example of this is a part being made up of sub-parts etc.
						Questions in the above sceenario are structured.  I assume this means a question could take the form 2.1(b)(iii) etc.  This shows me that a question can be recursively be defined as a collection of other questions.  An AtomicQuestion could be the leaf node of the hierarchy, where ther are no more sub-questions, and a CompositeQuestion is a Question with sub-questions.
						We can easily total up the marks for a question by making recursive calls down the tree to each sub-question untill we get a concrete value.  This is very usefull, as we could have an exam (a special type of CompositeQuestion) and call the mehtods getPossibleMarks() and getActualMarks() to return a students total exam mark with only 2 method calls.  The recursion makes this very simple and efficent.  Some code can be seen below:
						
						public abstract class Question{
						int getPossibleMarks();
						int getActualMarks();
						...
						}
						public class CompositeQuestion extends Question{
						Question [] collectionOfSubQuestions = null;
						...
						int getPossibleMarks(){
						int total = 0;
						for(int i = 0; i &lt; collectionOfSubQuestions.length; i++){
						total += collectionOfSubQuestions[i].getPossibleMarks();
						}
						return total;
						}
						...}
						public class AtomicQuestion extends Question{
						String answer = &quot;&quot;;
						int possibleMarks = 0;
						int actualMarks = 0;
						...
						int getPossibleMarks(){ return this.possibleMarks(); }
						...}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Because the system results will be stored over a network link to a server, we want to seperate the code between storage and calculation.  For this purpose we could use a Proxy pattern.  This provides an intermediate object between the storage classes and claculation classes that shares (at least part of) the same interface and adds some extra translucent functionallity.
						The proxy object in the above senario would abstract away storage instructions to the server from the calculation classes.  The calculation class would just pass the student information and the mark to the proxy, and assume it is stored on the server.  The proxy deals with converting the data to a bitstream and transferring it across the network, the calculation class dosnt need to worry about it.
						
						I imagine that the connection to the server will either need to remain open where we keep the same connection, or there can only be so many connections to a server at any one time.  In this case we would use the Singleton/ObjectPool pattern (1 or the other depending on design issues).  To ensure that only one connection is only ever made to the server, we have a connection class.  We can only ever have one instance of this connection class, so we make its constructor private, to prevent anyone from making an instance of it.  However we do keep a static class varible keeping check of the number of instances.  A static method can then check this value, and if no instances (connections) are held then it can call the private constructor and return an instance of the connection class.  This ensures only 1 connection is open at any one time.
						
						The senario states that there will be various stratergies to present the information to markers.  This must consist of using different algorithms to present this information differently.  This is an example of the Strategy Pattern.  We treat each algorithm as an object and switch between different algorithms depending on the requirement of the information.  We could have a display class, that will output the average of some student answers.  One marker may require the mean, another the mode, and median etc.  For each marker we will need to select a different algorithm to calculate a different average.  This will involve switching between differnt algorthim objects at any time in the system.
						
						Some algorithms may be very complex and may require to look at extensive sets of different data.  For example &quot;Of the students doing computer science, what percentage achived a first and were female?&quot; could be a valid request.  This would require the Visitor Pattern.  The algorithm may require differnt sub methods spread in differnt classes.  The visitor pattern will need to piece together the different sub-parts of the algorithm and place them into a single class.  It must do this my interacting extensively with a number of classes to extract the methods and information needed.  In its own visitor class it could then create a method, that allows a user to stipulate the above exact question to a single object.  The object could then return the correct value.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							A contract is a binding gaurentee between a class and its client.  Two classes, A and B will have a formal agreement between each other that specifies the claims and resposibilities of each class for pre-defined situations.  A contract between 2 classes could be defined using assertions (pre-conditions, post-conditions and class invarients).
							A pre condidtion defines the states that must hold for a method to function correctly.  A post-condition defines the states that will hold once the operation of the method is comlpete.  A post condition of a method is a guarentee to the methods implementor that it will provide the correct state back if the implementor can guarentee the correct states of the methods pre-condidtions.  This imposes a harmony of trust between the implmentor and the method!
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The stack class must make sure that an class invarient holds for the stack at all stable (before and after method calls).  This class invarient will throw an AssertionException in java if it fails at anytime.  The invarient makes sure that the stack in any state having pushed and object then poped an object will be in the smae original state.  We must also state a pre-condidtion for the pop() method making sure that we do not try to remove from an empty stack.  Assuming the stack does not have a confined size there are no pre-condidtions for the push() method.  We could implement post condidtions for both push() and pop() to make sure that the size of the stack has incread and decrease by 1 respectively, but this is a trival  and should be taken care of by the methods implementation.  We could also make sure that when we instantiate a stack it is already empty, but again, this should happen automatically.  Some code of invarients and a pre condition can be seen below:
							
							class Stack{
							Array theStorage = null;
							...
							push(){
							assert ( (theStorage + theStorage.push() + theStorage.pop() ) == theStorage);
							...
							assert ( (theStorage + theStorage.push() + theStorage.pop() ) == theStorage);
							}
							pop(){
							if(theStorage.size() &lt; 1)
							return;
							assert ( (theStorage + theStorage.push() + theStorage.pop() ) == theStorage);
							...
							assert ( (theStorage + theStorage.push() + theStorage.pop() ) == theStorage);
							}
							}
							
							For a square root class we must define some sort of accuracy to give back the answer to.  This can be defiend in the constructor, and then we can use a find() method to square root any number.  I can think of no class invarients for this application because i am developing it using one calculation method only.  Ther is no internal object that we must keep track of.  However there is a pre-condition and post-condition that we must stipulate to keep the trust between ourselves and the implementor.  We must stipulate that the number given to root must be a positive number, we can not guarentee to give back complex numbers etc.  With this pre-condition we must guarentee that the answer we give will be within the required precision to the actual answer.  This is checked by the post-condition at the end of the find() method.  The code describing these conditions can be seen below:
							
							class SqRoot{
							double precision = 0.0;
							sqRoot(double accuracy){ this.precision = accuracy;}
							
							double find(double numberToRoot){
							double answer = 0;
							if(numberToRoot &lt; 0.0)
							throw new NegativeNumberException();
							
							...//implement the answer by whatever method.
							
							if( (numberToRoot - (answer * answer) ) &gt; this.precision )
							throw new PrecsionNotGuarenteedException();
							
							return answer;
							}
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						We have already defined contracts for these two classes.  If we build a class using these two classes it saves time and effort in development and debugging.  For each number on the original stack, we could square root the number and place the new numbers into a new stack.  The contracts state that as long as wee meet the pre-conditions the methods will do exactly what we ask of them.
						
						In future development if there is an error in the program we know there is no need to debug the Stack and SqRoot classes as we have a guarentee they are correct.  We would concentrate our debugging on our own code, to make sure we have met ther required pre-conditions.  If everything is correct and the error exists in thier code then they have broken the contract and are liable for any resulting damages etc.
						For our class to provide an interface to both these classes, we must provide a class invarint that is the other two classes invarients logically anded.  For example if someone gives us a set of numbers and a stack, saying place the results in this stack, they must ensure that all the numbers are greater than 0 and the stack is either instantiated and empty already or can be instantiated.
						
						This can help ensure a guarentee for any clients that use our classes between us and them that if they meet our pre condidtions we can guarentee the correct results!
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="3" examId="CS310105" timeTaken="6882" isSubmission="true" allImages="true">
		<compositea marksAwarded="16" isMarked="true">
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The defender and striker is a inheritance of the superclass footballer but, they can play different roles in the game. Also Footballer can be a different type of sport in America so these postions are not in american football but are only in  the game of soccer. WayneRooney can play in different roles, the he was failed the is-a test making the class not inheritance to the superclass Striker.
						
						An alternative is to have footballer inherited from person, then have subclasses like striker and defender inherited from it. Because you can have defenders in other sports like hockey.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						the arraylist should be a abstract class. It&apos;s not an inheritance of ArrayList because it can be in a form of another data type. Also u want the ArrayList to be private so it&apos;s encapsulated so would be hidden from the client.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						MobilePhone and DigitalCamera has failed the is-a test, there are might be description of a personal electronic equipment not in mobile phone or digitalCamera. Thers is no distinction between the equipment been personal or being shared. It could be a company phone or a uni Camera. Cameraphone uses multiple inheritance and it&apos;s a inheritance of the MobilePhone and DigitalCamera Classes.
						
						Alternative to this would be to have a general class ElectronicEquipment then have subclasses of owning and borrowed. then have the DigitalCamera and MobilePhone inherited to one of the subclasses.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The book class does not pass the is-test to the the superclass InformationSource becasue not all book relevant information source. It should be the other way round that infomation should deligate from books.
						Also it&apos;s an multiple inheritance which is usually not sensible so should call the function copy to copy the infomation you want off it.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The MCQ and Text answer has passed the is-a test, one has a text answer which written answers and the other one is a choice, so they have atrributes of the superclass Answer cos they both give an result to the question.
						NoAnswerProvided shouldn&apos;t be inherited because it doesn&apos;t give an result, and is not really an answer because there is no information given, so for an alternative this class should just return an Null, to show to there is no value given so when it come to assigning marks it should pick up that there was no answer given.
						There are polymerisation in NoAnswerRequired where they are two classes with the same name but different function, This should not extend Answer because it doesn&apos;t require an answer at all, it&apos;s a totally different function, It should extend another class like questions.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation is the hiding of the implementation, encapsulation are loosley coupled in modules and so has a low modularity .
						
						Abstraction shows how the modules interact with each other, so when the code is reused you can see the implementation of the modules. It shows how each module works
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Because encapsulation are loosely coupled and  has a low modularity, so the modules does not rely on each other therefore, at runtime, the execution would be faster.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation can help manual storage management because they hide the high level modules so the client can not change them.But they can only change the parameters of methods, therefore stopping them from altering the main structure of the method. So if u created a system where it can store data into an tree structure. You would encapsulate the class where it structure the tree and the sorting. But the client would be able to use the add and delete function to store their specific data.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It&apos;s important for DbC beacuse between the client and the programmer we don&apos;t want the client to be changing parts of the module. We want them to able to use the system as they are intended and not to change the implementation of high level codes. So encapulation does this by hidding the implementation part of the programm so the client can&apos;t see them and access them to change the code and destroy what they are intended to do.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<compositea marksAwarded="3" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</unanswered>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Using Design by contract we need pre-condtions and post-condtions in the square root class, depending on the what values the clients want because we need to specify the number of significant points because some values when square rooted are infinite. So we need a parameter of how many digits we want. Also we can&apos;t square root 0 or negative numbers beause it gives infinity but in some cases for example in maths u can square root a negative number to get i  so we need to define that in our pre-condition what the client wants and what the program is used for, but we can solve this by having the SqRoot class as a superclass and have subclasses so you can choose to squareroot positive and negative numbers.
							So if we don&apos;t wanted negative square roots we need to define our pre-condition of the valume to be rooted to be 1 or more. Or if it&apos;s a negative we need to a different method to sort square root of negative numbers. In the SqRoot class we need to encapsulate this because we don&apos;t want the function of the method to change. And encapuslation hides this from the client so they cannot alter the calculation of squareroot.
							
							In the Stack class we need to define the amount of values we store in the stack, we need a pre-condition where  it must be the postion of the array must be 0 or higher because 0 is is start of the stack where it&apos;s empty and we can&apos;t have a negative postion. This class would be be public so we can change the value in the stack. We can also have a add and delte function for the stack so the client can add their own numbers to the stack or remove it. But this function must be encapuslated so the client cannot see implementation and destroy the structure of the data.
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In the stack class, we would have an arrrayList where we can store the numbers we want to be evaluated, this would be the stack method where it&apos;s public so the client can see what numbers are in the array. Then you would have an add and delete function so the client can add numbers to the stack they want to be squared rooted, These would be private so they can&apos;t change the implementation of the functions to the stack.
						Then in the squareroot class you would have the method where it calls the value on top of the stack and it does the calculation of squareroot. . And in this method we would call the stack function delete to delete the value off the stack once it&apos;s been square rooted. and then increment the postion of the array for the next value.
						
						This way the client can only change the values they want on the stack by addin to it. And the rest of the code will be encapsulated, benfit of this is that the rest of the code can&apos;t be changed and the implementation of the calcuation of SqRoot can&apos;t be changed by the user.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="4" examId="CS310105" timeTaken="4224" isSubmission="true" allImages="true">
		<compositea marksAwarded="40" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						These uses of inheritance have some merit but are not entirely sensible. The first two, Striker and Defender, satisfy the is-a test but appear more like roles (is-a-role-played-by) than full inheritance. e.g.
						
						public class Footballer {
						
						private Position myPosition;
						
						}
						
						The final example, WayneRooney, would be much better dealt with by simply having the name as an attribute of Footballer - creating a subclass for each individual name is overzealous use of inheritance
						
						public class Footballer {
						
						private String name;
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is &quot;implementation inheritance&quot;. The is-a test is just about satisfied, but not all the functions of ArrayList are used or indeed relevant to TrafficQueue. It is true that the ArrayList can form the backbone of the TrafficQueue, but the function of this class may expand at a later date, making its relationship to ArrayList even less convincing. The best alternative to use here is delegation - making the ArrayList an instance variable of TrafficQueue:
						
						public class TrafficQueue {
						
						private java.util.List theQueue;
						
						....
						}
						
						This implementation is slightly improved by using the more generic class List in place of ArrayList so the implementation could be changed at a later date by just modifying the one line.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The first two cases are fairly sensible, although the relationship is quite loose - that is, PersonalElectronicEquipment is a very large grouping and few of its subclasses will share much in common. The final case, where multiple inheritance is used, is again a reasonably sensible use of multiple inheritance - a disjoint where both inherited elements are unrelated - but the fact that they both inherit from PersonalElectronicEquipment would cause problems. Additionally, any application treating CameraPhone as a camera would need to know little about the mobile phone functions, and any treating it as a MobilePhone would need to know nothing about the camera functions. An alternative might be:
						
						public class CameraPhone
						{
						private MobilePhone thePhoneComponents;
						private DigitalCamera theCameraComponents;
						....
						}
						
						
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						There are cases like this which arise but they are quite rare. This is the main reason Java has built-in support for many of the common functions like this - cloning, serializing, synchronization - to minimize the number of places where this form of MI will be needed. There are few ways to resolve this problem and retain all functionality. One way to solve it would be to use an interface for the Copyable system, but the default implementation as specified would be lost.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a sensible use of inheritance in most cases. The MCQAnswer and TextAnswer classes should work well. However the NoAnswerProvided class might best be implemented as an instance variable of Answer, since the student might theoretically fail to provide any of Answer&apos;s subclasses. Similarly, whether or not the answer is Required could be set up in the same way, then assigned a value after the system has picked out the set of questions from the bank.
						
						public abstract class Answer {
						private boolean isRequired;
						private boolean wasProvided;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a technique to observe when designing software, a commonly recurring theme which is too general to be coded directly. The aim of a pattern is to produce readable and efficient software that can also be reused in as many cases as possible.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The main role of the Composite design pattern is in Trees and related data structures. In this example, the Tree is core to the system - an exam can be specified as a Tree of questions, where each branch of the tree leads to one or more subquestions. It is the &quot;one or more&quot; part where the Composite design pattern can help. It allows us to create a system where every node in the tree can use the same abstract data type - whether it is a single atomic question at one of the tree&apos;s leaves or a large composite question higher up in the tree. This is done by creating a hierarchy starting with a class Question at the top. This class can be subclassed into the more specific types of question, but the important one with respect to the Composite pattern is the class CompositeQuestion. This class will also inherit from Question, so it shares the relationship, but will have in it an array or similar data structure also consisting of Questions. Operations common to Question, like calculating marks, then operate in CompositeQuestion by aggregating the marks from each question in the array.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						Singleton:
						The Singleton design pattern is designed to ensure that only one instance of a class is in existence at any one time. In the case of the exam software, there will most likely be a top level class called Exam which then contains the various Questions. It is vitally important that, on each machine, only one instance of the Exam is created. The Singleton design pattern can ensure that this is the case.
						
						Factory:
						The Factory design pattern might be used in the marking software. When the software comes to present a question and its answer to the examiner, the method by which it displays them will vary greatly depending on the type of the Question. This could be solved using a series of if statements, but this would be error prone. The Factory pattern provides a more elegant solution. The viewer element (QuestionViewer) would be subclassed, and subclasses for each question created. Within each would be a factory method that creates the right kind of Viewer for the question.
						
						Observer/Observable:
						The Observer design pattern assigns the role of Observable to certain objects which have state that may change at some unspecified time, and Observer objects to watch for this state change. The Exam software has several uses of this functionality. The most obvious is watching for the exam start signal, which will most likely be issued remotely. In this case, the exam software is the Observer, and the control software issuing the signal is Observable.
						
						Flyweight:
						This design pattern, which separates data intrinsic to the class with data common to a series of objects, could be used to simplify the Question class with respect to the viewer software. For example, the viewer software may wish to display questions at different levels using different font styles. Flyweight could be used to store this data at a higher level of the hierarchy, instead of storing it with each individual atomic question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Introducing contracts is a way to enhance software reliability and in some cases, prove that the software is correct - that is that it meets the specification. Contracts also improve the robustness of a program by ensuring that when an input is given that violates the contract, it is dealt with elegantly and in a way that is helpful to the user. In the case of a software library, DbC provides a clear set of responsibilities to the external users of the library, but in return, it also guarantees to them that, if these responsibilities are met, the outputs will be within spec. This is an advantage to users of the library. Some languages have direct support for DbC, but most of the common ones do not, or have only limited support. In this case, the contracts can be defined using comments by each method that has a contract, outlining clearly the responsibilities of the caller (prerequisite) and the guarantee made by the method (post-requisitite).
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							When implementing a class to deal with SquareRoot there are a number of issues to consider with respect to what to make the prerequisite. Since the class is a simple one, the most clear prerequisite will be that the number passed to the SquareRoot function cannot be negative, as this would require support for complex numbers not provided by our package. However, since this is a library designed for use by anyone who wishes to, using the Java assert mechanism would not be appropriate to enforce this prerequisite. Instead the Java exceptions mechanism can be used to create an exception more specific to the error and therefore more helpful to the user.
							Concerning the post-requisitite of this method, after the square root has been calculated, the simplest way to ensure the correctness of the result would be to mulitply the square root with itself and test that this equals the original number. The Java assert mechanism is suitable for enforcing this.
							
							class SqRoot {
							
							public static squareRoot(float num) throws InvalidParameterException
							{
							if (num &lt; 0) throw new InvalidParameterException(&quot;Num must be &gt;= 0&quot;);
							....
							assert ((result * result) == num);
							return result;
							}
							}
							
							With regard to the stack, the operations to be considered are push and pop, the processes of adding a number to and removing one from the stack. Contracts in this case can simplify the amount of checking that needs to be done inside these functions by setting certain prerequisites that prohibit certain problematic cases. The precondition for the push() method would therefore be that the stack is not full, whereas the precondition for the pop() method would be that the stack is not empty. Violations of these conditions could be fielded using exceptions as above. The stack itself can then guarantee that its state is valid and that the number was either added successfully, or removed and returned correctly.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The program would start by creating an instance of Stack and populating it with numbers. During the populating phase, it is guaranteed by the contract that the stack will add the number provided the push() method is not called on a full stack, which is the client (i.e. the program&apos;s) responsibility to check. When the stack is full or as full as it needs to be for the user&apos;s purposes, the numbers will be pop()&apos;ed in turn. Here the contract also guarantees that the stack will return to a valid state after the process and that the number returned will be the correct one, provided the pop() function is not called on an empty stack. During each turn the squareRoot method will be called to calculate the square root of the current number. If the number is positive or zero as required by the contract it is then guaranteed that the result will be correct. However if there is a number in the stack that violates this contract, the mechanisms that enforce it will ensure that it is dealt with in a reasonable way.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="5" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="22" isMarked="true">
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The use of inheritance here is not sensible.
						Striker is-a- role-of Footballer, it will change over time. Hence we&apos;d better declare a Class Role for every roles played footballer. Defender is the same as Striker, not suitable to be declared as class. WayneRooney is person&apos;s name, not a-kind-of Striker, so it failed the is-a-kind-of test.
						We&apos;d better change the name of Footballer&apos;s class as FootballerDetails, as we&apos;re only interested each person&apos;s details, such as address, salary.
						the better version of this code is:
						Public class FootballerDetails{
						public Role currentRole;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It&apos;s not good use of inheritance. Because a traddic queue composes a list of cars or other sorts of transportaion, there&apos;s no need to declare an ArrayList as a supper class for TrafficQueue. Hence only delegation is enough in this situation.
						change the original code into:
						
						public class TrafficQueue{
						private List[] transportation;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Inheritance here is not sensible, as MobilePhone and Digital Camera are the features of CameraPhone, which can only be delegated to. Meanwhile, MobilePhone and DigitalCamera are not abstract classes, namely that all of both attributes will pass to CameraPhone, but in fact, it&apos;s not true.
						The better way to do it is to keep the first three class and change the CameraPhone class into:
						public class CameraPhone extends PersonalElectronicEquipment{
						List [] featureInfluenced;
						public CameraPhone(MobilePhone phone, DigitalCamera camera)
						{
						featureInfluenced{phone, camera};
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is one of the bad examples of Meyer Multiple Inheritance. Firstly, copy() method in the class Copyable is public, so everybody can change the copy method. Hence, for security reason, we&apos;d better declare it as protect. Secondly, the InformationSource of Book is just a list of sources, so no need to use inheritance here.
						the better code is:
						public class Copyable{
						protect Object copy()
						}
						public class Book extends Copyable{
						List[] InfoSources;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This&apos;s a bad use of inheritance, as there are too many small classes declared. We can declare an another class called CompositeAnswer, in wich using parameter answertype to distingush different kinds of answers.
						The code is:
						public abstract class Answer{}
						public abstract class CompositeAnswer{
						public CompositeAnswer(AnswerType answertype)
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						DesignPattern is a communication of classes and objects customerized to solve design problems in a particular context, simply a resuable and customerizable design. It&apos;s the best design after through many tests, can be used in many places, but may vary slightly.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Dynamic binding recursively used in CompositeQuestion class, which inheritated from Question. The other subclass of Question is AtomicQuestion. A composite question has a list of atomic question, so recursively call
						(Question)compositeQuestionList.get[i]
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							The purpose is to give a precise defination for what obligation and benefit every party should have. It attain a large degree of trust betweet clients and suppliers, so it&apos;s easier to expand and maintain my library classes in the future.
							Contract is predicate spesified as precondition, postcondition and invariant in my library classes.
							Precondition is the constraint under which the method can function properly; Postcondition is the properties guaranteed after executing the method; Invariant is the global properties of a class, which are preserved when new instance of this class created, and before and after each method execute.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							public class SqRoot{
							private double y;
							private double x;
							final RootRange=1+E-3;
							public SqRoot(double x)
							//invariant, maintained when every instance of SqRoot create
							{assert: x&gt;0; }//constructor
							public double getsqroot()
							{ //invariant, maintained before method executes
							assert: x&gt;0;
							//the answer must larger than or equal to 1+E-3 (i.e.0.001)
							if(x&lt;=0)
							{System.out.println(&quot;please use a positive number to calcuate its square root&quot;);}
							else {while(y within RootRange)
							{algorithm for square root computing and get y as the answer}
							return y;
							//invariant, maintained when every instance of SqRoot created
							assert: x&gt;0;
							}
							}//breif code for SqRoot
							class SqRoot
							invirant: x&gt;0
							method getsqroot precondition: answer within a range
							postcondition: answer&lt;=x ^answer within a range
							**************************Stack******************************************
							class Stack
							method pop
							precondition: stack not null
							postcondition: update stack
							method push x
							precondition: stack not full
							postcondition: update stack, x on top of the stack
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						class Test
						create instance of Stack;
						pop x pre: stack not equal to null
						post: update stack
						getsqroot(x) pre: x&gt;0
						post: answer&lt;x and answer within range and x&gt;0
						loop pop next_x pre and post condition are the same as pop x and getsqroot(x)
						push answer to another stack
						push answer pre: answer&lt;x and answer within range and stack not full
						post: answer&lt;x and answer within range and update statck, and the newest answer on top
						loop until push all of the answers into answer stack
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="6" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="42" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The use of inheritance here is really quite silly. Ostensibly it appears that Striker and Defender pass the &quot;is-a&quot; test but upon reflection this isn&apos;t actually the case. The subtle difference is that a Striker is a role played by a Footballer as is a Defender. Roles change over time and a footballer may have multiple roles at any one time. For example, a striker may need to track back and help defend. As a result of this, roles are not ammendable to inheritance. A better solution might be have a single concrete class Footballer and then generalise this class using parameterisation. This would not really work though if the footballer had various other attributes unique to their position. In that case, it might be best have a concrete class for each role which delegates operations to the Footballer class. This way multiple roles could link to a single Footballer object.
						
						eg)
						
						class Defender{
						
						// used to delegate functionality
						Footballer player;
						
						// various defender specific attributes...etc
						
						// constructor
						public Defender{
						player = new Footballer();
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is classic implemenation inheritance, a class of inheritance that is a little suspect to say the least and not usually a good idea. TrafficQueue is inheriting implementation from ArrayList merely for convernience which is why the &quot;is-a&quot; test so obviously fails. There is no logical connection between the two classes to suggest that TrafficQueue is a subtype of ArrayList. Problems may arise when using inheritance in this way. For example, only a few of the operations in ArrayList may even be applicable to TrafficQueue and seen as therre is no mechanism in java for hiding inherited methods, they could potentially be called irrespective of their viability. Once again delegation would make a lot more sense in this situation. TrafficQueue could become a client of ArrayList by storing an ArrayList object as an istance variable which it could then perform operations on. So we would have something like this:
						
						public class TrafficQueue{
						/* it would be better to declare the object as a List so if we subsequently decide that we
						would prefer to use a different list, we can just change the initialisation in the constructor */
						private List l;
						
						// constructor
						public TrafficQueue(){
						l = new ArrayList();
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The MobilePhone and the DigitialCamera classes do seem to pass the &quot;is-a&quot; test. They are kinds of personal electronic equipment which suggests that the inheritance is okay. Without knowing what kind of information is being recorded and why though, it&apos;s hard to say how sensible this inheritance hierarchy really is. The sort of data being represented would indicate how necessary it is to group common properties of mobile phones and digital cameras into the abstact superclass PersonalElectronicEquipment. What is certain is that the multiple inheritance used in the CameraPhone class is ill-advised (and completely illegal in java). A camera phone is primarily a phone, and quite a useful distinction, so it seems reasonable that it extends MobilePhone. If it only inherited from MobilePhone, it could then be a client of Digital camera and delegate the camera functionality.
						
						public class CameraPhone extends MobilePhone{
						private DigitalCamera camera;
						
						public CameraPhone(){
						camera = new CameraPhone();
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Seen as we&apos;re talking specifically about java mechansims here, it&apos;s worth pointing out that the MI above would not be valid. This is one of the cases where MI actually quite useful though- we need to mix classes to combine their properties. It would not be enough for Book to become a client of Copyable because it wants to actually &quot;be&quot; copyable. This is why mechanisms such as cloning, locking and serialising are built in to java (to avoid this kind of issue arising). If all information sources were copyable, one solution might be for InformationSource to extend Copyable. A better idea would be to just use the built in mechanism instead of trying to implement your own.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						MCQAnswer and TextAnswer some like quite useful distinctions and they pass the &quot;is-a&quot; test suggesting that this part of the inheritance hierarchy is okay. It seems a little odd use an object to represent &quot;no answer&quot; but on the other hand, this could be viewed as an implementation of the Null Object pattern and therefore a useful way of eradicating spurious error-prone null tests.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation is the process of hiding the implementaion of a module from it&apos;s clients. It&apos;s certainly a fundamental concept, key to the idea of having independent loosely coupled objects (the less they know about each other&apos;s implementation, the less dependent they will be on each other). Abstraction models the behaviour of a module (by module I&apos;m referring to say a class or package in java) by an interface. In general, an interface is a set of operations that a class makes aviable to it&apos;s clients whilst hiding the details of how these operations are actually implemented. It therefore relies on this concept of encapsulation which separates implementation from the contractual interface (a precise, succinct description describing the behaviours / functionality of an object). Think of a television and a remote controller. The controller is an abstraction of the underlying mechanisms encapsulated by the TV. It&apos;s a kind of interface, where the buttons represent the operations made available to us and pressing a button equates to calling a method.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It&apos;s certainly a possibility that this could be the case. Encapsulation effectively reduces coupling (dependencies between modules) which makes change much more manageable. Because the objects can exist almost independently, when one of them changes, very little other code is affected. Taking this into account coupled with the fact that many objects are mutable (their state can change subsequent to creation), encapsulation may help to improve run-time performance. If encapsulation wasn&apos;t used and module were tightly coupled, state changes may have a sort of ripple affect and affect numerous dependent modules. There must also be a runtime overhead associated with continually having to resolve all of these dependencies. However, that is not to say that the statement is inherently true. Access to low level implementation (ordinarily hidden by encapsulation) can often be utilised by performing various low level optimistaions to improve the efficiency of code. Maybe, in this respect, encapsulation is somewhat of double edged sword.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is certainly the case for &quot;low level&quot; high level languages such a C/C++. In C for example, we often want to manually allocate heap memory of using malloc() and free this memory using free(). What these methods are doing is encapsulating some really low level beaviour that as C programmers, we don&apos;t really want to know about. Through encapsulation and interfacing, this fairly complicated manipulation of main memory is made to appear simple, and this certainly helps us whilst programming. We have enough to worry about with memory leaks and dangling pointers without having to worry about the underlying implementation controlling all of this memory manipulation.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by Contract (DbC) views the relationship between a class and its clients as a formal agreement or &quot;contract&quot;, specifying the rights and obligations of each party. These contracts are formed through assertions (pre-conditions, post-conditions and invariants). By associating a precondition &apos;p&apos; and a postcondition &apos;q&apos; with a method &apos;m&apos; a class is basically saying to it&apos;s clients:
						
						&quot;Listen mate, if you promise to call m with p satisfied, then I promise to deliver a final state satisfying q&quot;.
						
						Hence a contract is formed with obligations and benefits for both the client and supplier. The great thing about establishing a contract like is that although a client is unware of the underlying implementation of a class due (due to encapsulation) it has obtained a guarantee (as has the class) and thus a significant degree of trust has been obtained. Encapsulation ensures that what is actually happening beneath the surface remains hidden- all that matters is the guarantee, which is why I would argue that encapsulation is indeed a prerequisite for DbC. With the guarantee in place and the finer details hidden, each party can simply move on to performing some other task
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of related classes and/or objects which can be modified to solve a general design problem in particular context. Design patterns provide us with reusable designs that are too general to be coded directly.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The Composite pattern is probably the most widely used of all the design patterns. We can use it wherever we have a hierarchy of objects and we want to be able to uniformly send messages to objects representing basic components and those which are composed of a series of these basic components. In this case we have a general abstract notion of a Question and a general abstract notion of an Answer. These notions can be broken down into individual parts and composite parts, and it&apos;s desirable that we&apos;re able to deal with all types of object in the same manner, and rely on dynamic binding to do the right thing at run time. So for example we may have:
						
						public abstract class Question{
						protected in mark;
						abstract int getMarks();
						}
						
						public abstract CompositeQuestiont extends Question{
						public int getMarks(){
						// sum the marks of each single part
						// return the overall mark
						return mark;
						}
						}
						
						public abstract Atomic Question extends Question{
						public int getMarks(){
						return mark;
						}
						}
						
						Using this Composite pattern we would be able to call methods such as getMarks according to the static type of the object (Question) knowing that dynamic binding will choose among the possible implemenations at run time (so we do not need any explicit selection statements)
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						(Running out of time)
						
						If the situation above resulted in a large tree structure consisting of lots of small objects that were being duplicated then we could optimise the system using the flyweight pattern. For example instead of producing lots of instances of the same question, we could use a Question Factory that recycles a single object which we could then access indirectly using some factory method eg.) getQuestion()
						
						We could use the Null Object pattern to eradicate the need for spurious null tests throughout the system. For example, and anwer may be left blank, and if we have a null object to represent this case with null implementations of any operations, then we no longer need to fill the system with ugly, verbose, explicit tests.
						
						The proxy pattern could be used to aid the management of the exam on the network.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="7" examId="CS310105" timeTaken="7039" isSubmission="true" allImages="true">
		<compositea marksAwarded="37" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The initial part of the code appears to be sensible, a Striker is a type of footballer and a Defender is also a type of footballer. However although the last class does appear to make sense it may not be the best way to achieve the desired affect. WayneRooney is a Striker, in normal circumstances this would call for inheritance however if the intention of this program would be to store details on all football players the amount of data stored would be huge. A more suitable approach might be to create a list of Strikers inside the Striker class (similarly for Defenders), this would greatly reduce the amount of data being stored for each player.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						While this is valid code it is probably not the most sensible way of going about the task. Initially an Array List may be judged to be the best possible storage type for TrafficQueue&apos;s needs, however over time another type of List may become more suitable (perhaps due to changes to the system or just an oversight when developing initially). Changing the TrafficQueue code in order to change from ArrayList to say a LinkedList would require a lot of work due to the way it is set up.
						A better way of setting TrafficQueue up would not require the use of inheritance, the class TrafficQueue could contain a list within the class itself as a variable. Another optimisation would be to define the variable as the interface List, this could reduce any future list changes to just one word changes (depending on list usage) rather than having to re-write the whole code.
						The example used is shown below :
						
						public class TrafficQueue
						{
						private List trafficList;
						
						public TrafficQueue( )
						{
						//Just the word ArrayList would need to be changed to change List types
						//Create an ArrayList of size 100
						trafficList = new ArrayList[100]
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Multiple Inheritance is typically a rather confusing and messy way to deal with a problem. In the case shown it is true that a MobilePhone is a PersonalElectronicEquipment, it is also true that a DigitalCamera is a PersonalElectronicEquipment however although a CameraPhone is a MobilePhone but it is more appropriate to say a CameraPhone has a DigitalCamera (rather than is-a). Therefore in this case only single inheritance is needed and the DigitalCamera aspect of a CameraPhone can be modelled by including a DigitalCamera object in the CameraPhone class.
						
						public class CameraPhone extends MobilePhone
						{
						private DigitalCamera phoneCamera;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The code shown here appears to be a sensible way to use inheritance. The multiple inheritance should cause no problems (similar to how Serializable is used in java) and appears to be the best way to deal with the copy.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In the case of an MCQAnswer and a TextAnswer they are both sufficiantly different to require their own classes extending the base class Answer. However in the case of the other two classes, NoAnswerProvided and NoAnswerRequired, it may be more suitable to combine them into one class. In both cases no actual answer data would be stored the only difference is that in one case the student doesn&apos;t answer the question and in the other they didn&apos;t need to answer the question. This could be represented by a simple boolean value which could be checked using an accessor method to find out which type of NoAnswer was provided.
						
						public class NoAnswer extends Answer
						{
						private boolean required;
						
						...
						
						public boolean getType()
						{
						return required;
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Abstraction gives a brief explanation of what a program does using method headings and other more specific pieces of information from a program (such as comments) to get its information. However if programs are not encapsulated the abstract representation will mean nothing. It may only contain a small number of methods that are used in the program because other methods are called from external classes. If the program is encapsulated then any abstraction of it is guarenteed to contain all the information required to understand the program and how it works.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						An encapsulated program only needs to be optimised to run the code within it. This allows optimisation to be performed on a smaller scale making it a far less complicated process. Although it is possible two seperately encapsulated programs that call methods in each other could be optimised more if they were both in a single program, the peformance enhancement is unlikely to be that much greater than when they are optimised individually yet the work required would go up a lot.
						e.g. you could have one program which takes input from a user and another which takes that input and stores it in a file. Presuming both have been optimised as well as possible putting them both together is likely to result in only a few lines of code being ommitted (method calls) and maybe some other more complicated optimisation which would save very small amounts of time compared to any optimisation that had been done prior to them being joined together.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Manual storage management involves the programmer taking account for destroying all variables which are created in their piece of code. When encapsulation is used correctly each section of code should run independant of any outside variables. This means that as long as whoever programs each section of code makes sure their piece of code does not include any memory leaks then the whole program will not include any memory leaks. It will also help when attempting to find memory leaks as each section of code can be tested seperatly and any leaks caught.
						
						e.g. Two programmers are writing a program which takes in a number, multiplies it by itself and then finds the square root (Making sure the number is positive). The first programmer will write some code to take the number and find its square, and the second programmer will write the code that finds the square root of the number passed to it by the first programmers program.
						Once the program is complete it is tested and found to contain a memory leak. The first programmers code is then tested seperatly to determine if the leak is contained in that section, the second programmers code would then also be tested being fed numbers by a testing program rather than the first programmers code. The leak would hopefully then be found and dealt with.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						In a system using Design by Contract each method essentially says &quot;As long as the data you are passing to me satisfies the pre-conditions then I can guarentee it will satisfy the post-conditions&quot;. In order for this to be true the method would have to be entirely self contained or have a similar contract between any other methods. Any class invariants being used would also ensure that they would satisfy throughout the whole class. Essentially all of these classes / methods would hide all their workings from their clients, providing them with an abstract and the pre/post - conditions. This is encapsulation.
						e.g. A method wants to ensure using Design by Contract that if it is given a number between 1 and 10 as a argument it will take that number and it wants to guarentee it will return a number between 6 and 20 (adding a random number between 5 and 10). In order for the method to value its guarentee it will need to be certain that given the pre-condition nothing can stop it from giving a required answer. The only way it can guarentee this is if it is encapsulated.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							A contract is an agreement between classes that if one class wants to call another classes methods as long as its arguments satisfy the pre-conditions set by the method it will give a result satisfying the methods post-conditions. As long as all classes/methods abide by their contracts then it can be guarenteed that any program using those methods will get a correct result (unless there is a logic error or something in the program itself but I will ignore that possibility for now). Defining contracts would depend on their use in a program, if the desire was just to get a program not to crash then a weak pre-condition would be used, if the pre-condition is for some sort of specialised method that although it will work with other values only actually wants values between certain values then a stronger pre-condition would be used. This is similar to post-conditions where the weakest post-condition contains all possible results and stronger post-conditions only contain subsets of this data.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							In order for a square root to be calculated the number supplied to the method would have to be greater than or equal to 0 as there is no square root for numbers less than 0, this gives a suitable pre-condition for this method. When finding out a square root it can always be guarenteed that the result will also be greater than or equal to 0, this would be a suitable post-condition however we can make it stronger as we could also for instance say that the square root will always be less than or equal to half of the number given (except for when the number given is 1).
							
							For this method the pre-conditions and post-conditions would be (using x as the number provided and y as the asnwer) :
							Pre-Condition : ( x &gt;= 0 )
							Post-Condition : ((y &gt;= 0) &amp;&amp; ((y &lt;= x/2) || (x == 1)))
							These would be placed in the code at the start and end of the square root method respectivly with the keyword assert placed infront of them.
							
							In the case of the class Stack the pre and post conditions will depend on wether or not the stack has a limited size. I am going to presume that is not the case as it is not explicitly mentioned in the question. This means that all the stack needs guarenteed is that the parameter being passed to it is actually a number. The post-condition will just be that the number inserted will be placed on the stack. This could be represented in code as : (using x as the number provided)
							Pre-Condition : (( x &lt;= 0 ) || (x &gt;= 0))
							Post-Condition : (Stack[stack.height - 1] == x)
							As before these would be placed in the code at the start and end of the method respectivly with the keyword assert placed infront of them.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						First the Stack would need to be populated with numbers, as the programmer I would be aware that SqRoot is later going to require that any numbers I pass to it are greater than or equal to 0 so although Stack allows negative numbers it would be best not to use any for this program. Once the Stack has been suitably populated a for loop over the length of the stack would need to get whatever value is on the top of the stack (presumably by some sort of popping method) and then passing this value to the SqRoot method. The returned results would be dealt with as required and the program would terminate. One of the benefits of using these SqRoot and Stack methods is that you feel more confident when programming, knowing a certain area of the program is going to perform exactly as it says its going to (barring any system errors) providing you satisfy its pre-conditions is a nice change. In programs not using Design by Contract when something goes wrong the problem could be anywhere in the code, this leads to another benefit &quot;less time spent searching for errors&quot;, anytime you can narrow down the area an error could have occured in is a good thing.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="8" examId="CS310105" timeTaken="5633" isSubmission="true" allImages="true">
		<compositea marksAwarded="32" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This example is sensible in that each of the methods for positions are always going to contain the methods in the superclass for footballer. the WayneRooney method is also quite sensible, as it would contain implementation of the methods from both striker and from footballer.
						An alternative way of creating this implementation in Java would be to have the code in the following style:
						
						public class Footballer {
						//other code here
						Position position = new Position(pos);
						Name name;
						}
						
						public class Position {
						//code about positions
						}
						
						By doing the implementation this way, you are avoiding having to have the seperate class for the individual players. Also, the Position class can contain code which is relavent to each of the different positions, but a method call determines which is used.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This method is sensible, as the data about a queue of traffic would be stored in a sequential data structure of some variety. However, it is only good for a static queue, as each time a car was removed or addad you would have to rebuild the whole list.
						An alternative would be:
						
						public class LinkedList{ ... }
						public class TrafficQueue extends LinkedList { ... }
						
						This would create a more efficient method of storage for the data, as each individual element in the list could be accessed quickly, and also addition and removal of items at an arbitrary point on the list is much faster than from an array.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a relatively good method of performing the inheritance, as the subcalsses would require most of the methods provided by the superclasses. However, in the case of CameraPhone it requires the use of two superclasses, which is unavailable in some languages.
						One possible alternative would be:
						public abstract class PersonalElectronicEquipment { ... }
						
						public class MobilePhone extends PersonalElectronicEquipment { ... }
						
						public class DigitalCamera extends PersonalElectronicEquipment { ... }
						
						public class CameraPhoine extends MobilePhone { ... }
						
						This requires some overlap in the methods available in DigitalCamera and CameraPhone. However, this is partially balanced out by the fact that, although slightly less efficient, the solution can be carried out in most programming languages.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a relatively poor implementation, as the Copyable class is providing a method as concrete and not as abstract. Therefore, the programmer has no control over the operation, and may as well just use the inbuilt clone methods. A better alternative would be:
						public class Copyable{
						public abstract Object copy();
						}
						
						public class Book extends InformationSource, Copyable { … }
						
						This allows for a more dynamic usage of the Copyable class. If required, there could be another class set up with a concrete instance of the copy() method to allow for simple usage as well as the more complex alternative, e.g.
						public class CopyMe extends Copyable{
						public Object copy() {...}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a relatively good implementation of the methods. However, it could be argued that a lot of the methods in the NoAnswerProvided and NoAnswerRequired methods would be the same, meaning there would be duplicated code in the program. An alternative to get round this problem would be:
						public abstract class Answer { … }
						public class MCQAnswer extends Answer { … }
						public class TextAnswer extends Answer { … }
						public abstract class NoAnswer extends Answer { ... }
						public class NoAnswerProvided extends NoAnswer { ... }
						public class NoAnswerRequired extends NoAnswer { ... }
						This means that the problem of duplicate code is eliminated by having the shared methods in the NoAnswer class.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Encapsulation is a requirement for abstraction because without it there is no way to show that an individual piece of code (method, class, package or program) is entirely self-contained. If there is a need for an outside interface or some kind of input or output that has not been defined, then there is no way of correctly abstracting the code. For the abstraction to be accurate, you need to be able to prove that the code to be abstracted is self-contained. The easiest way to do this is to ensure it is correctly encapsulated.
						For object-oriented programming, this is a necessity as it is required for each class in the program to be abstracted away from the others so that only the interface to that class is visible, e.g. in a banking system the account viewing
						class would only need to see the interfaces to the account classes, not the inner workings of those classes, in order to operate correctly.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation can be used at runtime because it linits the amount of communication that is required between different classes in order to make the program work. This has an effect on runtime performance as there are fewer bindings between different classes to be maintained, and therefore the overall speed of the program can be increased. For example, banking software could have several classes working together in order to create the interface for the user. Instead of doing this, the whole of the code could be encapsulated into a single class. This reduces the amount of dynamic binding that the system needs to maintain, and therefore increases the overall performance of the system.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Manual storage management is a difficult task as it requires constant, up-to-date knowledge of where each method is currently running, and which objects are no longer needed in the execution. Encapsulation can help this task, as by encapsulating the execution of an operation in a single object you reduce the number of different elements that the storage manager has to deal with. Also, by monitoring the inputs and outputs from a particular object you can partially determine whether it is active or inactive. This aids in that it makes identification of areas of &apos;dead&apos; code easier, and so they can be marked for cleanup faster. For example, by encapsulating the code needed to interface between a bank&apos;s user interface and an account, you can spot when that piece of code is finished with earlier and therefore clean it up faster, reducing the memory overheads of the system.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Design by Contract (DbC) requires the programmers involved to know the inputs and outputs for each other piece of code they are going to interface with. Encapsulation allows this to occur, as it hides the inner workings of a piece of code and only shows its interfaces to the outside world, which is what is required by DbC. Also, this makes decisions on the required pre- and postconditions easier, as you can see exactly where it is required that you inform other programmers of them.
						For example, if designing a bank system, the programmer designing the interface between the user interface and the account details wouldn&apos;t need to know the exact details of those classes, only their interfaces and conditions. Likewise, he would only have to inform the designers of the classes the interfaces to his code.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Contracts are introduced for the classes so that other developers using the library in the future would only need to know the contract details for each method in order to use it, as opposed to knowing the inner workings of the code.  The contracts would be defined in terms of the input required to the method and any preconditions that are associated with them and any outputs from the method. Postconditions would be used internally in the methods, in order to help avoid exceptions being generated by the outputs and operation of the method. Any postconditions arising from abnormal execution (e.g. a predefined value for a divide by zero) would also be given.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							public class SqRoot {
							public double doIt(double noIn){
							//Set an assert precondition, which will check that the input is valid
							assert (!(noIn &lt; 0)) //Ensures that the number to be rooted is not less than zero
							//square rooting code, only executed if the assert is OK
							//Otherwise, set noOut to a predefined state. Given in postconditions provided.
							return noOut;
							}
							}
							
							public class Stack {
							//code to add to stack. Would assert the value was a number first. Interface for the method provided in //documentation.
							//code to remove from stack. Interface provided in the documentation. Would assert there was an item in the //stack to be removed before operating.
							//other stack code
							}
							
							The assert statements used in the examples are not true design-by-contract methods. However, it is the closest way available in Java to simulate the requirement of pre- and postconditions. To properly ensure DbC is followed, a different language that supports it should be used, e.g. Eiffel.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The program would be roughly:
						public class rootOfStack{
						//build stack
						//populate stack with numbers
						for(int i=0; i &lt; stack.getSize(); i++)
						//Square root each value on the stack
						}
						The SqRoot and Stack methods are useful in this case because as they are designed using design by contract you know what the interfaces to the different methods would be, and what conditions are expected on the input and output values. Additionally, any conditions on the outputs would be known (e.g. divide by zero errors). This can all be done without actually knowing the operations of the methods.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="9" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="36" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Unless the functionality of each player class differs greatly then this would be a rather long winded approach.  Instead use parametisation to state what the class of Footballer is.
						
						public class Footballer {
						int playerType;
						
						public Footballer(int type) {
						playerType = type;
						}
						}
						
						Plus WayneRooney would not be a class, but an instance of a class of type Footballer.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This way would work but it is not the best way because a TrafficQueue is not an array list but contains one, even though it wants the functionality of it.  As the complexity of TrafficQuese grows then the List may only be a small part of it, so we should not inherit from it, but rather it should get the functionality of the ArrayList through delegation.  We can then even change the type of list used if we want to through dynamic binding without affecting the rest of the code.
						
						public class TrafficQueue {
						List queue;
						
						public  TrafficQueue() {
						// only set type of list here
						List = new ArrayList();
						} // TrafficQueue
						
						public add(Object obj) {
						queue.add(obj);
						} // add
						} // TrafficQueue
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Multiple Inheritance is generally not a good idea as it leads to redundent data where simialr data from inherited classes is stored, and name clashes that can be complex and hard to solve.  An example here would be battery power (a variable in PersonalElectronicEquipment). which would then also be contained in the phone and camera classes.  A CameraPhone is really just a phone, that has some of the functionality of a camera.  So the best approach would be to have CameraPhone as a subclass of MobilePhone only, but delegate functionality from DigitalCamera.
						
						public class CameraPhone extends MobilePhone {
						// its methods and functionality can now be used from within this class
						DigitalCamera camera;
						................................
						} // CameraPhone
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The class of Book should only implement the functionality of Copyable, not inherit from it. And because Book will probably want a different implementation other that the default one like above, then it will be best to implement its own version anyway.
						
						public interface Copyable {
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable {
						public Object copy() {
						.................
						} // copy
						}  Book
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Here, too many classes are used to model the questions as some of the classes are very similar.  The NoAnswerRequired and NoAnswerProvided are behaviours rather than types, they should be within other classes.  They should be flags within the top level (Answer) that the sub-classes can then use.
						public abstract Answer {
						boolean noAnswerProvided, noAnswerRequired;
						
						public Answer(provided, required) {
						noAnswerProvided = provided;
						noAnswerRequired = required;
						} // Answer
						} // class Answer
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a reusable &quot;design&quot; of code structure (rather than a reusable implementaion)  that can be applied to different situations.  It provides an archetecture for compining software components together.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The questions are going to be of different types, forming a hierachy of classes of questions, some questions will be composite questions, made up of other question classes.  For this reason we will need a composite design pattern.  We need to ensure that each different type of question, composite or not, will understand the same messages/method calls that are applicable to every question class (such as getMarksAllocated()).  So for example, suppose we have a class Question, with sub-classes of this being SimpleQuestion (say a single answer one part question) and a CompositeQuestion (made up of SingleQuestions and other CompositeQuestions, or even other types of questions).  The method in SimpleQuestion will have a simple body such as just &quot;return marksAllocated&quot;.  But the composte one will need go through each of its componants and call the getMarksAllocated() method of each one and add them up.  But because we don&apos;t know the class of Question to call the method on until runtime, we need &quot;dynamic binding&quot;, which will mean that the method for the appropiate class will be called with a call like &quot;marksAllocated += questions[i].getMarksAllocated();  (assuming that questions is an array of type Question in the composite class).  This will prevent the need for lots of &quot;if&quot; statements which can be very messy and error-prone, and can be hard to manage if more question types are added etc.  But using this composite design pattern, any number of subclasses of question can be added and the code will not need to change (as long as they implement a getMarksAllocated() method).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						Proxy - this design pattern could be used because of the distributed nature of the problem.  The remote Applets will need some way of communicating with the central server.  So a proxy object could be used to handle the communication so that it is transparent to the Applet that it is in fact communicating with a remote server.  It would implement some of the same functionality as the Applet to communicate with the server.
						Factory method - because the Applet is going to be run on many computers all of the world, it is almost certain that they will be running on different platforms.  The chances are that the program will need something that is platform specific, so object types cannot be hard-coded.  We use what is known as a &quot;Factory Method&quot; which will get the correct object via a method call such as Object instance = Factory.createObject().  It is up to the factory class to decide the correct class of object to return.
						Singleton - the answers will need to be stored persistently in some way like a database.  We need to have a class such as DBWriter that does the work of writing to the database and that we can only ever have one instance of the class (for concurrency reasons).  The singleton design pattern ensures this by allowing only one instance at any one time through the use of a private constructor called only if it is needed.
						Observer - the exam is going to be taken ion some sort of GUI where the user is going type, press buttons, and generally interact with the Applet, so we need some way of responding to the actions of the user.  This pattern uses two types of classes - Observers and Observables.  The Observers need to register what Observables they are going to &quot;listen&quot; to.  When a user interacts with an Observable (like pressing a button for example), an &quot;event&quot; is generated that is passed to the Observers that are registered with that Observable.  The Observer will then deal with that event accordingly.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="4" isMarked="true">
				<compositea marksAwarded="4" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts are used to ensure the correctness software, i.e. that it does what it is supposed to do according to its specification.  For example, that a method that is used to do a calculation of some sort will actually return the correct answer.  They will also ensure that the methods are only run under the right conditions to return a correct result.
							Contracts are defined using pre-conditions and post-conditions.  A pre-condition states the conditions that are needed for the code to execute in the first place, and a post-condtion states the condtion in the program (e.g. values of variables) must be in after excecution.  The code should never excecute when the pre-conditions are not met, and must also execute in a state satisfying the post-conditions if they are.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							class SqRoot {
							
							public real findSqRoot(Real number) {
							// because you cannot calculate the square root of a negative number, we need to ensure that the number we      // are given to find the square root of is positive, if not then we need to throw an Exception of some sort (we 	   // do not use assert because the method is public so need to deal with specific exceptions informing them that     // there call was invalid.
							
							if(number &lt; 0)
							throw new InvalidNumberException();
							
							...(some calculation to find root)
							
							// we need to check whether the calculation was correct before we return the result
							assert result * result = number;
							return result;
							} // findSqRoot
							} // SqRoot
							
							class Stack {
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="10" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="35" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In this case it may be better to have a single type of Class for an instance of a Footballer as in this example WayneRooney could be playing as a Striker one day, and as a midfielder another. You could then have a team class which consited of a group (List) of Footballers into various positions to represent the footballers present in a team. e.g
						
						public class Footballer{ /* each football is an instance of this class*/
						String name;
						int goals_scored;
						String defaultPosition; 	/* a string that stores their default position
						* could be a special class such as Position for more 				* details */
						...
						}
						
						public class FootballTeam{
						String name;
						Footballer goalkeeper;
						List defenders; List midfielders; List strikers; List subs;
						Formation f; // where formation would be a class representing the formation.
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this example the use of inheritance is ok if you only want to extend an ArrayList List. It would inherit all the methods and properties of the ArrayList class.
						
						Another way to implement this may be to do as follows:
						
						public class TrafficQueue{
						List queue;
						
						public TrafficQueue(){
						queue = new ArrayList();
						}
						
						public void addCar(Car c){
						queue.add(c);
						}
						...
						}
						
						This would allow you to use any type of List you wanted with only having to change the type of List intitialised in the constructor. The rest of the class would perform the same and carry out the operations through dynamic binding.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The class CameraPhone would not be valid due to MobilePhone and DigitalCamera not being interfaces but Classes - Java only allows multiple inheritance of interfaces not implemenations. (?)
						
						I would have interfaces Phone and Camera:
						
						public abstract class Phone extends PersonalElectronicEquipment{ ... }
						
						public abstract class Camera extends PersonalElectronic Equipment{ ... }
						
						and then have a classes for DigitalCamera -  you could have different ones as well such as DigitalSLRCamera - where the implemenation may differ condisderably and classes for MobilePhone, CameraPhone and you could also have LandLinePhone too with todays growing technology.
						
						class DigitalCamera extends Camera{ ... }
						
						class DigitalSLR extends Camers{ ...}
						
						class MobilePhone extends Phone{ ... }
						
						class CamerPhone extends Phone, Camers{ ... }
						
						class LandLine extends Phone{ ... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						As the Copyable class is only a proposed replacement and not a full replacement then the Book class may be missing features of &quot;cloning&quot; by only extending from the Copyable class.
						
						Perhaps the Copyable class should have a &quot;clone&quot; method that does exactly the same as the default &quot;clone&quot; mechanism in Java. This way the class Book will still be able to use the default clone mechanism as well as the replacement.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I think the class NoAnswerProvided is not necessary. Each different type of answer should simple return a null or blank answer if none has been given.
						
						For example if the answers were to be saved, and then allowed to be reloaded and editied, in the above example a Question may contain a reference to a NoAnswerProvided class. On reloading the data the user may enter an answer for this question resulting in the NoAnswerProvided being destroyed and a new relevant type of Answer being created.
						
						It would be better to keep the same type of Answer blank or null while saving so it can be re-edited without having to re-create and destroy classes.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							The use of contracts allows you to specify exactly what each operation (or method) does and what states it can start and end in. It helps the user to prove that their software performs to thier given specification and helps other programmers use their code.
							
							IUsing a contract allows you to control whether an operation is allowed to be run based on some pre-condition assertion, if this pre-condition evaluates to true then you can continue, else you throw some kind of error or exception. An example would be a java method accepting an integer, x,  as a parameter, and the pre-condition may be if (x &lt;0) throw SomeException();else continue with method implementation.
							Once the operation is complete you can then have a post-condition assertion which is contract so that the method ends in the stated state. Using the above example you could make the post-condition that x be greater than 5 at the end of the implementation.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							Assumption that we are dealing with integer numbers, if real numbers wanted substitute
							instances of &apos;int&apos; for &apos;float&apos; or &apos;double&apos;. Also assume various Java class libraries have been imported.
							
							class SqRoot{
							
							/**
							* Pre-condition that x is &gt;=0 else throw an IllegalArgument exception,
							* allow 0 as this would give a simple answer 0.
							* Post-condition that ans * ans = x, so that the answer squared gives
							* the original input
							*/
							public static int getSqRoot(int x) {
							
							/* Pre-condition check */
							if ( x &lt; 0)
							throw IllegalArgumentException(&quot;integer must be greater than or equal to 0, you inputted &quot; + x);
							
							/* Main body */
							int answer = 0; /*Answer used to store value of result*/
							//perform calculation of getting square root and store in &apos;answer&apos; variable.
							
							/*Post- Condition check, 2 possilbe implementations below*/
							
							/* 1. either implemented as this */
							if ( (ans * ans) == x )
							return ans;
							else
							throw SomeException(&quot;Error in calculation&quot;);
							
							/* 2. or could be implemented as this using the assert comand
							* This would throw an AssertionException if not true*/
							assert ( (ans * ans) == x );
							return ans; // return ans only applies of assertion is true
							} //end of getSqRoot method
							
							} //end of SqRoot class
							
							
							class Stack{
							/**used to store the numbers*/
							private List stack;
							
							/**
							* No pre-condition needed
							* Post condition that stack is not null, ie. has been initialised.
							*/
							public Stack(){
							//initialise stack
							assert (stack !=null);
							} //end of constructor
							
							/**
							* Pre-condition that int x is an int - this is checked at compile time by the java compiler
							* for all calls to this method.
							* Pre-condtion that x is not null - not checked at compile time, this will be checked at runtime
							* and if it is null a NullPointerException will be thrown.
							* Pre-condition that stack is not null, this should not be so as it will be initalised in the constructor
							* so doesn&apos;t need to be checked.
							* Post-condition that int x has been added to the stack - checked using another method
							* checkExists.
							*/
							public void addNumber(int x){
							stack.addElement(x); //add element to stack
							assert (checkExists(x));
							} //end of addNumber method
							
							/**
							* Checks whether a number is in the stack. Return true if it is, false otherwise
							* Pre-Condition that x is not null - checked at runtime and NullPointerException will be thrown
							* if x is null.
							* Pre-Condition that stack is not null - should be intialised in constructor hence no need to check.
							* Post-Condition that the stack is unchanged - checked at end.
							*/
							public boolean checkExists(int x){
							List backup = stack; // used to check for post-condition
							
							boolean result = false;
							
							/* Code to check for existence here */
							/*Post-condition check*/
							if ( backup != stack){
							stack = backup; //restore
							throw SomeException();
							}else
							return result;
							} //end of checkExists method
							
							} //end of Stack class
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						class SqRootOfStacks{
						
						private Stack stack;
						
						/**
						* Pre-condition that s is not null and its size &gt;0
						* Post condition that stack has been intialised to be s.
						*/
						public SqRootOfStacks(Stack s){
						if (s == null)
						throw IllegalArgumentException(&quot; cant have null stack&quot;);
						if (s.size &lt;=0)
						throw IllegalArgumentException(&quot; stack must have values in it&quot;);
						stack = s;
						
						/* Post-condition*/
						assert (stack.equals(s));
						}//end of constructor
						
						/**
						* Pre-condition that stack is not null - should not be as initialsed in constructor.
						* Post-condition that stack has not been altered.
						* method could return another Stack of square root answers if needed.
						*/
						public void getSqRoots(){
						Stack backup = stack;
						/*loop through each element of the stack
						* and get the square root of each number by calling
						* SqRoot.getSqRoot(number) - getSqRoot is static hence no need to
						* create single instance of class SqRoot.
						* The result could be printed, added to another stack or used however you
						* wanted*/
						
						/*Post condition*/
						if (!stack.equals(backup)){
						stack = backup; //restore from backup
						throw SomeException();
						} //end of getSqRoots method
						} //end of SqRootOfStacks class
						
						By using SqRoot as a static method class you don;t need to instantiate it into its own class, you can just call the method SqRoot.getSqRoot() whenever you want.
						The stack class handles exceptions to user input errors, so if you wanted this class to add numbers, you would just send the command to the Stack class.
						
						The programmer would know the results because of the contracts on SqRoot and Stack.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Software components are not just any block of software because they conform to a certain number of criteria that distinguish them from normal blocks of software:
						
						1. They use encapsulation - the implementation is hidden from the outside client. The client just knows what methods to call
						2. Use of interfaces - they provide an interface so a client or other component can see what services are available from this component, and it will know how to call them - i.e what type and number of parameters, and what to expect to be returned.
						3. Reuse - a software component should be able to be re-used in another context where its use is needed.
						4. Extensibility - a software component should be able to be extened or replaced to provide the same features and more.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="7" isMarked="true">
					<answerString>
						You would first need class to handle the data structure of a Book. These classes would be loaded from a data source such as a database storing Java Objects. You would then need beans that perform business logic - i.e perform operations that do a certain job). Such a bean could be a Book availability checker bean. This would first request the Book details from a Book Query bean based on a certain number of criteria, such as Title; Author; ISBN number etc, and then query the availability property of that Book and return a boolean value.
						
						class Book{
						String title;
						String author;
						int copies;
						int copies_on_loan;
						int copies_available; //some maybe lost, hence not just copies - copies on loan.
						/**other types of properties*/
						}
						
						Book Query bean{
						
						Book findBook(various search parameters, maybe a separate SearchQuery class to hold them){
						/*this would search for a book
						* based on the parameters and if found
						* load the data of the book into a Book class and return it
						*/
						}
						
						Book Availability bean{
						
						int checkAvailability(Book b){
						return the copies_available property of the Book b
						}
						
						int checkAvailability(set of search parameters){
						/*
						* instantiate a Book Query Bean,
						* send the query to the bean,
						* receive the response of a Book,
						* return the copies_available property or -1 if book doesn&apos;t exist
						*/
						}
						} //end Book Availability bean
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Enterprise JavaBeans allow you do access data sources and load data into a Bean.
						
						Enterprise Java Beans have two types, one (entity bean) which holds business data from a data source - such as Book data,
						and another type of bean which performs business logic - i.e actions on business data.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="11" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="25" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Striker is a footballer, denfender is a footballer, WayneRooney is a striker. The is-a test passes. But Striker and defender are actually roles played by a footballer, and the role change from time to time, WayneRooney could sometime be a defender.
						
						So an alternative and better solution would be:
						public abstract class Footballer { .. }
						public class Striker extends Footballer { … }
						public class Defender extends Footballer { .. }
						public class Role {...} //subclass for Striker and Defender.
						public class WayneRooney{
						Role currentRole;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						A trafficQueue is not an ArrayList, the is-a test fails.
						
						If TrafficQueue is implemented as a subclass of ArrayList, the the TrafficQueue has all the functionality of ArrayList, and those functionalities can not be hide from TrafficQueue&apos;s client.
						
						Alternative:
						public class ArrayList { … }
						public class TrafficQueue
						{
						private ArrayList trafficQueue;
						trafficQueue = new ArrayList();
						}
						
						TrafficQueue is now a client of ArrayList, and can now hides functionalities of ArrayList
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						MobilePhone is a PersonalElectronicEquipment, DigitalCamera is a PersonalElectronicEquipment, the is-a test passes.
						
						CameraPhone is made of a DigitalCamera and a MobilePhone, the releationship is has-a not is-a, so implement CameraPhone as subclass of MobilePhone and DigitalCamera is not the best thing to do.
						
						Alternative:
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { …
						public calss CameraPhone
						{
						private MobilePhone phone;
						private DigitalCamera camera;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Book is a InformationSource, the is-a test successed. If we only want to copy a book, we may rewrite the class Copyable using parameterisation, and then use delegation.
						
						public class Copyable{
						public Object copy(Object o) { …}
						}
						
						public class Book extends InformationSource{
						public Book copy()
						{
						Book cBook = Copyable.copy(book)
						return cBook;
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						MCQAnswer is an answer, TextAnswer is an answer, the is-a test sucesses on this two. but NoAnswerProvide is just a blank answer, is not actually a type of answer. NoAnswerReuired is not a type of Answer. we could simply use some instance variable in the Answer class to indicate this.
						Alternative:
						public abstract class Answer{
						boolean isRequired;
						boolean isProvided;
						}
						public class TextAnswer extends Answer { … }
						public class NoAnswerProvided extends Answer { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a pattern of communicating calsses and/or objects which can be customised to solve a particular design problem whithin a specific context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						There are several type of question in the exam: Multiple-Choice questions, text questions etc. Question can be an automic question or a composite question.
						
						public abstract class Queston{
						int mark;
						public abstract int getMark();
						}
						public class AutomicQuestion extends Question{
						public int getMarks()
						{
						return mark;
						}}
						public class CompositeQuestion extends Queston{
						private ArrayList subquestions;// a list of sub questions
						
						public int getMark()
						{
						int totalMark=0;
						for(int i =0 ; i &lt; subquestions.size(); i++)
						totalmark +=subquestion[i].getMark();
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Proxy pattern. The exam system is to be used from anywhere in the world, so we could apply the proxy pattern. A proxy is an object acts on behalf of another object, a proxy must has the same interface as the real object. It is very usefull when come to network comminucation.
						
						Singleton Pattern, if the answer is stored in a database, we have a class DBWriter responsible to write student&apos;s answer to the database, then have to ensure that only on instance of DBWriter is created at all time, otherwise it wiil result unconsistent or duplicate data in the database.
						public class DBWriter
						{
						private DBWriter instance
						private DBWriter(){...}
						public DBWriter getInstance()
						{
						if(instance == null)
						instance = new DBWriter();
						return instance
						}
						}
						
						Null object pattern.
						
						Flyweight pattern.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="4" isMarked="true">
				<compositea marksAwarded="2" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Introducing design by contract to avoid the system to break down easily. It is an agreement between the object and the object&apos;s caller. If an object is implemented using design by contract, then it is the caller&apos;s reposibility to ensure that the object&apos;s precondition is meet, the object only need to make sure that it deliever the correct postcondition.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="0" isMarked="true">
						<answerString>
							public class Stack{}
							public class SqRoot{}
							
							If two class A and B, A is the client of B, A tries to call B, before calling B, A should ensure the precondition of B is satisfied, and B should ensure that B&apos;s post condition is satisfied.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Finding a square root of a stack of numbers:
						each time get a new number from stack
						find its square root,
						repeat until stack is empty.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="12" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="35" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is not a good use of inheritance, as there is the possiblitly that a player could change positions, or even play in more than one position from game to game. Thus a better implementation would be to have a positions arrat stored in the Footballer class like this:
						
						public class Footballer
						{
						positions String[] = new Array();
						}
						
						This would then allow the footballer to have more than one position and it is also easier to change the position that a footballer plays in.
						
						This is also a bad use of inheritance as a footballer is not a Striker, he plays the role of a striker, so the &apos;is-a&apos; rule fails on this account. Inheritance should only be used is every instance of that class is also an instance of the class it is extending.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is a better use of inheritance as the properties of a traffic queue are not going to change and therefore it will just be an ArrayList with some extra information, such as location. It is also good as if you want to change the data structure of how the TrafficQueue is stored then you can simply change the detail in the ArrayList class without effecting other code in the TrafficQueue class.
						
						This passes the is-a rule as every TrafficQueue is a ArrayList (or is implemented as an ArrayList), and so the trafficQueue will make good use of most (if not all) of the methods defined in ArrayList.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a bad use of inheritance as a camera phone may not have all of the functionality that the Digital Camera has and therefore the notion that a camera phone extends a Digital Camera is wrong. Also it is possible to get an adapter to add a camera to a normal mobile phone, this it would be better implemented as the camera using the DigitalCamera class for example:
						
						public class MobilePhone extends PersonalElectonicEquipment
						{
						DigitalCamera camera;
						}
						
						This means that a camera can be added to a mobile phone and also that the MobilePhone class can use the parts of the DigitalCamera class that it needs.
						
						The use of inheritance for MobilePhone and DigitalCamera extending PersonalElectronicEquipment is a good one as they will share many of the same properties, such as battery, interfaces etc.
						
						Also a CameraPhone is not a DigitalCamera, it is a phone that has the ability to have some DigitalCamera properies. so every instance of a camera phone is not also an instance of a digital camera and so inheritance should not be used here.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a bad use of inheritance as it fails the &apos;is-a&apos; rule. A book is not a copyable, is has some properties that make it copyable, but it is not an actual copyable. So the implementation would be better off using Copyable, rather than entending it.
						
						public class Book extends InformationSource
						{
						public Book()
						{
						Copyable book = new Copyable();
						}
						
						}
						
						This means that the book will have the properites that it needs from copyable, without actually being a copyable. The use of inheritance to extend InformationSource is fine, as a book is an information source (although you could argue that only a reference book is an information source, but a fiction book also conveys a certain amount of information too!) and therefore has all of the properties that an information source will have.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a good use of inheritance as it take advantage of dynamic binding. This means that that at runtime the program can &apos;work out&apos; which set of methods it need to use for a particular question. This is good,as you will not know at compile time which questions will be selected. This implementation of inheritance will negate the need to have a lot of &apos;if&apos; statements of the kind:
						
						if (questionType == NoRequiredAnswer) {...}
						
						instead we can simpley have:
						
						samplequestion.mark();
						
						This will call the appropiate mark method, which can be difined within the specific answers class, e.g. NoAnswerRequired would simply return 0, while MCQAnswer would return the value assigned to the particlar anwer.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is the method used to hide implementation from the user.
						Abstraction is the definistion of how a class is used (defintion methods/variables/parameters).
						
						Encapsulation is necessary for abstraction as abstraction tries to reduce the amount of coupling between two (or more) classes. this means that one class is not inter-related to another. Encapsulation makes sure that two classes are only loosely coupled. It does this my not allowing any other class to directly access the methods/variables it defines. Instead it has a set of constucter/accessor methods that can be used by another class. This means that if you change the implementation of your class it will not effect any other classes that reference it.
						
						This is fundemental to Object-orientated software development, as the whole point of it, is to seperate entities into different classes and have them interact with each other when needed. If two classes were allowed to change each others internal properties then this would work fine, until you updated one of the classes, say changed a variable name (in the most simplist form), you would then have to go around the other class and update in references there too. This is why abstraction (and therefore encapsulation) is so important to Object-oriented software development, as using get/set methods means that you can change the variable name (which will be private) and not have to worry about the other classes breaking beacuse of the change ass they simply reference that variable as part of a get/set method. this make the development of software much easier, as you only have to ficus on the code you are changing without worrying about what else you have broken.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation can improve runtime performance via constucting the algorithms within a specfic class. By doign theis you can then make sure that the most efficient alogrith is used. For example if you store a set of results in an array. You can define the get/set methods to find the correct point in the array in then most efficient (quickest) way possible. As the array will be defined as private it means that another class can not access it directly and has to use your optomised method. Without encapsualtion any class could simply reference the array and search through it. Also via the get/set methods there is no need to copy the whole array across to the client, it can simply return the desired value(s) within the array, thus improving the runtime performance.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						For manual storage mangement you have to first check whether an object is being referenced, if it is you can not free the memory, however is it is no longer referenced then you can free the memory up that it is using. For a large system with lots of objects this can be a lengthy process and the benefits of the manual mangement would be lost by the fact that it takes a long time to process the manual stroage mangement.
						
						If you have a class which will create a lot of small objects, for example if you were mapping the contents of your shop, with the associated prices for a stock control system, this would create a lot of small objects. It would be a tedious task to go and visit each of these objects in turn to find out whether it is is still being referenced. A better implementation would be to encapsulate these objects and possible store the contents of the shop in one array/vector and the prices in another. All of the objects are then stored &apos;under one roof&apos; so you simply have to check whether anything is referenceing the encpasulated object as a whole, and if not you can free it up, rather than having to go and check each object in turn.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is an important factor in design by contract as it makes it much easier to check that the contract is being adhered to.
						
						For design by contract you will have a set of pre-requisistes and and set of post-requisites. For example is a method were to find the square root of a number passed to it the pre-requisite would be:
						x &gt;= 0
						this binds the client of the method to make sure it only calls the method if the above pre-requisite is met.The post-requisite would be:
						y = x * x
						This binds the implemeation to return a value meeting the above post-requisite as long as the pre-requisite was met.
						
						These will be implemented as invarients, i.e. they always have to be the case for the variables. With encapsulation it is easy, you can check the pre/post-requisites before and after the method calls (thet do not have to be met during the method call as they may be changing). however if the client was allowed to directly access the variables in the other class then it would be harder to check that the pre/post-requisite&apos;s were always being met. With encapsualtion only allowing access to it&apos;s implemntation via accessor methods the pre/post-requisites can simply be checked before and after these method calls. It would be impossible to mange the requisites without encapsualtion being present.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern describing how objects and/or class can be applied to a general problem to solve a problem in a specfic domain.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The composite design pattern would work something like below:
						
						Public Abstact Class Question
						{
						public int getQuestionText()
						{
						//Abstact will be defined in sub-classes
						}
						}
						
						Public Abstract Class BasicQuestion extend Question
						{
						private String questionText;
						
						public int getQuestiontext()
						{
						return questionText;
						}
						}
						
						Public Abstract Class CompositeQuestion extends Question
						{
						private Question[] questions = new Array()
						
						public int getQuestionText()
						{
						for (int i = 0; i &lt; questions.size(); i++)
						{
						(Question) questions[i].getQuestionText();
						}
						}
						}
						
						This is a good design pattern as it removes the need for and if statments to check the type of the question and then call the correct method. It simply calls the correct method using dynamic binding (working out at runtime which type of question each question actually is). This is also good as it means that we can have as many levels to a composite question as we want and it will just work, without needing to hack any code. this sort of pattern could also be used in marking scheme as the marking scheme will have the same structure as the questions, so in the above example just replace Question with Marking scheme and it will work in the same way. In the same way the disign pattern would be used to implement the answers, which would help the system to present thae data in an efficient and consistant manner (as all the structures would work along the same lines implementation of this would be very simple.
						
						
						This is a good design pattern as it can be applied to lots of different situations, e.g. modeling componets of a computer, which has parts which get broken down into sub-parts and so on.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						Proxy Design Pattern
						-----------------
						The proxy design could also be used in this system. The proxy design pattern is a method of delegating responsibilty for a method to someone else, while appearing to do it yourself. Using the example given in question 3.2 the class Question would appear to be doing the work, when actually the mehods defined in BasicQuestion and CompositeQuestion would be doing the actual work. The Question class would act as a sort of proxy and delegate the work to the correct class (via dynamic binding ant runtime).
						
						Remote Proxy Design Pattern
						------------------------
						The Remote Proxy Design Pattern could be used to efficiently get the exam to a number of people taking the exam in a remote place. If there were lots of people taking the exam in one place (e.g. a computer science department in  Nottingham and the Exam was stored in Manchester) then a proxy could be set up in Nottingham. this would mean that when the exam was accessed it would appear to go away and get it from Manchester. However if this went through a proxy then once the exam has been accessed once it could then be stored on the proxy in Nottingham. This would mean that the exam would only have to be accessed from Manchester once which would mean that if the connection between Manchester / Nottingham was slow you would only have to do this once, all subsequent users of the online exam software while appearing to get it from the Manchester server would actually be getting it from the Nottinham Proxy server, thus getting it quicker.
						
						Event Handling Design Pattern
						-------------------------
						This pattern would definitly be a benefit to the system. The system may monitor the applets ever 5 minutes or so, and save a copy of the answers all ready given incase the system goes down, however it does not want to keep checking whether the finish exam button has been pressed. So it could use an Event Handler, this would work via the exam system on the server telling the applet that it wishes to know when the finish button has been pressed. So when the user presses the finish button the applet will tell the exam system that it has been pressed. The exam system can then react to this, proably by saving the final answers. This means that the exam system does not have to constantly poll every single applet running to find out whether the finish button has been pressed.
						
						Visitor Design Pattern
						------------------
						When adding up the total marks for each student you will have to go in to every question that the student answered and get the marks the student has achieved. This will have to be done for every question for every student. This could be implemented using the visitor design pattern, this would mean that you could have a class GetTotalMarks which could go and find all of the questions that a answered and get the total number of marks. This would be implemented by having an acceptVisitor methid in the Question class, the Question class(es) would then not have to do anything else with regards to getting the total number of marks for a student.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="13" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="39" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The is-a test passed in this implementation as a striker or a defender is indeed a footballer. However this trigger the problem as discussed in the lecture notes. It triggers the is-a-kind-of and is-a-role played by problem.
						
						Role may changed over time and it&apos;s not appropriate to prototype in this manner, especially in the case &quot;class Wayne Rooney extends Striker&quot;. By doing so, we have sort of stereotyping Wayne Rooney as a permanent striker for his entire life. In which we do not know if his role will change in 10 years time. He may be a commentator after his career.
						
						An alternative will be:
						
						public class Position {..} //position that the footballer play
						public class Role{...}  // what is his profession
						
						public WayneRooney{
						Role role;
						Position pos;
						
						..........
						}
						
						Delegation in some aspect will be a better choice.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is typical a classical implementation inheritance problem as what was mentioned.
						
						If we prototype in this manner, encapsulation and the integrity of the implementation will be violated. In justifying my point, i am trying to express that when we create an ArrayList class   and TrafficQueue extends ArrayList as followed. We actually allowed the user to access the elements of his choice taken the fact that ArrayList implementation is through the use of interface and all the method calling like add(..) , remove(..) are standard.
						
						Example:
						public void addQueue(.......); //in the trafficQueue class to add an object
						
						TrafficQueue tq;
						
						instead of calling
						
						tq.addQueue(..);
						
						we can call
						tq.add(....); // through inheritance from ArrayList
						
						Encapsulation is violated.
						
						Alternatives:
						
						public class TrafficQueue
						{
						private List list;
						....
						public void add(object obj)
						{
						list.add(obj);
						}
						}
						
						in this way, it&apos;s encapsulated
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Is-a test passed here. A mobile phone is indeed a personal electronic equipment. I will say that this implementation is correct. The only thing i will find that it is not plausible is that using mulitple inheritance here may conflict as we are modelling two different entities into one.
						
						Other alternative:
						
						public class CameraPhone extends PersonalElectronicEquipment
						{
						MobilePhone mp;
						DigitalCamera dc;
						}
						
						Addressing the problem as a has-a relationship in CameraPhone extends MobilePhone, DigitalCamera. Not wise to use inheritance as digital camera/mobilephone features only contribute a fraction of the entire cameraphone capabilities.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						is-a test fail over here. A book has-a information source as what i deducted.
						
						Delegation could be used in this sense. The reason is that the criteria of inheritance in this case is not very clearly defined.
						
						Another alternative:
						{
						public class Book
						{
						InformationSource is ; //taken from InformationSource class
						Copyable cp;
						
						....
						}
						
						Inheritance in this case should only be used if we don&apos;t want copyable simply as an object in a class. As reference to the lockable example in the lecture notes where we make the class inherited from lockable class because of its criteria.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						the is-a test marginally passed here. Cause this can be view as a has-a relationship as well.
						
						The thoughts on using inheritance is right over here.
						
						However, MCQAnswer can be more than one like a composite or atomic.
						NoAnswerProvided can be done by simply a initialise a boolean variable as a check. So the class is redundant.
						NoAnswerRequired as well. Can be done by boolean variable.
						
						Time and space usage is the argument for this case.
						
						Another alternative:
						
						To be added to the abstract Answer Class;
						boolean noAnswerProvided;
						boolean noAnswerRequired;
						//remove these two classes;
						
						Others classes hold. Taken the assumption the structure of MCQAnswer and TextAnswer contained unique information.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Design is a patten of communicating classes and/or object which can be customised to solve deign problem.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Details extracted from question:
						
						1) exams have structured questions involving various types of answer.
						2) different marking manner
						
						In my own opinion, this exam software structure contains inheritance, taken the fact that there are various types of answers. Marking manner can be denoted as either using of inheritance or delegation.
						
						Composite Design pattern identify as a pattern used if we want to show subobject within objects and through the use of inheritance and delegation.
						
						This pattern can be used in methods such as calculateMarks() for the exam and MarkStrategy() exam strategy
						It allowed the fact that we do not have to focus much on the various type of question/answers when calculating the marks. Each of them is taken to as a common class. ie Question/Answers.
						
						Example.
						
						public int calculateMark(...)
						{
						for (i=0 ; i &lt; component.length ; i++)
						totalMarks += (Question/Answers) component.elementAt(i); // a vector
						return totalMarks;
						}
						In this case, all questions are taken from the parent class Question. (parent of MCQQuestion, Composite Question etc).
						
						2) MarkingStrategy(...) . Assuming each marking strategy is formed into class and by using inheritance.
						
						someInformation = (MarkStrategy) ms.getInfo(); // where MarkStrategy is the parent class and ms is a subclass
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						In my discussion, i will consider my 4 others design patterns
						1) Strategy
						2) Proxy
						3) Visitor
						4) Null Object Pattern
						
						
						1) Strategy can be used for implementing different algorithm for the same operation. In this case, the leniency of the marking scheme. This is based on assumption and in real fact, leniency factor may not applied at all.
						Different leniency factor select an different algorithm. ( I came up with this assumption because there are different marking strategies and the definition of it is very vague).
						
						
						2) Proxy, communication of method to another object . As the exam is an online system, proxy will be well-used in achieving the remote access module. communication withe the central server through proxy to the the client machine displaying the relevant information (Java Applet)
						
						
						3) Visitor
						Visitor definition is combining different operation/algorithm into a single class within the same object structure. Using this definition, we can apply this pattern in determining and collating the section of the  structure of the exam online system into one. E.g Network Communcation, Time, Communication Protocol, Events.
						
						
						
						4) NullObject Pattern. This pattern can be used esp in inheritance where check for null is being done implicitly. As the online exam system relies on inheritance and the class structure is relatively big, check for null explicitly can be tedious and erroneous. NullObject Pattern will be a good choice
						
						Example.
						NullObject Pattern can be used in the Answer classes. Used in the situation when there are no answer required or provided. Taking reference from Question 1 Part 5 where we model the two as classes.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to determine a formal agreement between me(implementor) and the client. Only thru this contract that we are able to bind the correctness and reliability of the classess in terms of its input and output. In this contract, a specification will be generated or obligated to give to aid me as an implementor to achieve the required result.
							
							I will define them in the 3 followings
							
							1)Pre-condition  (states which contraints the properties)
							2)Post-Condition (states that produce the required properties)
							3) Invariants  (states that take care of the global propeties of the class)
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							class Stack
							Attr: stackCount, MaxCount
							Methods: push()
							precondition : stack not full
							postcondition: stack updated
							pop()
							precondition: stack not empty
							postcondition: stack updated
							Invariant:  stackCount &gt;= 0 and StackCount &lt;= MaxCount
							
							class SquareRoot(...)
							{
							Methods : sqRoot(number)
							Attrib : result
							precondition: number &gt; 0
							post-condition: result = square root algorithm ( couldn think of the actual algorithm)
							
							Invariant: number &gt;= MIN_INTEGER &amp;&amp; number &lt;= MAX_INTEGER ;
							result &gt;= MIN_FLOAT &amp;&amp;    result &lt;= MAX_FLOAT;
							
							
							In stack class, we used Design by contract through the use of precondition , postcondition and invariant assertion.
							In the pre-condition, we need the verify that the push() operation will only executed if it fulfill the stack not empty precondition. If it&apos;s satisfy the precondition, method will execute and the post-condition is to update the stack.
							
							The operation goes the same for pop() operation.
							In the class we initialise a class invariant, to keep track that the stackCount is within bound upon each call.
							
							In sqRoot class,
							We need to justify the precondition through checking the number &gt;0 as we know that 0 and negative number will result in exception(no answer). If precondition is justify , it will yield the properties satisfying the post condition which is the sqroot answer.
							
							Invariant: we have to take note of the max and min value of the variables used in this class and make sure they don;t go out of bound resulting in exception
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						As reference from the question 4.1, the stack class and sqroot class is projected.
						
						The benefits of using this Design-by-contract is some of the exception handling can done explicitly through using of assertion. We avoid the implementation methods if it break the pre-condition i.e the method will not execute . and if it breaks postconditon, the result will not return. Invariants play a part in checking the integrity and the global aspect of the properties .i.e each call to the push and pop method, it&apos;s checked against to make sure the stackCount is within bound.
						
						So through this DBc, it gives us a give precise implementation of the class.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="14" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="41" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of inheritance here is not particularly suitable. The various footballing positions do not really have an &apos;is-a&apos; relationship with &apos;footballer&apos;. Instead, these are roles played by the footballer, so delegation would be more suitable. This is particularly true if a player ever wished to change positions - by using inheritance this would be difficult to achieve, if WayneRooney ever wished to become a Defender, we would have to redefine the entire class. I would suggest an alternative like:
						
						public abstract class Role{....}
						
						public class Defender extends Role{....}
						
						public class Striker extends Role{....}
						
						public class Footballer
						{
						String name;
						private Role;
						}
						
						where Role is a client of footballer. Things like names are probably best left to parameterisation.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This example is probably best left to delegation. By using inheritance, we are fixing the storage method of the trafficQueue class, which makes the system difficult to change in the future. If the ArrayList was made a client of trafficQueue, we could provide accessor methods for other classes, and leave the actual implementation private. In this way, if we ever wanted to change the storage method, we would only ever need to change trafficQueue, and not every class that used it.
						
						public class TrafficQueue
						{
						private ArrayList[] list;
						
						//example method that we might require
						public int getPos(int pos)
						{
						return list[pos];
						}
						}
						
						So encapsultation hides the actual implementation of the class and helps to enforce modularity.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this instance we are relying on real world classifications for our inheritance heirarchy, which is not always the best idea. Here, we have multipe inheritance used to create CameraPhone, which is probably best avoided if possible. Besides, the is-a test fails on CameraPhone, because whilst it may be a MobilePhone, it has-a Digital Camera. A better solution would be to delegate to an instance of DigitalCamera within the CameraPhone.
						
						public class MobilePhone extends PersonalElectoricEquipment{.....}
						
						public class DigitalCamera extends PersonalElectronicEquipment{.....}
						
						public class Camera Phone extends MobilePhone{
						private DigitalCamera;
						}
						
						It might also be worth removing PersonalElectronicEquipment altogether, as it is likely to cause similar &apos;has-a&apos; problems, although without knowing its exact usage, this is hard to say.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The use of inheritance here is reasonably valid. Assuming that the questions were to be stored in a tree like structure, inheritance of this form would allow us to treat each one equally, which is a desirable propery of trees. The use of inheritance in a couple of cases is slightly dubious though - specifically the last two cases, as it seems wasteful to have an object created for an answer that doesn&apos;t really exist. We could alter Answer to have a default implementation for null answers, whose functions are overriden by the subclasses.
						
						The last case is dubious as it does not specify the type of question - would it be possible to have an unrequired TextAnswer, for instance, or an unrequired MCQAnswer? This would be better solved by parameterisation - simply have a boolean &apos;required&apos; in Abstract, which can then be set as true or false depending on whether the answer was required.
						
						public abstract class Answer{
						
						private boolean isRequired;
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a set of communicating classes/objects explained in a specific context in order to solve a general design problem.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						As the questions are structured, we would expect a certain heirarchy to exist within the exam - ranging from individual questions to sections right up to the overall exam. A sensible way of representing this within a program would be as a tree. One desirable property of trees is that we should be able to treat every node the same - we do not want to have to make explicit tests in order to determine the type of the node. The Composite design pattern helps to enforce this property.
						
						For instance, we may wish to call getMarks() on a node of a tree. If this was an individual question, we would want the marks for that question, wheras if it was a section, we would want the marks to be gathered for that question. Implementing this using the Composite pattern, our code might look like:
						
						public abstract class Question
						{
						public int getMarks();
						}
						
						public class singleQuestion extends Question
						{
						int marks;
						public int getMarks()
						{
						return marks;
						}
						}
						
						public class singleSection extends Question
						{
						ArrayList[] list;
						
						public int getMarks()
						{
						int sum = 0
						for(int i = 0; i&lt; list.length; i++)
						{
						sum+=(Question)list[i].getMarks();
						}
						return sum;
						
						}
						}
						
						Here we are using both inheritance and delegation together in order to achieve the required solution. singleSection inherits from Question, but leaves the actual process of acquiring marks by delegating to individual singleQuestions. This makes the system more flexible, and means that we can alter the composite storage method without changing any other code.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						An obvious pattern that would be required would be the Proxy pattern. As we have a client-server model, we need some interface that will enable interaction across that network. The Proxy method uses interfaces to allow remote systems to communicate even if the actual systems vary. In addition, changes to, say, the software on the central server would be possible without any changes required being required to the client applications, so long as the interface remained the same.
						
						The Strategy pattern might be an option, although its implementation is generally controversial and it reduces system cohesion. In this example it could be appropriate though, as the core classes of the system are likely to change less often than the actual functions used to present the information to the marker. Strategy inverts the traditional OO style by making algorithms into individual classes that then act as clients. Thus changing the algorithm only requires changing the client, rather than redefining entire methods.
						
						The Factory pattern would certainly be viable here, as we may need to mark various different exam types, and would require different marking systems for each. By defining an abstract marking system class, we could then create &apos;factory&apos; subclasses to produce individual instances of marking systems. Changing the type of marking system would then only require returning a different instance, rather than adding a series of &apos;if&apos; statements to the central code in order to determine the one we needed. Also, adding a new system would simply require the addition of a new factory subclass.
						
						It would be natural to use some sort of database to manage the questions at the server end, and the software system would require some class for manipulating this database. Typically, only one instance of the class that does so would ever be required, otherwise the data could become incoherent. The Singleton pattern would be useful in this case, as it ensures that only one instance is ever created. We make the instance a private variable of the class itself along with its constructor, and only allow its creation via a public method. This method would check the state of the intance - if it is null, then a new one can be created and returned, but if not then the constructor is not called and the old instance is returned instead.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to enforce intergrity constraints on our code in order to ensure that it functions correctly. It is impossible to reason or prove that a program is correct without some sort of formal specification, which is what Design-by-contract (DBC) provides.
							
							How DBC is actually implemented varies on the programming language, but the theory remains the same. For every function we require both a prerequisite and a postrequisite - integrity constraints that must be satisfied before and after the function respectively. Prerequisites are an obligation to the caller of the method - if they are not satisfied then the function called should not execute. Postrequisites are an obligation to the client - the designer of the function must ensure that it works as expected and produces the required output.
							
							Our contract also would require class invariants to be defined. These are properties of a class that must hold when the class is ever in an observable state (ie. upon construction  with default values and whenever a function is not executing).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The class SqRoot would probably be fairly simple, having just the one method to return the required value. It might look like:
							
							public class SqRoot
							{
							public float getRoot(float number)
							{
							//calculate number and return it
							}
							}
							
							In order to implement design by contract, we would require pre- and post-conditions on this method. One requirement is that the input is not null - this is actually a pre-condition that will be handled by Java. The compiler would not allow a null value to be passed, and so enforces this for us. We still have to worry about negative values though, as attempting to calculate the square root of these would cause problems. This could be checked using the &apos;assert&apos; statement.
							
							public class SqRoot
							{
							public float getRoot(float number)
							{
							try
							{
							assert (number &gt;= 0);
							//calculate number and return it
							}
							catch (AssertException e)
							{
							System.out.println(&quot;Error: &quot; + number &quot; is less than zero&quot;);
							}
							}
							}
							
							In this way, we verify the input to the code before it is executed. If the assert statement fails, then it raises an exception explaining the result, and our contract holds. Post-conditions are a requirement on the actual implementor of the code, who would need to catch other exceptions in order to verify that his implementation is correct. No class invariants would be required in this case, as the class has no instance variables.
							
							The stack method might use a linked list to store its stack of numbers, and would require push() and pop() instructions, along with a get() function. For example:
							
							public class Stack
							{
							private linkedList list;
							
							public void push(int i){....}
							
							public void pop(int i){....}
							
							public int get(int i){.....}
							}
							
							The Java compiler will automatically typecheck the inputs for our various methods, so we can ensure that our contract holds here. The push instruction has no other prerequisites other than this, and it is the reponsibility of the implementor to ensure that the post conditions hold. For pop and get, however, we require that the list is not empty, or that the value supplied is in range. Both of these conditions can be handled by Java&apos;s exception system - we will get an arrayIndexOutofBounds exception, so by trying and catching for these, we can ensure that the contract holds. Again, it is the responsibility of the implementor that the functions peform as they should. In this case, however, we may require a class invariant specifying that the list is not null. This could be implemented as a boolean test function eg.
							
							public boolean validateList(void){.....}
							
							that should be executed after each function call.to the class. Then by calling
							
							assert validateList();
							
							we can verify the class invariant.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Using the code above, the code might look something like:
						
						public class stackRooter extends SqRoot
						{
						private Stack myStack;
						
						public stackRooter()
						{
						myStack = new Stack();
						}
						
						public float sumStackRoots() //method for summing all the roots of the stack
						{
						int sum = 0;
						for(int i = 0; i&lt; myStack.getLength(); i++)
						{
						sum+= getRoot(myStack.getRoot(i));
						}
						return sum;
						}
						
						//Various other manipulation methods....
						}
						
						The obvious benefit is that we now know the every function that uses SqRoot and Stack is automatically verified using design by contract. My outline code above uses an instance variable of Stack - every function call to this instance is now guarateed to be correct (providing the pre-conditions for the stackRooter class hold) as they have been implemented using design by contract. The stackRooter class inherited from SqRoot, but this causes no problems, as the pre and post conditions are transfered across to the child class.
						
						Using classes that have been implemented using DBC makes it far easier to reason about the correctness of programs. Without it, we have no easy way of proving correctness, and tracking down errors is also made far more difficult.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="15" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="52" isMarked="true">
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class Striker extends Footballer { … }
						public class Defender extends Footballer { .. }
						
						do both seem to pass the &quot;is-a test&quot; as a Defender is a Footballer and a Striker is a Footballer, but, actually, Defender and Striker are roles played by a footballer, and these roles may change, and a Footballer can have many roles. So a better way to do this would be to have a class footballer which delegates to a collection of different roles:
						
						public abstract class FootballingRole { .. }
						public class Defender extends FootballingRole { .. }
						public class Striker extends FootballingRoles { .. }
						
						public class Footballer {
						private FootballingRole [] roles;
						private name;
						
						public Footballer(String name, FootballingRole [] roles) {
						this.name = name;
						//maybe this.roles = roles;
						}
						}
						
						and in this way we can have an instance of a footballer, with the name Wayne Rooney. So, we are using delegation, but also paramaterising the Footballer class by a Footballer&apos;s name, (and other attributes if we wanted to add them, such as the roles if we wanted to initialise these in the constructor)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of implementation inheritance. The implementation of ArrayList is used for convenience in a TrafficQueue, and the is-a argument takes some ingenuity.
						
						This is bad use of inheritance as clients of TrafficQueue will be able to access all the methods and variables available in ArrayList, there is no way of hiding them, and we only want them to use the methods we define in TrafficQueue. A way of doing this is to realise that we could make TrafficQueue a client of ArrayList, i.e. it delegates to ArrayList, e.g.
						
						public class TrafficQueue {
						private ArrayList traffList;
						// ...etc
						}
						
						and this way, the implementation of ArrayList is not exposed to clients of TrafficQueue
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class MobilePhone extends PersonalElectronicEquipment { … } and
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						
						seem to be good uses of inheritance, as they pass the is-a test - a MobilePhone is a piece of PersonalElectronicEquipment, and so is a DigitalCamera.
						
						But,
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						is using multiple inheritance and saying that a phone is both a MobilePhone and a DigitalCamera, but really, a CameraPhone contains these two objects, so the code can be written as:
						
						public class CameraPhone {
						private MobilePhone mobile;
						private DigitalCamera camera;
						}
						
						but also, a CameraPhone is also PersonalElectronicEquipment, so we may want to have:
						public class CameraPhone extends PersonalElectronicEquipment {
						//as before
						}
						
						so we are using inheritance and delegation
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public class Book extends InformationSource, Copyable { … }
						
						is using multiple inheritance, which is very controversial because of name clashes and inheriting the same class twice (if a class is a subclass of 2 classes which both have the same superclass).
						
						I think that we should keep:
						public class Book extends InformationSource, because that passes the is-a test, a Book is an InformationSource, but perhaps we could have Copyable as an Interface, therefore, we can inherit the interface of copyable (i.e. copy()) and then implement different versions of the copy() method in the classes that implement the class.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class MCQAnswer extends Answer { … } and
						public class TextAnswer extends Answer { … }
						
						are good use of inheritance because a TextAnswer is an Answer, and so is an MCQAnswer.
						
						public class NoAnswerProvided extends Answer { … } - Does pass the is-a test, in a round about way because giving no answer is actually an answer. This is also using the Null Object Pattern, because instead of just using null for having no answer, we have an object instead, this is good use of inheritance because all nodes of the tree can be treated uniformly, i.e. the can understand the same message. Explicit testing for null is replaced with implicit selection via dynamic binding which makes the code less error prone and less libale to break if modified.
						
						For
						public class NoAnswerRequired extends Answer { … }
						I don&apos;t really understand why you would have this method, but, i think that you dont need to use inheritance for it anyway, you could have a discriminator in the subclasses of Answer, a boolean value, indicating whether an answer is required or not
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of communicating classes and/or objects which can be customised to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						If you have a hierarchy of objects, some of which are basic objects and others are composite objects, then the Composite design pattern is a way of allowing both basic and composite objects to be treated uniformly, so that they understand the same messages, via dynamic binding.
						
						So, in this example, we would have an abstract class Answer, with abstract methods which apply to all subclasses of Answer (but with different implementations for each subclass) e.g.
						
						public abstract class Answer {
						public abstract int markAnswer();
						}
						
						// An answer to a multiple-choice question
						public class MCQAnswer extends Answer {
						private int mark;
						
						public int markAnswer(){return mark;};
						}
						
						// An answer consisting of text
						public class TextAnswer extends Answer {
						private int mark;
						public int markAnswer() {return mark;};
						}
						
						// An composite answer which is an Answer, but also contains Answers
						public class CompositeAnswer extends Answer {
						private List components;
						public int markAnswer(){
						int total = 0;
						for (i=0; i &lt; components.size(); i++) { total += ((Answer)components.get(i)).markAnswer(); }
						return total
						}
						}
						
						// An Answer which the student failed to prove
						public class NoAnswerProvided extends Answer { … }
						
						Notice how we can use markAnswer() on any type of question, whether it&apos;s composite or not and we will be returned the correct mark. We could&apos;ve instead had a disciminator (such as a String) which would be used to say what type of answer it was, but this is messy, because it involves a lot of if statements, and does not allow code to be easily extended - it is liable to break because adding more Answer subclasses involves adding more cases to the if statement.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						The Proxy pattern could be used. A Proxy is an object which deals with method calls on behalf of another object. In  this example, the type of proxy object used couild be a Remote Proxy , to deal with method calls to the server. The local proxy object would help in communication with the remote server. The students taking the exam will be able to deal with the proxy object as if they were dealing with the remote server, because they would share (at least part of) the same interface. The communication with the remote server would be simplified because the details of communication would be managed by the proxy.
						
						The Strategy pattern is a convenient way of switching between different alternative algorithms by encapsulating the algorithms as classes with a common interface. So in this example, the Strategy pattern could be used to switch between the different ways of presenting the information to the marker. There would be an abstract strategy class, called e.g. InformationPresentation, then there would be various different concrete strategy classes with different implementations, depending on how the information is to be presented.
						
						The Observer pattern is a way of describing the relationship between 2 objects - Observables, which have a state which can change at unpredictable times, and Observers, who are interested in the changes in the Observables, so register an interest with them and are notified by the Observable if any such changes take place. In this example, we can use the Observer pattern when dealing with the GUI, because we can have events such as pressing a button, or entering text, being Observables i.e. ActionEvents, and the things in the GUI which need to know about changes in the state of these Observables would be the ActionEventListeners, i.e. the Observers, who register with specific Observables and are notified when the Observable&apos;s state changes, e.g. a button is pressed.
						
						Null object pattern - this is used as a result of using the composite pattern - because we have
						public class NoAnswerProvided extends Answer { … }
						Instead of using null for having no answer, we have an object instead, this is good use of inheritance because all nodes of the tree can be treated uniformly, i.e. the can understand the same message. Explicit testing for null is replaced with implicit selection via dynamic binding which makes the code less error prone and less libale to break if modified
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Software reliablility depends on precise specifications being honoured by classes and their clients. DbC views the relationship between classes and clients as a formal agreement - The purpose of introducing contracts is to have a formal agreement between classes and their clients, which expresses each party&apos;s rights and obligations. It is only by having such precise definitions of each classes claims and responsibilities can we hope to achieve a significant degree of trust in systems.
							Contracts are defined using pre-conditions and post-conditions which apply to individual methods, and also global properties that need to be preserved by all methods i.e. class invariants.
							In Java, there is limited support for DbC, and a way of declaring pre and post conditions is by using the keyword &quot;assert&quot;.
							
							For public methods in the class library, i.e. that can be called by clients, the preconditions need to be specified using Exceptions, because we need these preconditions to be true even if the asserts functionality os switched off at runtime. The preconditions of private classes, and also postconditions of both public and private methods can be done using assert statements, because these are things that have to be true.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							pre: represents the precondition, and that needs to hold before the execution of the method
							post: represents the postcondition, and that needs to hold on return from a method.
							
							public class Stack {
							
							private int counter, capacity;
							private double [] items;
							
							//pre: implicit precondition is that the constructor is passed an array of doubles
							public Stack (double [] items) {
							this.items = items;
							}
							//post: the instance variable array is initialised with the items passed to the constructor. I&apos;m not sure how you would do these using asserts. I think they just may be implicit that you ensure it happens.
							
							//The class invariants of this class are specified as assertions:
							assert counter &gt;= 0;
							assert counter &lt;= capacity;
							
							//pre: the stack must not be full, i.e. counter &lt;= capacity
							//because this is a public method, i would&apos;ve thought you needed to use exceptions, for example to check that //the x wasn&apos;t negative, but there is nothing in the specification saying that the stack cannot hold negative //numbers, but if it was a stack that could only hold numbers greater than zero, i could have:
							// if (x &lt;0) throw new IllegalArgumentException....
							public void push(double x) {
							//push a number onto the stack
							}
							//post: the number must be pushed on the stack and the counter incremented by 1, and counter will not be greater than capacity. This is checked using an assert, e.g. assert counter &lt;= capacity, but i suppose you don&apos;t really need this because it is already an invariant of the class.
							
							//pre: the stack must not be empty i.e. counter &gt; 0, and because this is a public method, i would&apos;ve thought you needed to use exceptions, but, there are no arguments to check, so i don&apos;t think an exception is needed. Instead i think you should have an assertion inside the method saying &quot;assert capacity &gt; 0&quot;
							public double pop() {
							//pop a value off the top of the stack
							}
							//post: return the value that was on the top of the stack, and decrement the counter by 1, make sure the counter is &gt;= 0. can be done by &quot;assert counter &gt;= 0&quot;, but again i&apos;m not sure whether you need to do this as its already a class invariant. But I would include it to be safe.
							
							}
							
							
							public static class SqRoot {
							
							//pre: the number is not negative i.e number &gt;=0
							//this would be done explicitly using exceptions, because it is a public method, so in theory, clients of the class //may call it with a negative number. So e.g. inside the method we would have
							// if (number &lt;0) throw new IllegalArgumentException(&quot;Number cannot be negative&quot;)
							//or perhaps if (number &lt;0) System.out.print(&quot;Number cannot be negative&quot;); return number; but this might
							//confuse a client as we are returning the same number.
							public static double findSqRoot(double number) {
							}
							//post: return the square root of the number passed in as an argument
							
							}
							
							In Java we have some implicit pre and post conditions, i.e. a precondition is the that the arguments of for example &quot;findSqRoot&quot; when it is called match the argument types in the method definition, and a postcondition is the return type.... But these are very weak.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						public class SqRootStack {
						
						public static void main(String [] args) {
						double [] items = {4, 16, 36}
						private Stack stack = new Stack(items);
						
						for (int i = 0; i &lt; stack.items.size(); i++)
						{
						System.out.println(SqRoot.findSqRoot(items[i]));
						}
						
						}
						}
						
						Because we designed the two classes SqRoot and Stack using DbC, we can be sure that the program will be reliable, i.e. it shouldn&apos;t crash, because each class has preconditions that must be met and if they aren&apos;t then they situation is handled by, for example, the user being notified that they have given a negative number when they shouldn&apos;t have. The program is correct and robust
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="16" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="41" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A striker is-a footballer but can also have his role changing over time. The change rule can be applied there and therefore it is better to use delegation instead, so its role can be changed at runtime if necessary. A class Role must be created as well. The Footballer class will then contain some properties commom to every footballer. One alternative is:
						public class Role{}
						public class Striker extends Footballer{
						Role[] roles;
						public Striker(Role role1, Role role2) {
						roles = {role1, role2};
						}
						}
						
						Similarly we would have for the Defender class:
						public class Defender extends Footballer{
						Role[] roles;
						public Striker(Role role1, Role role2) {
						roles = {role1, role2};
						}
						}
						
						public class WayneRooney extends Striker { … }
						
						This is fine. The is-a test is valid.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In this case we have  a problem with implementation inheritance.
						The clients of TrafficQueue would have access to the ArrayList methods, which we might want to hide, so that the clients cannot interfere with the ArrayList.
						It is therefore better to encapsulate ArrayList within the TrafficQueue class and declare its instance as private:
						public class TrafficQueue {
						private ArrayList arrayList;
						}
						We might also want to use the List interface instead of an ArrayList so that the type of list can be changed if required.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						Here multiple inheritance is used. This use is valid because we want a CameraPhone to be a MobilePhone and a DigitalCamera so that it can inherit all the features from those 2 classes. We do not just want CameraPhone to have 2 components.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Here we have to deal with composition. A Book consists of an InformationSource which can be copied. Therefore it is better to use delegation:
						public class Book {
						InformationSource informationSource;
						Copyable copyable;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This implementation is correct. The composite pattern is used and dynamic binding will be used at runtime.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A general pattern of communicating classes and/or objects which can be customisable in order to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The composite pattern can be used in order to treat any composite objects in a uniform manner. Therefore the composite questions and the atomic questions will be able to understand the same method declared in abstract method, and dynamic binding would then be used to chose the correct implementation of the method.
						Similarly the simple answers or composite answers woulkd be treated uniformly.
						
						The different strategies defined could be applied uniformly to the composite parts and simple parts of the exam.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						The Observer pattern could be used as well. It would be possible to define observable objects having different states and observer objects registering their interest to those observable objects. Then when the observable objects change their state, the observers are notified and act accordingly to the specific case. For example when a candidate has finished an exam he could take an action which would then be reported to the observers, whose role would be for example to store all the information entered by the candidate.
						
						The Proxy pattern could be used and allow the local machines to communicate with the central server. For example when a backup is required, a proxy object on the local machine deals with the remote communication and allows the local object to access the methods defined in the central server. The objects in the server is then in charged of storing the information. The proxy object shares the same or at least part of the same interface as the server object and allows the remote objects to communicate with the local objects.
						
						The Singleton pattern could also be used. It would be necessary to ensure that in the whole system there is only one instance in charge of dealing with one exam. This would avoid duplication of information and save memory space, as well as avoiding clashes and having information overwritten accidentally. For example one instance in the central server would be responsible for communication with one local machine.
						
						Finally the Strategy pattern could be used. It would be necessary to be able to have an abstrat class which can be then used as an interface to different concrete classes whose role would be then to evaluate the answers of different types of questions. The operation is the same: marking an answer, but the algorithms could be different depending on the type of answers (text answers or mcq answers).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Using contracts is a way of ensuring that reliability is maintained expressing the claims and responsibilites of each party. Contracts are a formal agreement made between the classes it the library and the objects using those classes (the clients). Contracts express each party&apos;s rights and obligations. The contract binds the client with preconditions: it is an obligation for him and a benefit for the supplier. Postconditions bind the suplier: they are obligations for him and benefits fot the clients. Contracts can state some properties of the system. When the methods in the class library are called and the preconditions are respected, the system will ensure to result in state specified by the postconditions. The invariants defined in the classes are properties of the instance variables which should be respected at all observeable states. When the contracts are broken, runtime exceptions will occur. Contracts also allow to control the power of inheritance. The parents&apos; invariants are inherited and logically anded to the children&apos;s invariants. The preconditions and postconditions may be redefined to be the same or weaker, or the same or stronger respectively, if the methods are redeclared. Otherwise they remain the same. Finally they provide a framework for debugging and testing as well as a method for documentation.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							The class SqRoot will have some preconditions and postconditions for the findSqRoot method.
							public class SqRoot {
							/**
							** The precondition for this method is that the given number is greater than or equal to 0.
							** This precondition is explicitly checked.
							** The postcondition is that the returned sqarae root should be less than or equal to the given number
							** and greater than 0.
							*/
							public double findSqRoot(double number) {
							double sqrRootNumber = 0;
							if(number == 0) return 0;
							else if(number &gt; 0) {
							// call the method to compute the sqare root with number being a valid argument.
							// this way we isolate the code that process the number from the code that checks for checked excpetions.
							sqrRootNumber = computeSqrRoot(number);
							}
							else {
							//throw AritmeticException;
							}
							// check postcondition
							assert sqrRootNumber &lt;= number &amp;&amp; sqrRootNumber &gt;= 0;
							return sqrRootNumber;
							}
							
							
							The class Stack will have some preconditions and postconditions for the put and pop methods.
							The class invariants should be also respected and checked before returning from the methods.
							public class Stack {
							List list; // variable holding the diferent numbers.
							// class invariants
							int capacity;
							int currentNumbers;
							int oldNoOfElements;
							public Stack() {
							list = new ArrayList();
							}
							
							/**
							** The precondition for the put method is that the stack is not full. This precondition is explicitly checked.
							** The postcondition is that the stack has been updated.
							*/
							public void put(int no){
							// if the stack is not full add the number at the end;
							if(!list.isFull()) {
							try {
							list.addLast(number);
							//check postcondition
							assert currentNumbers == oldNoOfElements + 1;
							//check for invariants
							assert checkConstraints();
							}
							catch(Exception e){}
							}
							}
							
							private boolean checkConstraints() {
							// check stack is not full
							// check currentNumbers &lt;= capacity;
							// check the total number of elements is the sum of all the elements in the list and is greater than 0
							}
							
							private boolean isFull() {
							//return true or false
							}
							
							private boolean isEmpty() {
							//return true or false
							}
							
							/**
							** The precondition for the put method is that the stack is not empty. This precondition is explicitly checked.
							** The postcondition is that the stack has been updated.
							*/
							private pop(int no)
							// if the stack is not empty get the number at the end;
							if(!list.isEmpty()) {
							try{
							list.getLast(number);
							//check postcondition
							assert currentNumbers == oldNoOfElements - 1;
							//check for invariants
							assert checkConstraints();
							}
							catch(Exception e) {}
							}
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Before calling any methods from the 2 classes, we must check that the preconditions are satisfied. Then we will get a result satisfying the properties stated by the postconditions. Also the class invariants must be preserved at any observable states.
						If we get any exceptions thrown from those 2 classes, we must re-cast them into specific ones corresponding to the program we are building.
						The class will hold an instance of the Stach class and an instance of the SqRoot class.
						Then the methods defined in SqRoot would apply to the elements in the stack.
						Using Design by contract allows to ensure that the properties of the assertions are respected and the class is bug-free.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="17" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="42" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The &apos;Is a&apos; test works for all 3 of the examples but there is the usual problem encountered when modeling real world entities.  A footballer is also a human, a human is also a mammal.... etc.  Where do you stop?  The class WayneRooney passes the &apos;Is a&apos; Striker test but the sub-class does not actually add anything else to the superclass apart form maybe skill level so inheritance should not be used.  Striker and defender do not also add enough extra functionality to warrant inheritance.  For all parametisation would be a better option:
						
						public class Footballer{
						
						String mainJob;
						Integer skillLevel;
						
						//Personal details
						String name;
						
						etc
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an examle of Implementation inheritance.  It is not a good use of inheritance because the relationship between TrafficQueue and ArrayList is a &apos;Has a&apos; relationship and not a &apos;Is a&apos; relationship.  There would be a problem if you wanted to change the data structure from an ArrayList to a Linked List for example as this would not be possible.  Also all the public methods contained in ArrayList are also available to users of the TrafficQueue class which is not good as they can access the data structure directly and in a possibly inappropriate way.
						
						An alternative would be to use delegation.
						
						public class TrafficQueue{
						
						private ArrayList queue;
						
						public void add(Object o){
						queue.add(o);
						}
						
						This solves the problems stated above.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The &apos;Is a&apos; test is valid for all of the above.  But there is a prioblem witht he multiple inheritance in CameraPhone.  There would most probably be duplication of attributes in CameraPhone for example a MobilePhone would have a serial number and so would DigitalCamera.  Also there would be duplication and name clashes of methods inherited from MobilePhone and DigitalCamera.  The cohesion has been lost as it is trying to be two things at once.
						
						A better alternative would be to use deleagtion.
						
						public class CameraPhone extends PersonalElectronicEquipment{
						
						private DigitalCamera camera;
						private MobilePhone mobilePhone;
						
						etc
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is an OK use of inheritance.  There may be an issue witht he copy method though.  It appears to only do a shallow copy which is the same as what the default implementaion of clone does in Object.  So Book should overide copy to do a deep copy because a Book might represent the text in Chapter objects wich may point to paragraph objects which may point to sentence objects.  So in a copy all the objects below chapters also need to be copied.  Also why not just overide the clone method in Object instead of a new class which does not add anymore funtionality?  The copy method returns an object, this will need to be cast checked at run-time to ensure that it is a book.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						There is an overuse of inheritance.  For the class NoAnswerProvided this can easily be tested for by an empty instance String varible returned from a call to a method such getAnswerTxt() so no inheritance is required and this could be represented by TextAnswer.  The class NoAnswerRequired is also an overuse of inheritance as it adds no more funtionality to Answer and could again be represented in TextAnswer or MCQAnswer by parametisation.
						
						public abstract Answer{
						
						Boolean answerRequired;
						.....
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Abstraction is the modelling of a (usually) real world object.  This means it is a simplification of the object and so this leads to interfaces being developed from the model.  For the interfaces to be useful they must be the only access to the object and this is gauranteed by making the internal state variables private and only allowing access via given iterfaces (methods).
						
						An example is that of a bank account, the balance must not be public so that it the changing of it can be controlled.  The abstraction of an account id that of personal details and a balance.
						
						public Class Account{
						
						private double balance;
						private PersonalDetails;
						
						public double getBalance()
						
						return blalance;
						
						}
						
						etc......
						
						abstraction leads to the main properties of the object to be identified, encapsualtion then allows this information to be stored correctly and accessed in a correct and appropriate way which represents the semantics of the abstraction.  For ecample getArea would use width and height which would be private.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation can improve runtime performance by being used to stop the creation of lots of small objects which would need to be accessed.  Storage of small objects which may only have one or two primative attributes is ineffecient in memory as the overhead of storing the data as an object can double the amount of memory needed.  Also during access if an array is used in java to store the objects more memory accesses are required to access the data due to the array being a list of pointers to the objects.  The data cannot be directly accessed in the array.  To counteract this the data values can be stored directly in an array.  This is a bit messy though and so encapsulation can be used to hide this clunky representation by having the data stored inside the class in a simple private array and providing accessor methods to access the array in a much cleaner fashion.  Also algorithms such as sorting algorithms can be swapped easily becasuse the change is only needed in one place and so a choice can be made bewtween say using an insert sort or a bubble sort depending on the nature of the data such as if it is already mostly in order use bubble for effeciency.  This could even be done at runtime by passing in a parameter to the constructor indicate which kind of sort is to be used.
						
						I have used this technique in my project which is to simulate nanoparticles.  Each particle has associated with it an energy and size.  Initially I had an array of value objects to store two doubles, the energy and size.  After learning of the above technique I used encapsualtion to store the values directly in a class and access them via indexing through getter and setter methods.
						
						Public Class Values{
						
						private double[] energy;
						private double[] Size;
						
						public void setEnergy(double energyIn, integer index){
						this.energy[index]=energyIn;
						}
						
						public double getEnergy(integer index){
						return this.energy[index];
						}
						
						same for size.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation can help with amanual storage management by allowing the use of private internal data structures to store the data.  The data stored can then only be accessed via the accessor methods provided.  There can be no direct pointers to the data stored for say in the private LinkedList.  By using encapsulation this way it is possible to change the internal data structure being used to store the data with no effect on the classes using the accessor interfaces.  This can be aided by programming to interfaces such as List, then at runtime an ArrayList could be used instead of a LinkedList for example.  Policies such as caching deleted cells can also be used, then when a new cell is needed to store data the old deleted cell can be recylced and save the creation of a new LinkedList object for example.  Also if a GC is not being used it is easier to know when to destruct a cell that is not referenced anymore by a technique such as reference counting because it is known that all references must be inside the data storgae class.
						
						An example would be the implementation if a queue:
						
						public Class QueueImplementation{
						
						private List queue;
						
						public  QueueImplementation (){
						queue = new LinkedList();
						}
						
						public add(Object in){
						queue.addLast(in);
						}
						
						public Object remove(){
						return queue.removeFirst();
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapusaltion can be used to ensure that objects being passed from class to class are of the correct type, ie they are type safe.  DbC of a class have a pre-requsite that only objects of type A may be passed in to be stored internally.  This can be gauranteed by using encapsulation of the internal data storage mechanism and only using the interfaces supplied.  An example would be a class to store catalogue item objects.  A pre-requsite is that only CatalogueItems may be stored and retrieved fron the storage object.  And only retrieved if there is more than one stored.
						
						An invariant might be that a count of items must alway be greater than 0, the size variable must be made private so that it cannot be accessed and changed directly from outside which could corrupt the variable.
						
						A post requectuisite may be that after an item is added the size is increased by one, this can be tested with the private size variable at the end of the add method;
						
						public Class CatalogueItemStore{
						
						private List items;
						private size;
						
						public CatalogueItem getItem(integer index){
						
						if (size&gt;0) return (CatalogueItem)items.elementAt(index);
						else return null;  //not pretty I know could use exception
						}
						
						public void storeItem(CatalogueItem itemIn){
						items.add(itemIn);
						size++;
						}
						
						public void removeItem(integer index)
						if (index&lt;size &amp;&amp; size &gt;0) {
						items.removeElemenetAt(index);
						size--;
						}
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of classes/objects, which can be customised to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The composite design pattern could be used to represent the answers of the exam.  You would have an abstract superclass called Answer and the two subclassed called MultipleAnswer which uses can comprise of other Answer classes.  The other sublcass would be an AtomicAnswer.  This is an elegant way of representing and storing the answers as it allows the different answer types to be treated the same by software using the classes such as the server.  For the implementation of the collaborative marking the Answer class could have a method called isCollaborative which returns a boolean as to whether is is or not.  The server could call this on any type of Answer class and it would be understood by the class.  This allows simpler programming and no testing of which type of subclass the answer is.  I think its better to parameterise this collaboration area than to extend Answer class because the collaborative naswer does not add that much extra functionality.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						A proxy design pattern could be used for the connection form the applets to the central server.  The applets would use the identical methods of the proxy class, which would have the same interfaces as the real server class, to pass the answer objects and other information onto the server.  To enable this an abstract superclass of Connection would then be extended by the proxy class and the actual server class, this way they can both be gauranteed of the same interfaces.  The proxy would then communicatio directly with the server class.  This makes the process cleaner for the applet as the grubby part of sending the data is left to the proxy.  Also the proxy could also add security by checking the crudentials of the person using the applet and cyphering the data to be sent.
						
						A observer pattern could be used by the server to repsond to messages by the applet, the server would register itslef to the applet as an observer and the applet would become the observed.  Then when an answer was entered the applet would fire an event containing the answer to the listening server, the server would then process the answer.  This is a helpful pattern as when the answer willbe entered is unpredictable.
						
						A flyweight pattern could be used to store the answers to stop the creations of many small answers objects.  When a answers is required by the applet it would ask the server for the answers object.  The server would then use a factory to create the answer object if it was not already created.  This would also help if any of the answer objects changed as they would only have to be changed once.
						
						A factory pattern could be used to create the different types of answers, a factory to create non collaborative answers and a factory to create collaboratorive answers.  This would simplify the creation of the two types of answers as once it has been defined which type a answers is a new one can be created without any test statement such as if or switch statements to test which type needs to be created.  This is a good thing because such tests are liable to error and it makes the system extensible by allowing new types of answers to be added without changing the original classes code.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="18" examId="CS310105" timeTaken="7147" isSubmission="true" allImages="true">
		<compositea marksAwarded="48" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Hmph! Taxi!
						Anyhow, this use of inheritance seems to be reasonable - although it is extremely limited in terms of expandability etc etc.
						For example: WayneRooney is-a Striker may only be valid for a certian amount of time. The other roles (Striker &amp; Defender) are somewhat fixed in their implementation as an actual &quot;persion&quot;. This means someone who is-a Footballer cannot also be-a photographer and the like - unless multiple inheritance is used (which is rather icky).
						
						A more sensible solution would be to start from the ground up with classes such as
						
						public class Human {
						String firstName, lastName ...;
						List abilities = new ...();
						List jobs = new ...();
						etc...
						}
						
						public interface Job {
						public String name();
						public String description();
						etc...
						}
						
						public class Footballer implements Job {
						public String name() { return &quot;Footballer&quot;; }
						public String description() { return &quot;Kicks balls, things, other things and self, for a living.&quot;; }
						}
						
						public class Striker extends Footballer {
						public String description() { return &quot;Strikes out on their own. Supposed to bring the ball home in the opposition&apos;s net. Seldom does.&quot;; }
						}
						
						public class Striker extends Footballer {
						public String description() { return &quot;Strikes out on their own. Supposed to bring the ball home in the opposition&apos;s net. Seldom does.&quot;; }
						}
						Et cetera. An alternative would be to have Footballer as an abstract class wtih a few extras defined (you could have a general vocation catagory &quot;Sport&quot; within a package &quot;java.vocations&quot;, for example) that would never be implemented (if you wanted someone to be classified as being able to play many different parts within football, you could simply give them a fixed instance of each job kind - perhaps even have a &quot;currentJob&quot; instance variable to hold the job instance for which they are currently working).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Again, another rather obvious use of inheritance - you&apos;re implementing a queue, and so you extend a form of first-in first-out listing object (or at least, perhaps you should?).
						The likely problem with this is that the general methods (add(), remove() etc) applicable to the ArrayList class may not always be as descriptive or, indeed, suitable to the task as it was for the original class.
						Something more appropriate would be to use delegation. This is where a class provides accessor methods of its own making for an instance variable. In this case:
						
						public class TrafficQueue {
						ArrayList queue = new ...();	// Allows for easier modification at a later date
						
						public void addToQueue(RoadEntity obj) { queue.add(obj); }
						
						public RoadEntity removeHeadOfQueue() { queue... getFirst() ?; }
						
						public RoadEntity removeFootOfQueue() { .. } // People may get fed up of waiting?
						}
						
						Where RoadEntity would be a generic abstract object representing anything which could appear in the queue: cars, lorries, general vehicles, confused pedestrians (a Walrus, maybe?), etc.
						
						This form of delegation would be better suited to the purpose so that the class may be more easily upgraded in the future (for instance: to use a better data structure).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Gah! Gharstly use of Multiple Inheritance! Ah well. Again, it seems somewhat an obvious way in which to use MI. Though perhaps a little inelegant? Multiple Extends are very controversial (which is why Java doesn&apos;t implement them, perhaps?) and can often be done in another way (using single extends or multiple interfaces, for instance).
						
						The use of the abstract class PersonalElectronicEquipment *could* be forgivable. Though it may be more suitable to have it as an interface and then have other interfaces which implement it. Or it may be more suitable to keep the abstract class and then have interfaces which implement it. That all depends upon the purpose of the intended classes.
						
						Anyhow, a (perhaps) better solution than the above would be (for the sake of typing, assume PersonalElectronicEquipment is still an abstract class):
						
						public interface MobilePhone extends PersonalElectronicEquipment {
						// Mobile phone specific methods
						}
						
						public interface DigitalCamera extends Persona... {
						// Camera specific methods
						}
						
						public interface CameraPhone implements MobilePhone, DigitalCamera {
						// Hybrid methods
						}
						
						The interfaces would then be implemented in specific classes of mobile phone (E.G. Nokia 6670). That makes slightly more sense than the MI extends used above (and is certainly nicer).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Another gharstly use of multiple extends! Arrgh!
						In Java, cloneable is an interface - if we seek to replace that function (or improve it), we should follow suite. And not just for the purpose of the fasion trend. MI extends are not a good thing - they&apos;re messy (what do you do with conflicting method names etc etc) and, as stated previously, should not be used for trivial purposes (as this is).
						An interface is *required* for this purpose as only the implementing class will know how to copy its self.
						
						public interface Copyable {
						public Object copy();
						}
						
						public class Book extends InformationSource impements Copyable {
						public Object copy() { ... }
						}
						
						Nicer, eh?
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Right...
						
						This is an almost-reasonable solution ot the problem. Here we see that Answer is an abstract entity in its own right and extensions to fulfill the other kinds of answers which are possible.
						
						This is not so nice, though, as answers are invariable tied to questions! It would be better to implement a system which contained a static representation of the various questions which then provides a mirror-like data structure of the answers to those questions.
						But, as we intend to implement only the answer side of the system:
						
						The Composite design pattern can be used here to better effect. The answers can be built up into a tree like structure to mirror the supposed question structure:
						Q1: A { a1, a2, a3 } B { b1, b2}
						Q2
						Q4: A, B, C
						
						Etc.
						
						The abstract Answer class can be the base node of our tree - though it should be an interface with various parts to it, perhaps.
						The MCQAnswer should *not* extend another class, but provide the implementations of methods to gain the other, individual, answers. Therefore this class would be the better with which to implement our tree.
						
						eg:
						The answer interface:
						public interface Answer {
						public String getAnswerText();
						public int getAnswerNumber();
						public boolean hasSubAnswers();
						public Answer getSubAnswer(int answerNumber);
						}
						
						public class AtomicAnswer implements Answer {
						public String getAnswerText();
						public int getAnswerNumber();
						public boolean hasSubAnswers() { return false; }
						public Answer getSubAnswer(int ..) { return null; }
						}
						
						public class MCQAnswer implements Answer {
						...
						public boolean hasSubAnswers()...
						}
						
						You get the idea. I&apos;ll come back to finish the description if I have time. Bon avia.
						
						Back for a brief retinue... Maybe not. :-)
						I refer you to my brief description of the Answer class structure in Question 3.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation allows the programmer to group similar functions (or related functions) together within a single chunk of code (eg an Object).
						This is indeed a fundamental point to OO software development. It allows abstraction (by defining methods which *should* be implemented for a given data structure whose internal workings are not viewable by methods outside of that data structure - standard private/public/protected/package protection features etc) which, in turn, allows greater inter-operability and ease of modification to individual parts of any system without the requirement of modifying the system as a whole.
						For instance: having a generic class such as:
						
						public class String extends Object {
						public String getString();
						public String replaceAll(Sting find, String replace);
						public String concatenate(String);
						}
						
						Allows an entire system (even an O.S.) to be based upon this code&apos;s functionality whilst, at the same time, allowing us to completely re-implement the class at any time without having to touch a line of code in any of the other classes/methods/etc which depend upon it. (So long as the class was designed in a properly encapsulated form).
						Essentially, Encapsulation allows us to see only what we need to see to derive the desired functionality from any given class/code/etc. This, in turn, allows the code we have interfaced with to be changed at will without affecting the rest of the system in terms of functionality (as long as the public interfaces are kept the same).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation can markedly improve runtime performance by allowing other developers to use previously devised code which is, usually, better developed and more efficient than code which an inexperienced developer could come up with in a limited amount of time (using encapsulated libraries, for instance, the org.apache.regex package for regex-like String manipulation).
						It can also improve performance in other ways. In traditional procedural programming, a piece of code with the same function may be implemented several times in many places (with varying degrees of efficiency and success, supposedly). With encapsulation, it is far more apparrent where such code should be placed and therefore it is easier to make more efficient code by not re-implementing functions all over the place but keeping them grouped according to their operation and allowing for more efficient operations to come along.
						For example:
						
						org.apache.regex has been superceded in many ways by Java 1.4.2&apos;s inclusion of regex parsing in a more suitable location at java.lang.String (though slightly more limited). This benefits the system by having a base function on which to rely (though it has not replaced the original apache implementation by any stretch of the imagination) that can be optimised and upgraded as development proceeds by people whom, in theory, have more time and experience with that kind of thing and so:
						&quot;Something&quot;.regex(...); can be faster and better than any in-line implementation in a procedural package.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A good example here for (manual) storage management. Encapsulation allows objects to each have their own internal descriptions (or states - intrinsic) and also allows objects to have their own internal collection of objects - allowing tree-like, recusirve and most other kinds of data structures to be implemented with ease (and, with hotspot, reasonable efficiency). Encapsulation helps us here when we wish to store these: each class can have its own format for storage representation and then a simple class can read/write entire data structures (with many different objects) recursively or with simple loops! One example of this could be the Java Serialized functionality - where any instance which implements Serialized can have their state saved to and reloaded from a String.
						Many packages are also implementing XML like manual storage:
						
						public interface XMLalization {
						public static XMLalization loadFromXML(String XML);
						public static Sting saveToXML(XMLalization object);
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						True as DbC does not care about the internal implementation of any given piece of code - just so long as its public interface remains consistent throughout its lifespan.
						Encapsulation achieves this through the declaration of private, protected, public and package (nothing) visibility of methods, variables etc. This is required by DbC because if any piece of code was able to change any piece of any other code, the entire system would be liable to collapse as there would be no certainty of state nor of service.
						EG:
						
						public class XMLstuff {
						private String myXMLRep;
						public String getXML() {
						return myXMLRep;
						}
						}
						
						(Yes, I know a references is returned to myXMLRep - but it *is* immutable and therefore cannot be changed).
						If XMLstuff&apos;s internal representation of its own XML was not privately defined, its output would be unpredictable as any other class/code/etc could reach into an instance of XMLstuff and modify it.
						DbC allows us to be certian of what domains various parts of a system have access to.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A Design Pattern is a general solution to a specific problem described in a general manner. This solution can then be implemented in any system. It is, essentially, a pattern which a design can follow to achieve the best known performance in a given circumstance.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The Composite Design pattern describes how a tree (or similar data structure) can be composed so that every individual element (be it a leaf, node or miscellaneous body part) can be addressed and manipulated using the same accessor/mutator methods (obviously excluding methods which are part and parcel of the unique classes themselves).
						
						This pattern can be used to design this software system in a reasonably efficient manner: with the questions within the exam represented as a tree and then the students&apos; answers to the exam contained as a simliar tree.
						
						To start with, an extensible structure for the questions should be created:
						
						public abstract Question {
						public Sting getQuestionText();
						public int getQuestionMark();
						}
						
						public class AtomicQuestion extends Question {
						public String getQuestionText();
						public int getQuestionMark();
						}
						
						public class MultiplePartQuestion extends Question {
						private Collection subQuestions;
						public String getQuestionText();
						public int getQuestionMark() {
						int marks = 0;
						for (int i = 0; i &lt; subQuestions.size(); i ++) {
						marks += subQuestions.get(i);
						}
						return marks;
						}
						public int numberOfSubQuestions() { }
						public Question getSubQuestion() { return ... }
						}
						
						That can sort out the tree-like question structure. But how can the Composite design pattern also be applied to the answer system? What about other kinds of questsions?
						That&apos;s relatively easy. All questions will have some form of description (so our essential hierarchy stands). If we want to have more complex descriptions, we can use a different format for the description instance variable - similar to a formatted text object in a modern O.S. (Objective-C Mac OS X&apos;s NFormattedText for example - pictures, fonts, alphas etc, all in one object which can be treated as a String).
						As for the answer formats: each question could be associated with a particular form of Answer Form (including a &apos;blank&apos; to be returned by a MultiplePartQuestion - unless we wished to use this to return a special kind of form to contain the sub-questions).
						
						ammendment:
						public abstract Question {
						...
						public AnswerForm getAnswerForm() {}
						}
						
						public abstract AnswerForm (extends JPanel perhaps) {
						public Answer getAnswer();
						}
						
						public class TextAnswerForm extends AnswerForm {}
						public class MultipleChoiceAnswerForm extends AnswerForm {}
						
						The answers could then be collected from these forms in their various formats (still with the Composite design pattern) and kept in a tree which reflects that of the exam Questions themselves. The answer class hierarchy would fit in with the AnswerForm class hierarchy - it would make more sense for the hierarchies to be layed out thusly:
						
						1. Each question has a specific sublcass to which it belongs (Multiple Choice, text, drawing, mixed etc).
						2. These Question subclasses have their own defined Answer subclasses which correlate to an Answer interface or Abstract Class.
						3. These Answer subclasses have accessor methods to obtain a suitable AnswerForm object for the student to answer the question.
						4. Constructors to the Answer subclasses would be fulfilled by the Question Type. etc etc
						
						The system would work as follows:
						
						The exam writer would select the question type and type in the question.
						The question subclass they selected for the question would have a choice of at least one way in which to answer the question - one or more Answer subclass objects it can instanciate.
						The question GUI would allow the writer to select the Answer subclass that they feel is appropriate to the question.
						The Answer subclass can then give any options (if there *are* any options - it doesn&apos;t do to make the system too complicated, does it?) for the kind of AnswerForm it should produce for the user to answer the question in.
						
						Of course, there could only be one Answer subclass for a particular Question type, which - in turn - has only one AnswerForm subclass for a student to write their answer into. Keeping it simple (but with the option for future complexity if desired) is the key and crowning glory of the Composite deisgn pattern.
						
						Such a design would be similar to a tree in structure - but built in 3 Dimensions (not simply a pyramid, but a pyramid of pyramids, if you would. If I had the means to draw one, I wouldn&apos;t attempt to!).
						
						The Answer hierarchy would be a similar one to the Question Hierarchy (as would the AnswerForm - though they may be specific entirely to an Answer subclass). There could also be a &quot;blank&quot; (a singleton) answer subclass for use in Multiple Part Questions.
						
						With four minutes remaining, I wouldn&apos;t attempt to write out the java. I hope that my description of the structure and a few java code examples will be sufficient.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Strategy:
						The Strategy design pattern could be used to facilitate the marking scheme of certain exams - be they automated or marked by a human.
						The basic idea of the Strategy design pattern is that a lot of essential methods, which would otherwise be spread out amongst a hierarchial data/object structure, are grouped together in a single class. The reason for this is that the implementation of these methods may change more often than the data/object structure in question (certianly applicable to the above) and it would be a pain in the proverbial to modify each individual class in the hierarchy to update the algorithm which these methods may well implement. The Strategy pattern is here to ease the development of algorithms in an OO environment.
						Here we could have a simple abstract class:
						
						public abstract class MarkingAlgorithm {
						getMark();
						markExam(Exam exam);
						}	// Most likely using a singleton pattern
						
						Which can be implemented in a few other manners:
						
						public abstract class HumanMarkingAlg extends MarkingAlgorithm {} // Provides a GUI for a human marker
						public abstract class AutomaticMarkingAlg extends MarkingAlgorithm{} // Provides default methods for automated marking
						
						And then:
						
						public class CS3101MarkingGUI extends HumanMarkingAlg {} // A nice GUI to mark this exam with!
						public class MultipleChoiceExam extends AutomaticMarkingAlg{} // Simple MI marking system
						
						
						Flyweight:
						Possibly useful in a multiple choice type exam where the answers could all by represented by a flyweight patten based system. For example, if a MC exam had 200 (simple) questions, each with an answer of A, B or C. Then a flyweight system could be used to have a default Answer object which can represent one of three answers : A B or C.
						That is somewhat simplified. Perhaps it would be more appropriate to have the flyweight pattern associated with the formatting of an exam - perhaps for a DTP exam where one of the questions required the appropriate formatting of a provided document. The Flyweight pattern would be an efficient way of storing the formatting used and then to allow easy analysis by computer or recreation for a human marker.
						
						
						Factory Methods (Singletons)interface
						For exams where there are only a given number of possible answers (multiple choice?) or where there are many question nodes which may go unanswered, the Singletons pattern may well be very suitable. This is where a factory method is used to supply a default object which may be used more than once. The factory method is responsible for keeping an eye on the number/creation of certain objects in a system.
						For this context, a singleton method could be used to create the default objects to represent answers in a multiple-choice question - or perhaps to supply the blank or basic answers which some questions may ask the student to work from.
						This would improve the efficiency of the basic question/answer datastructure. It would also be useful to supply the &apos;blank&apos; answer forms for the Multiple Questions in the above answer.
						
						
						Visitor
						The Visitor pattern may be suitable for the marking algorithm as opposed to the Strategy design pattern.
						The Visitor pattern would be to create a standard accessor method for all of the exam questions/answers and then have an algorithm object/set of objects which would &quot;visit&quot; each node in turn. This allows large complicated exams to be marked and &quot;visited&quot; by the marking algorithm without the algorithm needing to know the overall structure of the exam paper or be modified if the structure is ever modified.
						Useful if the system is to be revised regularly (which we assume that it shall be, at least during the first few years of its existence).
						
						An alternative use of Visitor would be to &quot;collect&quot; the exam answers, at the end of an exam, into a useful data structure to be marked. An algorithm could &quot;visit&quot; each question in turn, and collect the Students answer if they have answered it - and any other relevant data. Thus building an answer-tree as it goes.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="19" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="50" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In this  example the is-a test applies. I.e a stirker is a footballer etc. However a football player may change his/her role in the team therefore this is an example of roles where by there would be a class which has a position role within it. Here is a pseudocode example.
						public abstarct class Position{...}
						public class Defender extends Position{...}
						public class Striker extends Position{...}
						public class Footballer{
						//the role of the footballer in the team. (can only be one at one in this case)//
						public Footballer(Position initialPosition)
						{
						myPosition = initialPosition
						}
						private Position myPosition;
						}
						
						Then wayneRooney can act8ally be an instance of footballer.
						Footballer WayneRooney = new Footballer(Striker);
						
						and this role can be changed over time by an accessor or mutator.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this case there is not a reason given for why a user of the TrafficQueue needs to know that it is implemented by an array list. It is therefore probably better to use encapsulation and delegation here. This means that if the write of the TrafficQueu want s to change it to use a VEctor for example they can do without effecting any clients of the class. Here is a code example.
						public class TrafficQueue
						{
						private ArrayList list;
						}
						Then any methods within the class can use the arrayList as required.
						eg
						puclic AddCar(Car c)
						{
						list.add(c);
						}
						This is probably how it should be done unless of course we for some reason wanted to treat the TrafficQueue as an ArrayList eg in a list of ArrayLists. But I think this is unlikely.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of the diamond problem. In java we could do this more easily by using interfaces. The diamond problem is bad as CameraPhone will end up with two copies of the data in PersonalElectronicEquipment. Then there will have to be a way to decide which should be used.
						Here is a code alternative.
						public abstract class PersonalElectronicEquipment{...}
						public interface MobilePhone extends PersonalElectronic equipment{...}
						public interface DigitalCamera extends PersonalElectronic equipment{...}
						public class CameraPhone implements MoblePhone, DIgitalCamera.
						Another way of looking at this is that a CameraPhone is actually a phone that uses a camera rather than being an actual phone, in which case you could delegate operations to digital camera.
						ie
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class CameraPhone extends MobilePhone{
						private DigitalCamera myCamera;
						}
						A further alternative to this is parametisation. The sollution all depends on the context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In java it would be better to use an interface here or chain the inheritance if all informationSOurces are to be copyable.
						FOr an interface we would have,
						public interface Copyable{
						public Object Copy()
						}
						
						public class Book extends Information Source implements copyable
						{
						public Object Copy()
						{
						//the implementing object must then override the copy function for its specific needs.
						}
						}
						The given code would mean that the Book would not need to override the copy functino which is bad as it may not do exactly what thebook wants it to do.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In this case the MCQ and text answers pass the is a test. But the no answer and no answer rquired do not as they are not actually answers. The no answer provided is obviously going to be an answer to a specific question that had no answer rather than saying it is an answer in itself. I think in this case I would delegate answer into the classes and that way when no answer is given to a question it could return an empty sting.
						public abstract class question{
						public answer getAnswer()
						}
						public class MCQ extends question
						{
						public Answer getAnswer(
						return MCQANswer
						} this is ok using the above code.
						If there is no answer we should return a null object .
						Im not really sue on what is the intended use for the last class in this example. I suppose if no answer is required then again it could return a message.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of communicating classes/objects that can be customised to solve a general design problem in a specific context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The composite design pattern can be used in this softwar to represent the questions with paticular types of answers. There will be questions which are basic ie have one answer and a finite number of marks and others which are composites of other answers to questions which can be basic and composite and therefor have marks which are the total of the answers given. The composite design pattern helps us to define tree like structures with simplicity. Here is a code example of how this would be used.
						public abstract class Question
						{
						//member variables and methods needed by all questions.
						//eg number or title
						//eg get marks
						private int marks;
						public int getMarks()
						}
						
						public class BasicQuestionPart extends Question{
						public int getMarks()
						{
						return marks;
						}
						}
						
						public class CompositeQuestion extends Question{
						private ArrayList questions;
						public int getMarks()
						{
						int sumMarks;
						for(/*ever question in the arrayList i*/)
						sumMArks += (Question) ArrayList.get(i);
						return sumMarks;
						}
						}
						
						This provides an elegant structure to this tree of questions. The choice of list in the composite question is something that needs to be decided upon dependant on how one wished to add and remove and order questions.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Another pattern which will be useful in this software is the RemoteProxy pattern. As all the users of the system will need to connect to a central server which holds very complex algorithms they can be encapsulated into a class at there end wich shares the interface of the classes required on the server. This means that classes on the client appear to be calling classes on the server directly but they are actually calling methods on a proxyObject which hides all the necessary information for sending this message to the server.
						Further to this, within the proxy object we could use the singleton method to ensure hat we only get one connection to the server at a time. Also this pattern could be used so that we can only get one instance of the actual exam up at a time . This would be done as folows where the client only wants to have one connection to the server.
						public class ServerConnection()
						private ServerConnection()
						private ServerConnection connection;
						public getConnection()
						{
						if(this.connection == null)
						{
						connection = new ServerConnection;
						}
						return connection.
						
						The information may be presented to users in various ways using various strategies. This suggests we could use the stategy pattern to allow the writter to employ different stategies for displaying information and can add new ones as and when required. This pattern is where an algoritm is in a class of its own and then another function will choose which stategy to choose.
						Eg
						public abstract class ShowInformation
						{
						public void showInfo();
						}
						
						public class ShowImportantInfo extends ShowInformation
						{
						public void ShowInfo(){//paticular quick method to show only important info//}
						}
						
						public class ShowInfoAsText extends ShowInformation
						{
						public void ShowInfo(){//paticular method to only show text}
						}
						
						public class ShowInfoAsGraphics extends ShowInformation
						{
						public void ShowInfo(){//paticular method graphically display indformation}
						}
						Then dynamic binding will allow us to choose the correct implementation at runtime.
						
						The observer pattern may also be applied here as the central server may whih to send out messages to the clients to let them know when to stop an exam or let them know when an exam is avaliable to begin. For example if an exam taken in many places had to be started at the same time a mesage could be sent from the control central server to the clients. This means the clients must observe the state of the system sending the message. The clients can therefore have a reciever class and the sender must obiously send the message.
						public abstract class Reciever{
						public abstract void RecieveSignal(Signal s)
						}
						//a class that listens for when the exam starts
						public class StartSignalListener extends Reciever{
						puclic void RecieveSignal(Signal s){
						startExam functions}
						}
						
						//the sender of the signal
						public class SignalSender{
						List Recievers;
						public void AddReciever(Reciever r)
						{
						recievrs.add(r);
						}
						public void RemoveReciever(Reciever r)
						{
						recievrs.remove(r);
						}
						
						public static void sendSignal(Signal s)
						{
						//for( every reciever i)
						Recievers.[i].RecieveSignal(s);
						}
						}
						public class ExamStarter extends SignalSender{
						public startExam()
						{
						sendsignal(StartExam);
						}
						}
						
						//the signal
						public Signal{..}
						public StartExam extend signal{...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							Contracts are used so that users of the library can be guranteeed that if they give any functions the correct information (satisfy any preconditions) then they will get a correct state returned form the function post conditions) and that at any observeble state the class invariants remain true. The contract binds the clients to satifying the preconditions and binds the library to satisfy the post conditions given that the pre conditions are met. The contracts are defined in the contractual inteface. For a method we have {p} M {Q} where M is the method P are the pre conditions and Q are the pos conditions. Pre and psot conditions and invariants are defined by logical operations on any conditions that may given. Ie a pree condition is something that should be true and is therefore defined  as a boolean.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Here are the outlines of the classes. Ie the interfaces.
							public class SqRoot{
							public double squareRoot(double n);
							}
							
							public class Stack{
							int NumInStack;
							elements //some internal structur possibly a vector
							
							public void push(double n);
							
							public double pop();
							
							public int GetNumInStack(){return NumInStack;}
							
							}
							
							The class square root would have one function sqrroot. I will assume we are talking about square roots of natural numebrs.
							The function would have the precondition that the argument supplied to it is 0 or greater (ie not negative) that they it is of the correct type and is not null. A post condition would be that the result is positive (obviously square roots can also be negative but we will assume this function gives the positive one) and is above 0 and is the same or smaller than the given number.
							eg
							{n &gt;=0
							n == double
							n != null}
							double result =  squareRoot(double n);
							{result &lt;= n
							result &gt; 0}
							
							inside the square root function we could ceck for exceptions where the contract has been broken by the user and then return -1 for example in which case
							squareRoot(double n){
							if(!(n &gt;=0 &amp;&amp;
							n == double &amp;&amp;
							n != null)) return -1
							else{ok do rest}
							}
							in this case we have and extra postcondition
							if(!(n &gt;=0 &amp;&amp;
							n == double &amp;&amp;
							n != null)) result == -1
							
							
							
							For a stack we have push and pop.
							A class invariant of this is that the number of items in the stack will be 0 or greater. It can never be negative. Also that the last number added is on the top of the stack.
							eg
							{I = NumInstack &lt;= 0}
							Here are some contracts for the function push. The number must be of the correct type and not null are the pre conditions. The post conditions are that the numbet pushed on willl be on the top of the stack and that the number in the stack will have increased by 1.
							
							{n == double
							n != null}
							push(double n)
							{I == true //the class invariant holds
							NumInStack == NumInStack += 1
							TopStack = n}
							
							To pop something from the stack it cannot be empty. The user must know it is not empty if it wants to do this function. The number in the stack will have decreased by 1.
							
							{TopStack = n
							NumInStack &gt; 0}
							double n pop()
							{I == true
							NumInStack == NumInStack -= 1
							n = TopOfStack
							TopOfStack = null or item below in the stack}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						If we used the programs together their contracts will merge.
						For example all numbers on the stack must now be &gt;= 0. This is that any pre conditions are now the same or weaker. If we were inheriting any class invariants will be logically anded and the postconditions must be equal or stronger.
						The class would probably be a class which uses square root and takes a stack and performs square root on the stack.
						For example we may have this function.
						Stack rootStack SqRoot(Stack s)
						
						pre conditions;
						-Elements in s must be &gt;= 0
						-Elements in s must be doubles and not null(ie not an empty stack. If an empty stack was given then an empty one would be returned)
						
						post conditions;
						-rootStack.GetNumInStack() == s.GetNumInStack().
						-The stack given is not modified (the invariant I should still hold)
						-All numbers in rootStack are less than or equal to their counterparts in s.
						-All numbers in the rootStack are greater than  0
						
						The benfits of using sqroot and stack are that we have already defined pre and post conditions to these classes so these can just be used again as shown above without having to add any more. We should have already dealt with any exceptions within methods and so they can just be used together without modification of them and without having to define new pre and pos conditions. We can just assume the logical operatios on the
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="20" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="39" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a classic case of confusing the &apos;is-a&apos; relationship with &apos;is-a-role-played-by-a&apos;. Striker and Defender are roles played by a Footballer. Subtype inheritance is not the best way to model these relationships as a Footballer may have more than one role and roles may also change over time. Also, it is probably only the personal details of a footballer that we are interested in, so a better way to structure this example would be as follows:
						
						public class FootballerDetails {...}
						public abstract class Role {...}
						public class Striker extends Role {...}
						public class Defender extends Role {...}
						public class WayneRooney {
						private FootballerDetails details;
						private Role role;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is implementation inheritance, which is controversial because delegation is usually a better way to model most cases. Rather than being a subclass of ArrayList, it would be better to TrafficQueue as a client of ArrayList (i.e. have an instance variable of type ArrayList in TrafficQueue). Furthermore, it would actually be better to declare the instance variable as type List, rather than ArrayList, as this is more adaptable to change (i.e. if the ArrayList is replaced by a different type of List in future, other code that uses this variable will not be affected).
						
						public class TrafficQueue {
						private List queueList;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Although it can be argued that the &apos;is-a&apos; test succeeds in each case of the above cases of inheritance (every instance of MobilePhone is also an instance of PersonalElectronicEquipment, and so on), multiple inheritance is rarely the best way of stucturing a relationship. It has negative consequences such as extra runtime costs and problems with name clashes. The first two cases (MobilePhone and DigitalCamera) are fairly sensible, although depending on the details of the subclasses, they could perhaps be modelled by parameterisation rather than creating two extra classes. Furthermore, it can be argued that a CameraPhone HAS-A DigitalCamera and a MobilePhone rather than &apos;is-a&apos;, which would suggest that delegation is an alternative way of modelling this relationship, e.g.
						
						public class CameraPhone {
						private MobilePhone phone;
						private DigitalCamera camera;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Multiple inheritance is rarely the best way of modelling a relationship between objects, as it adds to runtime costs (e.g. dynamic binding is more complicated) and poses problems such as name clashes (methods in more than one of superclass with the same name). In this case, Book being a subclass of InformationSource seems fine, as it passes the is-a test and we don&apos;t really know anything about the functionality of either class. However, Copyable would be better modelled as an interface rather than a class, and then implemented by Book. Also, if the subclasses of Copyable are intended to have different, overriding methods for copy(), it is better to make the superclass method abstract rather than provide a default implmentations, so that any forgotten redeclarations can be easily picked up by the compiler.
						
						public interface Copyable {
						public abstract Object copy() {...}
						}
						
						public class Book extends InformationSource implements Copyable {...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first two subclasses of Answer are sensible, as they pass the is-a test and would probably benefit from subtype polymorphism, i.e. may be used in mixed collections of Answers and may use dynamic binding to provide different implementations of the same method. However, the last two subclasses don&apos;t really pass the is-a test - they are not really types of answer.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Abstraction is the modelling of the behaviour of a module (e.g. a class), in a succinct and precise manner, via a contractual interface. Encapsulation is necessary to achieve this because it hides the implementation, which is separate from the contractual interface, from clients of the module. These two principles are necessary for achieving modularity, which is the decomposition of a complex system into highly cohesive (functionally related) but loosely coupled (not interdependent) modules.(The more encapsulation, the less coupling among modules.) Modularity is the basis of OO software development. For example,
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by Contract is about specifying exactly what functionality a class provides, i.e. what conditions need to be met in order for it to work correctly and what conditions it will meet. It is a formal agreement between a class and its clients, in the form of a contractual interface. Clients of a class need to know what it does, but do not want to know how it does it. Therefore, the implmentation is separated from the interface and hidden from the clients. Design by Contract would be very difficult without encapsulation, as it would make the interface of a class very confusing and give its clients far too much useless information. For example, a class that calculates, say, a person&apos;s Body Mass Index given their height and weight might contain some fairly complicated code, but a client of this class, say a class containing personal details, just needs to know what the BMI class does and that it will definitely do it (as well as what conditions the client itself needs to meet in order for the BMI class to work correctly). It certainly does not want access to the details of the calculation, as it would then have the ability to alter it and would be responsible for ensuring that it worked correctly.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="11" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts are useful because they make it very clear to both parties (i.e. a library class and its client) what is expected of them. Users of a library class need to know exactly what it does and need to be assured that it will do what it claims to do. The programmer of such a class has an obligation to stick to this contract, otherwise, clients can argue that the program is not correct. The contractual interface of a class would consist of: what functionality it provides (in terms of an exact specifitcation), what conditions need to be met in order for it to work correctly (i.e. its pre-conditions) and what conditions it will always satisfy (its post-conditions). Without this formal agreement between class and client, it is very difficult to argue whether or not a class performs correctly.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							Design-by-contract is not well supported in Java, as it is in other languages, e.g. Eiffel. Pre- and post-conditions, and class invariants can be specified using the &apos;assert&apos; statement, but by convention, pre-conditions for public methods should be checked explicity and exceptions thrown if they are not satisfied. An example of a definition for the contractual interface for the SqRoot class is as follows:
							Specification: the method, findSqRoot(), given a number, returns its square root.
							Pre-conditions: the number must be of type float and must not be less than zero.
							Post-conditions: the square root of the number is returned
							
							public class SqRoot {
							
							public float findSqRoot(float number) {
							// code to check that the number is not less than zero and to calculate its square root
							}
							}
							
							An example contractual interface for the Stack class is:
							Specification: the method, get(), returns the number that is at the top of the stack
							the method, add(), given a number, adds it to the top of the stack
							the method, remove(), removes the number that is at the top of the stack
							Pre-conditions: for get(), the stack is not empty
							for add(), the number is of type float and the stack is not full
							for remove(), the stack is not empty
							Post-conditions: for get(), the number at the top of the stack is returned
							for add(), the number is added to the top of the stack
							for remove(), the number at the top of the stack is removed
							
							public class Stack {
							
							public float get() {
							// code to return the number at the top of the stack
							}
							
							public void add(float number) {
							// code to check that the stack is not full and to add the number to the top of the stack
							}
							
							public void remove() {
							// code to check the stack is not empty and remove a number from the top of it
							}
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This program would consist of a class, say SqRootOfStack, which would be a client of the SqRoot and Stack classes (i.e. would have instance variables of type Stack and SqRoot, which it would take as arguments to its constructor) and would use the get() and remove() methods of Stack to go through the stack, applying findSqRoot() to each number in turn. The benefits of using SqRoot and Stack are that the implementation of how they work is encapsulated (hidden from their clients). All the client needs to know is what they do, under what conditions, and that they will definitely do it. Then it can use their methods cleanly and simply in its own code.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="21" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="32" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a fairly reasonable use of inheritance. The is-a relationship holds in that WayneRooney is-a Striker and a Striker is-a Footballer. As such, thinking from the point of view of implementing a football game for example, it would be natural for Footballer, Striker, Defender and WayneRooney to move(), kickBall(), tryToScore() etc. Using inheritance here would help with trying to re-use the code provided in those methods. Even with slightly more special cases such as GoalKeeper, this still holds fairly well.
						
						Since each footballer has a particular role on the pitch, it would probably be sensible to declare Footballer as abstract if organised games are being represented, as each Footballer will have some kind of position,even if this is simply Substitute.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is not a great use of inheritance, even though it will function fine. This is implementation inheritance, and considered slightly dubious by many programmers but its use is not clear cut good or bad. Flexibility is lost, as we cannot make any choices at runtime about which collection class to use - ArrayList is &apos;hard coded&apos; so to speak.
						
						Also, since java does not allow us to choose which methods are inherited, all the methods implemented in ArrayList can be called on TrafficQueue. Whilst obviously this provides lots of functionality, it may expose more than we want to. If we later decide to change the TrafficQueue class, we cannot make major changes to any of the methods in ArrayList as they could be used by another class, and would thus break the system. If we chose not to make them available, then we could make implementations to do whatever we wanted,in a future revision.
						
						Since TrafficQueue is simply using an ArrayList, it would be better practice to simply have TrafficQueue contain an instance of ArrayList, which is used to store the queue of traffic. In doing this, we can choose what methods are exposed to clients and which are specifically kept private.
						
						public class TrafficQueue {
						private List trafficQueue;
						public class TrafficQueue () {
						List trafficQueue = new ArrayList();
						}
						public void add(Vehicle v) {
						trafficQueue.add(v);
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In this scenario, the is-a-kind-of relationship seems to hold OK. However, this appears to be a slightly dubious use of inheritance as DigitalCamera and MobilePhone do not really have a great deal in common - some physical characteristics could be inherited, but in the main, their implementation would differ quite wildly. Given the fast-paced advances in technology, more and more functionality is being integrated into these small devices, such that we could end up with a very complex inheritance situation if the MobilePhone was to be a Radio, MP3Player and TVRemoteControl at the same time, too! Method clashes with multiple inheritance could eventually be hard to resolve.
						
						Given that multiple inheritance is not implemented in Java, the best way of overcoming this would probably be to have instance variables within the class which are of type ElectronicEquipment. This could be an ArrayList for example. Additional functionality for each device could then be implemented by putting an object of its type into the ArrayList. e.g.
						
						arrayList.add(new MobilePhone());
						arrayList.add(new MP3Player());
						
						The downside of this is that every time new functionality is added, we need to provide some kind of implementation of the methods it provides. Interfaces could also be used to specify the methods that must be present.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Copyable seems more like the kind of thing that would be implemented as an interface, as it is additional functionality but not something which specifically fits the is-a relationship. Different types of objects would likely require different code to copy their instance variables, therefore inheriting a generic version of this method seems like it would be appropriate.
						
						public interface Copyable {
						public Object copy();
						}
						
						public class Book implements Copyable {
						// code...
						public Object copy() {
						// code...
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Seems OK but the different types of anser don&apos;t have a
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is the idea of locking away parts of software that those who use it do not need to see. With a well-defined interface and an implementation that provides all the required functionality, the client should only need to know &apos;what it does&apos; and not &apos;how it does it&apos;. This is abstraction at work. Detail regarding the implementation of a class is &apos;abstracted&apos; away such that outsiders only see the details that they need to know. By doing this, it encourages better software design. Clients program their software to the interface rather than to the implementation thus reducing coupling and interdependencies between different classes, which make maintenance harder and software more complex. Encapsulation is necessary to absolutely prevent (using private methods for example) clients from seeing any parts that they do not need to see, such as instance variables or internally used methods. The fact that they cannot see the detail provides the abstraction, therefore encapsulation is fundamental to object oriented software development.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation has a role more in inreasing the maintainability and readability of software, rather than increasing its runtime performance. Allowing a client to access everything inside a class (by making all variables and methods public) might well improve performance, for example in C++ a client could get pointers to bits of the data structures in a class. Since they might bypass a fetch() method or some other code to achieve this, performance might well be increased, but at considerable cost. If anything about that data structure is ever changed - new variable added to a struct for example, then on upgrade, the whole thing is completely broken. Encapsulation forces things to be done in a coherent, logical fashion and according to the wishes of the programmer who developed the encapsulated module. This is for better design, better maintainability and better code readability, rather than an increase in raw runtime performance.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						If functions are implemented to perform storage management, then encapsulation can help by enforcing use of the required interfaces to the storage management code. Users are unable to override the sotrage management mechanisms by interfering with the data structures and/or variables.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by contract allows the usage of assertions, preconditions and postconditions to specify the &apos;allowable&apos; observable states of a program. If the programmer specifies a precondition a, and the client specifies a postcondition b, then the contract is such that &quot;If you [the client] promise to call this function such that precondition a is satisfied, I [the programmer] promise that it will always terminate in a state where postcondition b is satisfied,&quot;. In order to deliver on this promise, it is important that the code that the programmer writes cannot be accessed or used in any way other than was intended when it was constructed. Therefore, the programmer provides an interface as specified in the contract that the client will use to call the functions. If the module is not encapsulated, then the client (or someone else) could modify the state of the program by altrering instance variables, and intefering with data structures. Under such circumstances, it would be considerably harder for the programmer to be able to guarantee to uphold his part of the bargain. Thus, encapsulation is a prerequisite for Design by Contract.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Contracts are introduced to protect the interests of both the programmer and the client. Imprecise specifications can easily lead to situations where a programmer writes the code that he thinks the client wants. The client then turns around and says &quot;This is wrong!&quot;. The programmer is not an expert in the business of the client, and the client is probably not an expert computer programmer (or he would implement it himself!), so it is hard for the two to use an informal and ambiguous natural language to specify the requirements for a system constructed in a specific and formal language such as Java or C++. Using design by contract, we can identify specific points in the program and specify the state that we want the program to be in at that point. These assertions, postconditions or preconditions are specified in a formal language, thus is it possible to check that they are satisfied automatically. Using design by contract reduces the ambiguity associated with software specification, and means that it is easier to ascertain whether the programmer has implemented the specification wrongly, or whether the client has simply been imprecise about the specification of the system.
							
							Java now provides support for basic design by contract. Assertions can be put into the program which specify the states that it should be in at that point, for example if we are calculating the area of a rectangle...
							It would be nonsense to have a negative length or width.
							public area(int length, int width) {
							assert length &gt;= 0 &amp; width &gt;= 0;
							return length * width;
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							public class SqRoot {
							public static double sqRoot(double d) {
							assert d &lt; 0; // Can&apos;t have a square root of a negative (unless we implement complex numbers too!).
							return Math.sqrt(d);
							}
							
							The assertion in SqRoot prevents the client from calling the method sqRoot with a negative number, without breaking the contract - i.e. square root of a negative numbers is undefined, hence we can&apos;t guarantee what the behaviour here should be, so we write it out of the contract by putting in an assertion which says to the client that this method will only work if the assertion is true. The client understands the situation, so does the programmer.
							
							public class Stack {
							private List stack;
							public push(Object o) throws AssertionException {
							assert Object instanceOf Integer, Float, Double etc..
							stack.addElementToEnd(o);
							}
							public pop(int ref) throws AssetionException {
							assert ref &lt; stack.getNumberOfElements();
							Object o = stack.getElementAt(ref);
							stack.removeElementAt(ref);
							return o;
							}
							public int getNumber() {
							return stack.numberOfElements();
							}
							}
							
							The first assertion here (assuming you are using objects for the numbers) ensures that the object being passed is in fact some kind of number - not sure how you would do this with primitives without having lots of overloaded methods or similar. This is saying to the client that this stack is for numbers, you can&apos;t use it for putting any random objects in because we&apos;re not prepared to guarantee its behaviour under those circumstances.
							
							In the pop method, we do not want someone trying to pop an object which is outside the index range (and therefore definitely doesn&apos;t exist).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class SqRtStack {
						public static void main (String [] args) {
						Stack stack = new Stack();
						stack.push(new Double(1.2));
						stack.push(new Double(3.5));
						for (int i = 0; stack.getNumber(); i++) {
						try {
						System.out.println(SqRt.sqRoot(stack.pop()));
						} catch (AssertionException a) {
						System.out.println(&quot;Square Root of negative is not allowed.\n&quot;);
						}
						}
						}
						
						Benefits - We know that if we call the methods with anything that is not allowed, the program will not go into some odd undefined state, it will simply throw an AssertionException which we can catch and handle neatly.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="22" examId="CS310105" timeTaken="6832" isSubmission="true" allImages="true">
		<compositea marksAwarded="53" isMarked="true">
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						By using the is-a test, this use of inheritance seems to work. A striker is-a footballer, and WayneRooney is-a Striker. However, it would be more appopriate in this case to use roles, and this means that this is not a good use of inheritance. It can be said that a Footballer is a role played by a football player, as is a Defender. This is more appropriate, since it is possible for a football player to change playing positions at any time. This is advantageous, since there will only be one copy of the details of a particular player, which will avoid any abiguity which could arise if there needs to be two copies for the same player, for example, one for when a certain player is a Defender, and one when that same player is a Striker.
						The WayneRooney class should not exist, and instead should be an instance. This avoids having a class for every single player.
						The structure would look like:
						
						public class FootballerDetails { ... }
						public abstract class FootballingRole { ... }
						public class Striker extends FootballingRole { ... }
						public class Defender extends FootballingRole { ... }
						
						public class Footballer {
						private FootballerDetails details;
						private FootballingRole[] roles;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of implementation inheritance, and is therefore not a good use of inheritance. The TrafficQueue class has extended ArrayList in order to get the functionality of the ArrayList. The is-a test does not work, since a TrafficQueue is not an ArrayList.
						A better use of inheriance would be delegation. Instead of the TrafficQueue extending ArrayList, it should have a private ArrayList instance inside the class, and delegate any operations to it. This is advantageous, since it only allows users of the TrafficQueue class to access the ArrayList through certain operations. With the given code, anyone using TrafficQueue would be able to modify the contents of the list by any of the ArrayList&apos;s public methods, since they will all be visible.
						
						The structure of the code should look like:
						
						public class ArrayList { ... }
						public class TrafficQueue {
						private List trafficList;
						
						public TrafficQueue() {
						trafficList = new ArrayList();
						}
						...
						}
						
						The internal ArrayList has been defined as being of type List. This in itself is advantageous, since the programmer can change the representation of the data at any time without having to change the public interface. This was simply not possible with the code in the question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						For all of the classes the is-a test passes. For the CameraPhone class, it is both a MobilePhone and a DigitalCamera. However, the main functionality of a CameraPhone is that is it a MobilePhone, and it has a DigitalCamera as an addition. It will be better in this case for CameraPhone to just extend from MobilePhone, and hold an instance of DigialCamera, providing delegate methods to it when needed.
						
						The CameraPhone class will now look like:
						public class CameraPhone extends MobilePhone {
						private DigitalCamera camera;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						For a class extended from Copyable, the default implementation will not be able to copy instance variables unless the copy method is overridden. Also, the Copyable class should be made abstract, since this is more likely an operation to be performed on other objects, rather than on itself. Since the copy() method will need to be overridden to gain any useful functionality from the method, it is worth matking this abstract too. By making it abstract, any subclass will need to explicitly provide a useful inplementation of the copy method.
						
						A revised structure would look like:
						
						public abstract class Copyable {
						public abstract Object copy();
						}
						
						public class Book extends InformationSource, Copyable {
						public Object copy() { ... }
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test for NoAnswerRequired does not pass. It is not an answer. It is used in the case where there does not need to be an answer.
						A proposed change would be to have a different abstract supertype, Response. This will have two subtypes, Answer, and NoAnswerRequired. The heirarchy below Answer will remain the same, with the only change that NoAnswerRequired is now directly a subclass of Response. Any methods in Answer, such as one to calculate the total marks, will need to be moved to Response, and the NoAnswerRequired will simply return an appropriate value, such as zero in the case of marks for a question.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						A definition of abstraction is that all the functionality or behaviour of an object can be placed in a contractual interface. An implementation of the interface can then be implemented separately from the definition. Any implementation can simply say it is going to use a type defined by the contractual interface, and at runtime decide which implementation to use. For the users of the encapsulating class, they do not know which implementation they are using, however, they do know what the behaviour will be like, as this is defined in the contractual interface. By encapsulating the implementation of the contractual interface, this is known as information hiding.
						One such example would be to have a class which holds a list of information. At runtime it can be decided whether that data will be held in a Vector or an ArrayList or something similar. This does not matter to the users. They have a set of operations, and it will work as they expected, since both Vector and ArrayList implement the List interface.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						By programming to the interface, an encapsulated object can be changed at runtime without any disruption to anyone using the encapsulating class.
						For example, a certain class holds a Map, as it is required to hold data in key-value pairs. At first, this could be implemented using a Hashmap, since this is an implementation of the Map interface. However, at runtime, it may appear that the Map is frequently being accessed all the values in order. By swapping the Hashmap to a TreeMap at runtime, any client may notice a small drop in performance during the swap from Hashmap to TreeMap, but once that has occurred, accessing all the values in order will happen quicker using this implementation, improving runtime performance. This does not have to happen at runtime, it can happen at compile time, but will still result in an imrpoved runtime performance.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						By encapsulating a data structure within a representation of that structure, the memory management of the internal representation of the data can be handled completely separately from the memory management of the encapsulating object.
						For example, a class may hold a representation of a tree-based structure within it. By encapsulating the tree, and client of the encapsulating class must go through that class in order to access any part of the tree. This helps with the manual storage management, since it is known that only the encapsulating class has direct access to the tree, as long as the tree cannot be accessed directly by the ouside world, such as having a pointer to the structure. Therefore parts or all of the tree can be garbage collected without the fear of any dangling references to the tree from the outside world.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Design by Contract defines that any method call must have clearly defined preconditions and postcondition. If the preconditions are not met, then the method will not execute, and an executed method will always return in a state where the postconditions are satisfied.
						For a class, it will have a set of methods, and each of these methods must have a set of preconditions and postconditions. For design by contract, it must be the case that these preconditions hold before executing the method. So encapsulation is a prerequisite for Design by Contract, since calls to encapsulated objects must first be checked to see if the object is in a correct state to execute the method.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of communication classes and/or objects which can be customised to solve a general problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The composite design pattern can be used to structure the question format for the exam. An abstract class Question can have two types of subclasses, an abstract class AtomicQuestion, and a concrete class CompositeQuestion. The CompositeQuestion class will hold a list of type Question. The AtomicQuestion may have several concrete subclasses, including a TextQuestion and a MultipleChoiceQuestion. An abstract method for calculating the number of marks for each question is in the Question class. An AtomicQuestion will simply return the value of the marks for that question, and a CompositeQuestion will return the sum of the marks from each element in its list, which will recursively call until an AtomicQuestion in the list returns a value. Java&apos;s dynamic binding will take care of whether the method for returning marks is called in an AtomicQuestion or CompositeQuestion by determining its dynamic type at runtime.
						An example of the class structure is:
						
						public abstract class Question {
						public abstract int getMarks();
						}
						
						public abstract class AtomicQuestion {
						private int marks;
						
						public AtomicQuestion(int marks) {
						this.marks = marks;
						}
						
						public int getMarks() {
						return marks;
						}
						...
						}
						
						public class TextQuestion {
						
						public TextQuestion(int marks) {
						super(marks);
						}
						...
						}
						
						public class CompositeQuestion {
						private Question[] questions;
						
						public int getMarks() {
						int total = 0;
						for(int i = 0; i &lt; questions.length; i++) {
						total += questions[i].getMarks();
						}
						return total;
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						One pattern that could be used is a proxy pattern. Since the exams are going to be taken remotely, the details of handling network transfer can be hidden by using a proxy object. For example, if there was a class in the system to handle answers, an Answer object, then this could be made abstract, and have two subclasses, ProxyAnswer, and RealAnswer. The functionality will appear to be the same, since both classes are using the same interface, defined in the abstract sperclass Answer. However, the Proxy class will hold extra functionality, to transport the data over the network.
						
						The proxy pattern can be used effectively with the factory pattern in order to abstract the creation of the object. An abstract Factory class has a subclass for each of the different types that it wants to create. In this case, it will have a class for creating ProxyAnswers, and a class for creating RealAnswer. All that needs to be done, is to specify that a proxy-type answer needs to be created. The appropriate factory class is used, creating a ProxyAnswer. This will be return to the client of the factory as a type Answer, so they do not need to be worried about which style of answer is being used.
						
						The strategy pattern can be used to help with the marking. The system has been designed so that the software can employ different strategies for its presenting the information for marking. To use the strategy pattern, an abstract class holds an abstract method which will evaluate the way to present the information. It will have a parameter to the method which is the detail to be displayed. Each different strategy for presenting the information will be housed in a different class, with each implementing its strategy in the method provided by the abstract class. At runtime, any of the implemented strategies can be chosen to present the information, and at any time, more strategies can be added simply by extending another class from the abstract strategy class.
						
						A flyweight pattern can be used, for if an answer is not attempted, it will not have changed at all. By using the flyweight pattern, this will reduce the number of objects in the system, particularly if the student has not answered many questions. By doing a simple check to see if the user has made an attempt at an answer, either the answer will be sent back for marking, or a flyweight object can be returned, representing no answer at all. This can be particularly useful if client is sending data at regular intervals back to the server during the duration of the exam. At the start of the exam, the user of the exam applet may not have answered much at all, so it would be useful to send back a flyweight object to save on the load of the network. The flywieght pattern will return the same instance of an object for each copy of the instance which is equal.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="23" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="14" isMarked="true">
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						the is-a test is succeed.
						But WayneRooney can play differnet role over the time changes.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						the the TrafficeQueue representing a traffic queue in a traffic simulatin application., so it can be an interface extend  ArrayList.
						
						interface TrafficQueue extends  ArrayList{...}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The problem is Meryes&apos; dodge muptile inherientce.
						
						Public class CameraPhone {
						private MobilePhone mPhone;
						Private  DigitalCamer dCamera;
						....
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						public class Book extend Information
						{
						private Copyable copyable;
						..........
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						the class NoAnswerProvided and the class NoAnswerRequired are rlated to the class MCQAnswer and TextAnswer.NoanswerProvide can be either a MCQAnswer or a TextAnswer or enev both, and NoAnswerReqired is the same.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="2" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation is fundamental to OO software development, because:
						*As we can know a large SW can be decomposied into small modules.
						*Encapsulation also means information hidden, which hidde the implementation of the one class, and make  interface.
						* so use encapsulation we can contrac the class of the OO SW more efficient.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						As we said that Encapsulation hidde the inmplementaion of the class, when  subclasses want use the method inherite from its superclass,the implementation can be done in the superclass, it save lots of time.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Encapsulation hiddent the implenmentation of the operation.so, for the subclass of it, it doesn&apos;t need stroage to store the implentation.
					</answerString>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<freeTextAnswer marksAwarded="0" isMarked="true" notSelectedForMarking="true">
					<answerString>
						A patter of communicating with classes and /or objects which can be customied to solve general design proble with a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<compositea marksAwarded="7" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							the purpose is: we developing a class library for some OO programing languang:
							*we know that the DbC view the relationship between the the class(us, the suppiler) and the client as a formal argument or contract.We supply the libray to the client,
							*and we must make sure that we know what the client really want about the library, so we need a    specification--{p}m{q},
							- where the m is the operation, and
							- p and q is the assertation(p is the precondition,q is the postcondition). and
							*by this, the client can get a significant degree to trust our library.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							Fro the class SqRoot:we can simple know that
							*the pre-condition for this class is: the number wich is the prameter of this method,cannot negative. {p} - the number &gt;=0;
							* the post-condition is : the result of this method has two, one is Postive, and one is negative.
							For the class Stack:as we can know the class Stack has a mehtod for maintaining a stack of number.and wo need to us arraylist in this method. so
							* the pre-condition is : the index of the arraylist must be smaller that the stack size.
							* the post-condition is :the number of these numbers contains in the stack must less than the stack size.
							* the invarient is : the index of the arraylist must always less than or equal to the size if the stack.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						the program is used to finds the square roots of the stack of unmbers using SqRoot and Stack.
						{p} is the numbers in this stack must all be positive.
						m: use SqRoot to square root the number in this stack.
						{q}:
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="24" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="41" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The is-a test passes for WayneRooney because he is a striker which means that strikers methods and implementation can be placed within the Striker class. WayneRooney can then override methods for his custom implementation.
						
						Defender and Striker subclasses are defining &quot;roles&quot; of a typical footballer but as a footballers role is unlikely to change over time (change rule) then it is probably ok to use inheritance in this case. Then concrete footballers can have an implementation of whatever that do without having to have a total custom implementation for each footballer.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is bad because TrafficQueue is exposing all public members of ArrayList.
						
						I would be better to implement using a client something like as follows:
						
						public class TrafficQueue {
						private List _Traffic;
						
						public QueueTraffic(Traffic t) {
						_Traffic.Add(t);
						}
						
						public Traffic DequeueTraffic() {
						Traffic traffic = _Traffic.ElementAt(_Traffic.Length);
						_Traffic.Remove(traffic);
						return traffic;
						}
						}
						
						Notice the member of type List, so that the type of the underlying collection can be modified without having to change any code which depends on the TrafficQueue class.
						
						TrafficQueue could also implement an interface which defines its methods, eg for the Enqueue() and Dequeue()
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The is-a test passes for MobilePhone and DigitalCamera, however CameraPhone fails the is-a test when implementing everything from DigitalCamera. A CameraPhone is not a DigitalCamera. It only has some features of a digital camera.
						
						As camera mobile phones have limited resolution and capability, it would be unwise to say that a camera phone could have all the functionality of a dedicated digital camera, however this may become the case in a few years. so... we could implement as a client as follows.
						
						public class CameraPhone extends PersonalElectronicEquipment
						{
						private DigitalCamera _DigitalCamera;
						
						public Bitmap TakePhoto() {
						// or whatever
						}
						}
						
						Or, we could implement an interface on CameraPhone so that a custom implementation needs to be written for the camera features.
						
						public interface ICamera {
						protected abstract DigitalCamera;
						public abstract Bitmap TakePhoto();
						}
						
						public class CameraPhone extends PersonalElectronicEquipment implements ICamera
						{
						protected DigitalCamera _DigitalCamera;
						
						public Bitmap TakePhoto() {
						// or whatever
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The example is using multiple inheritance which has a runtime overhead and assuming all objects can be &quot;Copyable&quot;, a dynamic binding overhead for all objects. This is bad and could be handled better using an ICopyable interface and custom implementations in the subclasses. This is because all classes will require a custom implementation for their specifc instance variables. It makes little sense to add an extra level to the inheritance hierarchy when the code will be overridden anyway.
						
						public interface ICopyable {
						public abstract object Copy();
						}
						
						public class Book extends InformationSource implements ICopyable
						{
						private string _Title;
						
						public Book() {}
						
						// Copy constructor
						public Book(string title) {
						_Title = title;
						}
						
						public Object Copy() {
						return new Book(_Title);
						}
						
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The is-a test fails for NoAnswerProvided and NoAnswerRequired. These are properties of an exam question and not of the answer.
						
						It would be better to have a class dedicated to marking exams or questions and subclasses with custom marking code for each type of exam, or question type. The question could create an answer of the correct type and the properties (no answer required etc) included as members.
						
						public class Question {
						bool _AnswerRequired;
						
						public Question getEmptyAnswer() {
						return new TextAnswer();
						}
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation allows abstraction of objects from the domain of interest by allowing classes to have well defined roles with jobs to do. It allows the interface of classes to remain clean so that OO software developers can easily reuse classes without having to understand the implementation of the class (blackbox). This way a developer can create a class or set of classes to perform a particular duty or task and exchange this with his collegues whenever that particular task needs doing on other projects.
						
						It also allows for cleaner code whereby code for particluar tasks is in one place. Implemention can change over time and clients of the object do not have to have their code updated. Encapulation is the basis for loosly coupled components which are themselves &apos;abstracted&apos; entities within a system.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation can improve performance by having classes dedicated to each task which have functions or methods which perform a lot of work. This way, function calls are reduced (which have runtime overhead) and a relevant object is returned by the method. This is true computation where loosly coupled processing units are exchanging messages.
						
						Runtime performance can be improved by encapsulation because seperate encapsulated components can be run on seperate machines and communicate via RPC etc. It is also possible for encapsulation to have a negetive effect on runtime performance as third party code may not be efficiently written and you have no way of modifying it or changing its implmentation by overriding functions (if a sealed class) without the source code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						By encapsulating the object instances required by a task in a class dedicated to that task, when the task object is disposed, all resources required by the task are also disposed of. This is good for unmanaged environments where there is no garbage collector. All that need be implemented is the correct delete() or .dispose() calls in the task objects&apos; destructor, ~finalise, or dispose() method.
						
						The objects using the hypothetical GenericTask class need not know about the allocations, file handles or whatever which are being aquired by the GenericTask class as these will all be managed by the GenericTask class and its lifecycle as long as it is implemented correctly the once in the GenericTask class as described above.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by contract requires a provider and a client of a service. The client need not know the implementation of a particular method on the provider, but requires (due to the contractual agreement of DbC) a particular return value from the provider, given specific parameters. The encapsulation of a method in the provider allows an implementation of code for exception handling and assertions to ensure that the formal agreement between the client and the provider is satisfied. This code can be hidden from the client so that the provider object itself does not appear &apos;messy&apos; and the client can not interfere with the operation of the provider object so as to allow operations to execute which would invalidate the class invariant or the methods&apos; DbC agreement.
						
						The DbC enforcement code should not be exposed. Encapsulation then allows the exposure of select methods to clients which are DbC checked and adhere to the formal agreements of the design specification.
						
						Without encapsulation, DbC could not be enforced as developers have access to all members of a class and will not use it as contractually agreed!
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a reusable solution to a problem for particular contexts which appear in routine software development. They detail rules of thumb, strategies or guidelines for tackling problems encountered in programming.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						As the software involves the use of structured questions, there will be different types of questions in the system with certain common implementation between them. The composite design pattern is suited because the exams will contain composite questions which have more than one question within them. There will be an array of type Question within each CompositeQuestion instance (see below)
						
						It also allows the is-a test to succeed with the classes of question we will be using, and use parts of a shared implementaion for each type of question.
						
						Probably most import is the use of dynamic binding for returning properties and aggregated values from the question instances.
						
						public abstract class Question
						{
						protected string _QuestionText;
						protected Answer _Answer;
						
						public Answer getAnswer() {
						return _Answer;
						}
						}
						
						public class CompositeQuestion extends Question
						{
						private Question[] _Questions;
						
						public Answer getAnswerForQuestion(int q) {
						return _Questions[q].getAnswer();
						}
						
						public ArrayList getAnswers() {
						ArrayList answers = new ArrayList();
						
						foreach(Question q in _Questions)
						answers.add(q.getAnswer());
						
						return answers;
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Proxy: A remote proxy could be used for communication between the exam client and the secure server. The server remoting technology model/framework would return a proxy object to the client which the client can call methods on. These methods will then execute on the server. This can be used for the exchange of XML structed data via parameters etc.
						
						Observer could be used to &quot;enable&quot; the client applets when the exam starts. The exam clients will want to know when the exam has started so that the GUI can be enabled. This can be accomplished by hooking up or subscribing to the event exposed by the server (perhaps via the previously mentioned proxy) by all of the clients. The change in state of the exam (started, cancelled, etc) is then propagated to all of the clients.
						
						Strategy can be employed for the displaying or marking of exams as the system is developed further in the future. The base ExamMarking class can expose abstract methods for &quot;getAnswerSummary(Exam exam)&quot; etc and the custom (maybe complex) algorithm for the actual displaying or marking of the answers can be placed in the subclasses specific for marking a particular type of exam and executed by dynamic binding.
						
						Null object pattern can be used for the storage of answers for a particular question, or for an exam as these would form a tree like structure in memory. To stop the need for brittle tests for null, the null object pattern combined with a static instance for leaf nodes (representing what would be null) can be implemented.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="25" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="47" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is an example of the use of inheritance to represent roles and is not a sensible use of inheritance. Having a Footballer class and then different classes for the different positions is possibly valid depending on the situation, but the relationship between the roles and Footballer should be a form of delagation. Each role should have a private field to indicate the footballer who currently plays that role, e.g.
						
						public class Defender {
						private Footballer footballer;
						}
						
						This will allow one Footballer object to represent a footballer who may be needed to play several roles throughout a match, for example during a corner, which would be impossible if the relationship was fixed by inheritance.
						
						It is also not good style to have a seperate class for WayneRooney. Despite some impressive performances and a few missing chromosones there is nothing that seperates his behaviour from any other Striker and the differences in name, appearence and inteligence should therefore be represented by parameterisation of the Footballer class.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is not a sensible use of inheritance because it breaks the encapsulation of TrafficQueue. It is an example of Implementation Inheritance where a class has been subclassed for the convienience of some of its implementation but not for the interface which is unsuitable for the situation. For example in this version of TrafficQueue all of ArrayList&apos;s methods, including probably unsuitable ones such as remove(int pos) and insert(int pos) are publicly available to clients of TrafficQueue. It would be better to encapsulate the ArrayList within TrafficQueue as a private field and then implement methods to provide access to the ArrayList methods we do want to make public e.g.
						
						public class TrafficQueue {
						private ArrayList trafficList;
						public void add(Traffic newTraffic) {.....};
						......
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In this example the class PersonalElectronicEquipment exists only to serve as a means for classifying the other three classes. It is unlikely that the PersonalElectronicEquipment class will contain much in the way of common functionality which has been abstracted into it or common interface which can then be used for polymorhpism, but it may have some. The suitablity of this approach would depend entirely on the use, it may be suitable for example in a Electronics Shop situation when it would be usefull to have a superclass of all Personal Electronics products to allow polymorphism.
						
						However in a general situation there is very little similarity between a camera and a phone and the properties which they do share would be better represented by interfaces, e.g.
						
						public interface batteryPowered() {
						public int getBatteryLifePercentage();
						.....
						}
						
						public class MobilePhone implements BatteryPowered {....}
						
						The case for defining a camera phone as being both a Camera and a Phone is stronger, but since there is a lot of difference between the camera in a phone and the camera in a normal digital camera the class might be implemented as an extension of MobilePhone which also implements the Camera interface, i.e.
						
						public interface Camera {.....}
						public class CameraPhone extends MobilePhone implements Camera { ..... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Copyable is here an alternative to the usual Cloneable interface. This provides the advantage of being able to provide a default implementation of copy() in the definition of Copyable, rather than in the definition of any acutal class. This may be advantageous if very few implementing classes are likely to overide the copy() method. The alternative is to provide an interface similar to the existing Cloneable inteface in Java:
						
						public interface Copyable {
						public Object copy();
						}
						
						Since this doesn&apos;t allow a default implementation of the method one will have to be defined either in the classes that implement the interface themselves or higher up the Inheritance tree, in Object for example.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Implementing the Answers in this way has some advantages. For example it would allow marking of the answers using a consistent method by making use of polymorphism. This would require the method to be defined similar to:
						public int markAnswer(Answer ans) { .... }
						and could be declared in the Question objects for example.
						
						However this application of inheritance probably creates too many classes which would be better off represented by a parameterised class which would allow increase code reuse. For example NoAnswerProvided and NoAnswerRequired could be grouped into a single class using a boolean flag to indicate if an answer to that question was required. This could be done whilst still preserving the ability to treat all the Answers the same through polymorphism.
						
						public class EmptyAnswer {
						private Question question;
						public boolean answerRequired() {
						return question.requiresAnswer();
						}
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a reusable general design which can be used as a solution to many specific problems. They are approaches to problems which have been reliably proven to be &quot;best practice&quot; in many situations and are defined in terms of the context in which they apply, the way in which they can be applied and the consequences of doing so.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						This software will need to store the exam question heirachy in some form of tree. The Composite design pattern is a common design pattern for producing reliable trees in which operations can be uniformly performed on every node. In this design pattern we would define three abstract classes, one overall superclass of all objects in the tree, one for all complex non-leaf objects and one for simple leaf objects. In this example we will assume that we will want to add up the marks at the end of the exam.
						
						e.g.
						
						public abstract class ExamQuestion {
						public int getMarks();
						......
						}
						
						public abstract class ComplexQuestion {
						private ArrayList subquestions;
						public int getMarks() {
						int total = 0;
						for (int i = 0; i &lt; subquestions.getSize(); i++) {
						total =+ subquestions.get(i).getMarks();
						}
						return total;
						}
						}
						
						public abstract class SimpleQuestion {
						private int mark;
						public int getMarks() {
						return mark;
						}
						}
						
						This will form a tree of Complex Questions and their Sub Questions which can be traversed to calculate all the marks using polymorphism thanks to the getMarks() method declared in the abstract superclass. Specific types of question will then be declared as concrete implementations of the abstract classes: e.g.
						
						public class MultiChoiceQuestion extends ComplexQuestion {....}
						public class TextQuestion extends SimpleQuestion { ..... }
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Other design patterns are also suitable for this software.
						
						Since the software needs to communicate over a network to provide the exams to students throughout the world the Remote Proxy design pattern would be very useful. The Remote Proxy design pattern invloves creating a local or near object which has most of the same or all of the same interface as the remote object, and then encapsulating the code for performing Remote Method Invocation on the remote object within the local proxy. This allows the local code to treat the local proxy object as it was the remote object and allows the local code to interact with the remote code almost as if it were running on the same machine.
						
						e.g. On remote machine:
						public class QuestionServerImplementation implements QuestionServer{
						public Question getQuestion(int id) {....}
						}
						
						On local machine
						public class QuestionServerStub implements QuestionServer {
						public Question getQuestion(int id) {
						&lt;RMI Magic&gt;
						return remote.getQuestion(id);
						&lt;/RMI Magic&gt;
						}
						}
						
						This could then be used by any local class in place of a real QuestionServerImplementation by polymorphism.
						QuestionServer qs = new QuestionServerStub(Locator location);
						myQuestion = qs.getQuestion(27);
						
						
						
						Since the software will need to interface with users (students and markers) through a GUI the Observer pattern would be usefull. In the observer patten Observable and Observer objects are clearly decoupled, with Observable classes representing objects which may at any time change state in response to an outside influence and Observer classes representing objects which may be interested in this change of state. This is often used in GUI situtations, for example the &quot;Start Exam&quot; button. In the Observer pattern this button would be an Observable object and there would be another object within the system which would register itself with the Start Button to allow it to be notified if the state of the button changes.
						
						e.g.
						public class Button {
						public boolean clicked = false;
						public void registerButtonListener(ButtonListener listener) { .... }
						
						public void click() {
						clicked = true;
						(Notify all registered listeners that a state change has occoured by calling notifyOfClick on them)
						}
						}
						
						public interface ButtonListener {
						public void notifyOfClick();
						}
						
						
						In the tree representing the exam question hierarchies once the answered exams have been collected by the central server for marking many of the objects may be the same. In this situation the Flyweight pattern would be useful. For example if the tree for the answered exam is actually considered as a hierachical tree of answers with attached questions then we could use a tree of Answer, ComplexAnswer and BasicAnswer objects according to the Composite patern discussed earlier. Each Answer object would then have a private field with a reference to its question. The questions would be imuteable objects so could be generated by a factory method, for example
						public getQuestion(int questionID) {
						return questions[questionID];
						}
						in the Question class where questions[] is an array of questions initialised with all the questions in advance using a protected constructor. This would save repetition of large numbers of identical Question objects. This would also mean that for each question there would only be one instance representing that question.
						
						If the exams contain optional questions then it is also likely that many of the objects in the tree will be empty Answers. These could be modeled as null values, but this breaks the ability provided by the Composite pattern to treat all nodes the same by polymorphism and greatly reduces software reliability by making it prone to NullPointerExceptions. A better solution would be to use the Null Object pattern, where an EmptyAnswer class is created to represent these uncompleted questions. The EmptyAnswer class would inherit from the same hierarchy as any Answer object but would contain empty (or null) implementations of most of the methods. For example the getMarks() method would probably simply be implemented as:
						
						public int getMarks() {
						return 0;
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Introducing the concept of contracts attempts to improve realiabilty (the ability of a program to react to situations not in the specififcation) and correctness (the ability of a program to perform according to the specification under the situations described in it). It achieves this by specifying a set of obligations and rights for every interaction with a method. These take the form of pre and post conditions to methods. A pre-condition is an obligation on the client which describes the acceptable states in which the method can be called, it provides a benifit to the supplier class by allowing certain assumptions to be made. A post-condition is a gaurantee by the supplier class that if the pre-conditions are fullfilled then the method will always result in a state which satisfies the post-conditions. This provides the benifit to the client of reliable results.
							
							Contracts are defined through the use of interfaces. This does not necessarily require the use of seperate Interface constructs (as in Java) or seperate files (.h files in C/C++), in fact it is better done through the use of a tool such as JavaDoc which generates a constantly updated description of the class&apos; contract.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							If I was to implement these classes in Java I would define the interfaces using the JavaDoc tool and would enforce the pre and post conditions through a mixture of manual checking (for public method pre-conditions) and the assert statement for other situations. The Javadoc comments will specify the pre and post conditions for the public methods from general comments, @param entries and @return entries. For example the SqRoot class could be defined as:
							
							/**
							* Class for storing the SqRoot of a simple number. Will not deal with complex numbers so can only
							* represent the SqRoot of positive numbers.
							*/
							public class SqRoot {
							private double number = -1;
							
							/**
							* &lt;p&gt;
							*     Constructor to create a SqRoot object from a given double.
							* &lt;/p&gt;
							* @param number: double defining the number to be square-rooted. Must be positive
							public SqRoot(double number) throws InvalidArgumentExecption {
							if (number &lt; 0) {
							throw new InvalidArgumentException(&quot;SqRoot must be created using a positive source&quot;);
							}
							
							this.number = number;
							
							/* No non-trivial post condition, except for &quot;this.number == number&quot; and that is trivially true provided
							the preconditions are held */
							}
							
							/**
							* Method to get the square root of the number used to create the SqRoot instance.
							* Pre-conditions: SqRoot was constructed using a positive number
							* @return     double    -    The value of the square root of the number.
							public double getSqRoot() {
							/* Pre-condition: number &gt;= 0 implemented as an assert since there should be no way to
							have an instantiated class with a negative number */
							assert (number &gt;= 0), &quot;Attempted to square root negative number.&quot;;
							
							return Math.sqRoot(number);
							
							
							/* Post-condition that the return value is equal to the square root of the number is provided by the
							* post-conditions of Math.sqRoot, but if there was any doubt about the reliability of the Math class
							* it could be checked using: assert (result * result == number), although this makes assumptions about
							* rounding accuracies. */
							}
							}
							
							The stack method could be implemented in a similar way, using Javadoc comments such as:
							
							/**
							* Push method. Adds a new object onto the top of the stack provided that the stack is not full.
							* @param - Object to be added.
							*/
							public void push(Object newObj)  throws StackFullException {
							if (isFull()) {
							throw new StackFullException(&quot;Adding object: &quot; + newObj.toString() + &quot;failed, stack was full&quot;);
							}
							
							underlyingStack.push(newObj);
							
							// Check post condition
							assert underlyingStack.contains(newObj), &quot;Stack does not contain new object after push operation&quot;;
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In this situation we could add a new class SqRootStack which has a pre-condition requireing all objects on the stack to be SqRoot objects by typing the push methods more strictly. This would break the pre-conditions of the normal Stack and so can&apos;t be a subclass of stack since all subclasses must accept at least the states their superclasses did.
						
						e.g.
						
						public class SqRootStack {
						Stack stack;
						
						public void push(SqRoot newSqRoot) throws StackFullException ( .....}
						}
						
						This allows us to assume that all objects on the stack are SqRoot objects so we can use Polymorphism to recursivly call getSqRoot on all the objects:
						
						public double[] getAllSqRoots() {
						//Pre-condition that all objects on stack are SqRoot objects is satisfied by typing of push() arguments
						.......
						}
						
						The advantages of using Stack and SqRoot here are that their contracts can be used to satisfy the pre and post conditions in the new class. For example there is no need to re-check the pre condition that the stack is not full in the new implementation of push since that is checked on the call to Stack.push(). It is enough to simply declare that the new SqRootStack.push() throws a StackFullException and then propogate the exception up from the Stack class if it occours.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="26" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="36" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Here it would be more sensible to use parameterisation.
						
						public class Footballer {
						
						String position;
						String name;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is an example of implementation inheritance. This is bad because all the arrayList methods are available in the TrafficQueue. Would be better to encapsulate the arrayList in the TrafficQueue class. This would also allow the easy changing of the data structure at a later date.
						
						public class TrafficQueue{
						
						ArrayList queue;
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I think the top classes inheritance is ok, it passes the Is-a test. the bottom isn&apos;t so clear. I would use delagation instead here. A camera phone has a phone and has a camera.
						
						public abstract class PersonalElectronicEquipment{...}
						
						public class MobliePhone extends PersonalElectronicEquipment{...}
						
						public class DigitalCamera extends PersonalElectronicEquipment{...}
						
						public class CameraPhone{
						
						MobilePhone phone;
						DigitalCamera camera;
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I tihnk the copyable inheritance is ok, but the information source is suspect. There is usually a better way of implementation than multiple inheritance. Here I would say the book has an informationSource and is copyable. A better implementation would be like this:
						
						public class Book extends Copyable {
						
						InformationSource bookSource;
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The Answer, MCQAnswer and TextAnswer are ok. The other two sub-classes should be implemented using parameterisation. Use booleans to control the parameters
						
						Public class Answer{
						
						Boolean noAnswerProvided;
						Boolean noAnswerRequired;
						//...........
						}
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A general outline solution to a reoccuring problem. It is written in a way that defines the general apporach, not specifically bound to one language implementation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The composite structure could be used to implement the actual structure of the exam. The exam would be structured as a tree, we would want to calculate the total marks by navigating the tree and calcuating the marks at each individual question.
						
						// top class for all questions
						public abstract class Question {
						
						// the method we want to apply to all nodes in the tree
						public abstract int calculateMarks( ){}
						
						}
						
						
						public abstract class basicQuestion extends Question{
						
						Int marks;
						
						public abstract int calculateMarks() {return marks}
						
						}
						
						// implements a combination of questions, eg true or false and a text answer
						public abstract class compositeQuestion extends Question{
						
						ArrayList questions;
						int marks;
						
						public abstract int calculateMarks(){
						
						for (i = o; i&lt;questions.size;i++){
						
						marks += ((Question) questions.get(i)).calculateMarks;
						
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						I would use a remote proxy to manage the connections over the internet. The exam client would see the proxy as the server, not needing to know the details of the connection.
						
						I would use singleton to only allow the students to open 1 instance of their exam. Then even if the client sends multiple requests ( due to the unpredictablilty of the net connection) only 1 instance of the exam oblject would be open per student per exam.
						
						I would use the observer pattern to watch the net for incoming exams. The exam client would be observables, the server would be the observer. The exams could be taken without the need to be set up and monitored by the central server. The students could take the exams whenever, the exam client alerting the server when an exam is about to be started.
						
						During the actual marking process the marking system could use an implementation of the factory method pattern. The program could use dynamic binding at runtime to generate the right marking scheme for each exam type, rather than having to use loads of conditional statements.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to allow us to increase the amount of correctness in our library&apos;s classes and their functions. By inserting mechanisms for defining pre and post conditions, and also class invariants, we can check our methods for correctness.
							
							Pre and post conditions would be implemented by requring methods to use extra keywords. requires for pre-conditions, satisfies for post-conditions. eg:
							
							public void testMethod requires(x != 0) satisfies(x&lt;0) (String input){....}
							
							Class invariants would be delared at the start of a class and use the keyword invariant. eg
							
							public class test{
							
							invariant number&lt;x;
							//....
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							public class SqRoot{
							
							public static int findRoot(int x){
							
							try{
							if ( x&lt;=0){ throw arithmetricException() e }
							.....
							}
							
							}
							
							As the method is public, better to use an explicit check rather than using assert. This is because the assert exception will be the same no matter what the exception actually is, making it harder to track to the root of a bug.
							
							public class Stack{
							
							List stack = new List();
							int stackPointer = 0;
							assert stackPointer &gt;= 0;
							
							public void push( int i){....}
							
							public int pop(){....}
							try {
							
							if (stackPointer &lt;= 0) {......}
							else { throw (execption e) }
							}
							catch (e) { System.print(&quot;there is nothing on the stack&quot;)}
							
							}
							
							The class invariant for the stack class ( stackPointer &gt;= 0) is asserted using the assert keyword. The pre condition for pop ( there must be something on the stack to pop off) is expressed using an explicit check.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						public class calculate stackRoots {
						
						Stack stack = new Stack():
						
						public array  checkRoots(Stack checkStack){
						int i;
						for (i = 0;i &lt;checkStack.size;i++) {
						try{
						
						i = SqRoot.findRoot(checkStack.pop());
						//....
						} catch (arithmetricException e){ System.Out.println(&quot;cannot calculate root of zero or negative number&quot;)}
						
						}
						}
						
						The benefits come from the contracts in Sqroot and Stack. They allow us to guarrantee the correctness of our program. By using conditions and invariants, along with the exceptions they generate, we reduce the amount of unexpected errors in our system. By catching exceptions thrown when contracts are broken, the system will be able to deal with states unknown to us at the time of programming without crashing.
						.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="27" examId="CS310105" timeTaken="7097" isSubmission="true" allImages="true">
		<compositea marksAwarded="32" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The use of inheritence in this particular instance is mostly sensible. When first doing the &apos;is-a&apos; test, we can determine that both Striker and Defender are good uses of inheritence from the class of Footballer. Anything that a footballer can do, any of the specific types of footballer should be able to do (from the method inheritence).
						
						The number of subclasses from the abstract Footballer is limited (in real-world classification) by the number of positions on a football pitch, and thus the conversion from real-world classification to software classification works well, with it&apos;s enforced limits.
						
						Defenders and Strikers have quite different jobs, though are clearly related in &apos;real-world&apos; terms. Thus this distinction is quite sensible.
						
						WayneRooney however is a bad example of inheritence. Rather than extending Striker, it would make more sense to have WayneRooney as an instance of the class Striker;
						
						Striker wayneRooney = new Striker();
						
						due to the fact that providing a subclass for each individual Striker in football would lead to an explosion of subclasses. A WayneRooney can not (sensibly) do more than a Striker can do, due to the stringent rules already provided in football limiting the various actions/methods.
						
						A WayneRooney would have attributes akin to any other Striker, and so these attributes can be included as variables within an instance of said class.
						
						This class specialisation is unrequired, and quite clearly overkill.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						ArrayList is one of the Java library classes of Collections, implementing the List interface. Due to the fact that a list is an ordered set of Objects, it would make sense that in a traffic simulation the order in which the cars are in the queue are quite important.
						
						Thus, using one of the base classes and specialising for this particular need is quite sensible.
						
						Alternately to this particlar implementation, the class TrafficQueue could instead itself implement the interface List, with it&apos;s required iterators and accessor methods.
						
						public class TrafficQueue implements List { ... }
						
						This would allow for better abstraction should the simulation creators decide that another type of collection would be more suitable for this particular purpose.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In Java, multiple inheritence is not allowable, as it is in other Object Oriented languages such as C++. Thus the statement;
						
						public class CameraPhone extends MobilePhone, DigitalCamera { ... }
						
						is not actually valid.
						
						Whilst a Java class can implement multiple interfaces, it can not be a direct subclass of more than one class.
						
						This is, unfortunately, one of the few cases in which multiple inheritence in Java could feasibly be justified, due to the fact that technologies such as camera technology and mobile phone technology are becoming increasingly alike, and components from each are being inter-mixed with each other.
						
						This is due to the problems of classification when it comes to deciding on types of Java classes based on real-world objects. Whilst this classification (and inheritence) works in real-world terms, in software terms, and Java terms in thie particular instance, a different abstraction and clafficiation is required.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						As with the previous question, multiple inheritence is not allowed in Java. As such, the statement;
						
						public class Book extends InformationSource, Copyable { ... }
						
						is not valid.
						
						Rather than Copyable being a class, it should sensibly be an interface, much in the way that Serializable is an interface.
						
						public interface Copyable
						{
						public Object copy() { ... }
						}
						
						Due to the fact that Copyable would be defined as an interface, Book could be redifined as;
						
						public class Book extends InformationSource implements Copyable { ... }
						
						with Copyable now being the interface rather than the supertype that is used for this class. a Book is-a-type-of InformationSource, but it certainly is NOT a type of Copyable.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is an example of over-using inheritence with the large number of subclasses extended from the superclass Answer.
						
						Due to the fact that marks will be tallied based on the correctness of an answer, the class NoAnswerProvided seems unnecessary. If we limit the types of answers in an exam down to both TextAnswer&apos;s and MCQAnswer&apos;s, then we have, by the definition of those types of question, an instant test as to whether or not an answer was provided (by the Object having either empty variables for it&apos;s &apos;text&apos;, or being a null value). NoAnswerProvided is overspecialisation, and would be better served by a variable within Answer which can be called by an accessor along the lines of;
						
						public boolean isEmpty() { ... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A &quot;Design Pattern&quot; is a generalised way in which a particular problem can be addressed, using the knowledge of people experienced in the particular problem area. Due to the fact that certain computing and algorithmical problems occur again and again, often due to inexperience, Design Patterns provide a way for the inexperienced designer to look at patterns which may &apos;generally&apos; solve their problems, that have been developed and/or researched by experienced individuals in the field. Design Patterns generally have to contain information such as;
						
						- what problem this could help address
						- how to implement it
						- examples of implementing this pattern
						- alternatives, or related patterns
						- considerations to have when deciding to use this pattern
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The Composite design pattern is a very common pattern used in Object Oriented programming.
						
						Whereas we will oft have the need to implement an &apos;is-a&apos; relationship through way of inheritence, we will also oft wish to implement of way of showing the &apos;has-a&apos; relationship. This helps to display the relationship whereby a class is essentially made up of other classes.
						
						An Object which is made up of other Objects, such as a building, which is in turn made up by a door object, wall objects, etc...
						
						I, unfortunately, can&apos;t remember the details of this design pattern, save for the parts in the notes about how a Tree can be broken down into Branches, Leaves, and so forth. *curses*
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="7" isMarked="true">
					<answerString>
						Factory Design Pattern
						=============
						
						
						
						Observer Design Pattern
						==============
						
						The observer design pattern is essentially made up of two distinct parts; the observer and the observed. The observer must register interest to the observed that it wishes to be informed should something &apos;change&apos; with what is being observed. The observed will then, when changed, update the observer with the new information. This could be particularly useful in this particular program in order to display generalised results over a set of students/examinees, for example, in updating graph statistics (on average marks, etc... for use in weighting) when a new exam has completed being marked.
						
						FlyWeight Design Pattern
						==============
						
						The flyweight design pattern allows us to make optimisations in the space consumption used by multiple Objects which have the same value. This is done by, instead of having multiple Objects, we have one instance of an Object which has a certain value (which is, required many times), and multiple references to that Object, instead of multiple Objects themselves. This could be useful in this particular program in instances such as multiple choice answers, where in reality, we may only need 5 Objects (eg. 1-5) which may in turn be required many times over in the software.
						
						Strategy Design Pattern
						==============
						
						A strategy design pattern uses some sort of evaluation function in order to determine the value which should be given to a particular answer. This particular design pattern is useful when algorithms which are used to evaluate a certain set of data changes more often than the data itself, and so allows for substitution of algorithms which are instead treated as Objects. This would be a useful design pattern for possibly non-scientific examination marking, where there is no &apos;one correct answer&apos;.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="11" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design-by-contract is a methodology whereby classes and methods have a form of &apos;contract&apos; written between them.
							
							Considering the following;
							
							public abstract class Classy { ... }
							
							public class ClassA extends Classy
							{
							public Class getB(int a) { ... }
							...
							}
							
							public class ClassB extends Classy
							{
							public Class getA(int b) { ... }
							...
							}
							
							we have two seperate classes, each of which wishes to access methods in the other class. Design by contract takes into consideration both pre and post conditions in state during the communication between them.
							
							For example, there could be a contract between ClassA and ClassB which essentially states;
							
							&quot;As ClassA, if you (ClassB) guarantee to make sure that you satisfy the preconditions which are required to call my method (getB(int a)), then i shall guarantee to provide you with a Class, as specified by my method.&quot;
							
							This contractual agreement allows a programmer to check the &apos;correctness&apos; of their program, in order that it meets the specification as provided by the initial remit.
							
							Also, class invariants are important in allowing certain intrinsic &apos;states&apos; to be true in instances of the class, and any subclasses thereof.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							Java only currently has one basic way in which to enforce design by contract, and that is through the keyword &apos;assert&apos;. This can be seen as a way of saying &apos;make sure that x is the case&apos;.
							
							public abstract final class SqRoot
							{
							// method for computing the square root of an int
							public long root(int x)
							{
							// the required pre-condition is that the int is &gt; 0
							// ================
							// the post-condition is a long which is the square root of x is returned
							}
							}
							
							
							In order for a class Stack to work as required, there are specific pre and post conditions which must be met when calling the required methods.
							
							public class Stack
							{
							// method for determining Stack fullness
							public boolean isFull() { ... }
							
							// method for determining Stack emptiness
							public boolean isEmpty() { ... }
							
							// method for adding a number to the stack
							public void push(int newNumber)
							{
							// the required pre-condition is that the stack is not full
							// also that the parameter is an int (checked)
							// ===============
							// the post-condition is that the int shall be pushed onto the stack
							}
							
							// method for removing a number from the stack
							public int pop()
							{
							// the required pre-condition is that the stack is not empty
							// ================
							// the post-condition is the int on top of the stack shall be returned
							}
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Due to the fact that we are using design by contract, we have already initially stated within the classes that certain pre and post conditions must be met, and as such, the correctness of the class methods can be checked.
						
						This allows us to build a more robust system using these components, with the main functionality taking place as defined by the following main method;
						
						while (!stackInstance.isEmpty())
						{
						System.out.println(SqRoot.root(stackInstance.pop()));
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="28" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="18" isMarked="true">
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						It is good. A striker is a footballer, a defender is a footballer and WayneRooney is a striker. So if we want to change WayneRonney to be other striker, we just need to change the class of the WayneRooney and it will not affect other classes.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Use the is-a checking, the traffic queue cannot only be a arrayList and it has many other things to include. Try the has-a checking, it can past the checking. So we use delegation, like:
						public class TrafficQueue
						{
						ArrayList arrayList = new ArrayList;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It has the mulitiple inheritance problems, the CameraPhone is a MobilePhone and also a DigitalCamera. We use the CameraPhone to get two parmeters.
						public class CameraPhone
						{
						MobliePhone m;
						DigitalCarmera d;
						CameraPhone cameraPhone(m,d);
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is the problem of the implementation inheritance. It is not very good, to use this we can inheris some implementation in the super class. But if we want to do the change in the running time, it will be very difficult. So we can create the implementation in the class Book itself, and when we change the Book, it will not affect other classes.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						To check the class, the MCQAnswer can have the TextAnswer as well. Use delegation.
						NoAnswerProvided and NoAnswerRequired hace some commer code. We can create another class to have the common part between them and use paremation to create the instance in the class.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						A complex system can be decomponsed into highly cohesive modules and loosly coupling modules. Encapsulation is used to get lossly coupling modules. It use the information hide to hide the implementations of the client. Because the smaller the client knows the implementations the looser the coupling modules can be. For the abstraction, the constractal interface is essense of the behaviours of the module. It is better if the caonstractal interface contain no implemerntations. We use encapsulation to seperate the implemernataions from the constractal interface.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						public: can access by all outside classes in the module.
						protected: can access super or sub classes.
						private: can only access in the class.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Because the encapsulation is using the information hide, to use the inheritance we can only store some codes one time. The common code will waste the storage, so to use the encapsulation can reduce the reuse code space to same the storage.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Design by Contract is to use the contract as the relationship between the client and the supplier.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of the introducing contracts is to ensure the correctness of the programe. So we should get a precondition, a postcondition and also a invarient.
							precondition: bindling with the client - person, and check the correctness when the method of the classes is be called. It is the contract of the client and the benefit of the supplier - library.
							postcondition: bindling with the supplier - library, and check the correctness when the method of the classes is on return. It is the contract of the supplier and the benefit of the client - person.
							precondition and postcondition have the properties of indivital instance, and invariant has the goble properties of the instance of the class.
							So we can define the precondition like: pre book has N copies. postconditions: post book copies update. invarient: copiesOfBook &gt;= 0 and copiesOfBook &lt;= storeSpace(Max numbers of the books can store in the library)
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							specification of the method: finding the square root of a number.
							precondition: the stack is not full.
							postcondition:update the stack.
							invarient: theNumberInStack &gt;= 0 and theNumberInStack &lt;= theStackSapce(the max numbers can put into the stack)
							
							Firstly, check the invarient theNumberInStack &gt;= 0 and theNumberInStack &lt;= theStackSapcethe, to make sure the stack is OK. Secondly, client check the preconfition to ensure that the stack has the space to store the new number. So the X= square of X can be store on the top of the stack. Then we store the value of X into the stack and to use postcondition to updata the stack.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public class SqRoot extends Stack
						{
						private int x;
						x= math.square(x);
						stack.push(x);
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="29" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="33" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I feel this is not appropriate as Striker and Defender are roles which a footballer plays, which can change many times throughout the course of a game.  For example a midfielder may become a striker for the last 10 minutes of a game if they are 1-0 down.  Inheritence doesn&apos;t allow this flexiblility to change as a player cannot be a Striker and Midfielder object at the same time.  I would therefore use delegation for Footballer.  Striker etc would have instances of footballer within them.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of implementation inheritence - the TrafficQueue is-not-a ArrayList but is a subclass just so it can use its methods.  Firstly I think inheritence used here is inappropriate as it is unlikely TrafficQueue will want to use all the methods of ArrayList - should be delegated to ArrayList.  And secondly specifically using an ArrayList makes the code inflexible to change e.g. may want to use another type of datastructure at some point - it should be &apos;dynamically asigned&apos; as ArrayList.
						
						class Vehicle {
						}
						
						class TrafficQueue {
						private List queue; // Abstract class list used for flexibility.
						
						TrafficQueue() {
						queue = new ArrayList(); // Dynamically assigned as a ArrayList.
						}
						
						addVehicle(Vehicle vechicle) {
						queue.add(vehicle);  //Delegating add to ArrayList istead of inheriting it.
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						I think Mobile and DigitalCamera inheriting from the abstract class is good deisgn.  But there are some problems with the multiple inhertence for CameraPhone.  As it inherits two objects which inherit the same thing themselves there may be some clashes.  For example, if the abstract class defined an abstract method that must be implemented by its subclasses, then CameraPhone will inhetrit both these identically named methods with different implementations. How does it know which one to use!  I think a CameraPhone has-a MobilePhone and has-a DigitalCamera, and would therefore be better implemented by delegation.  Now the programmer can say which methods to use.
						
						public class CameraPhone {
						MobilePhone m;
						DigitalCamera dc;
						}
						
						But a CameraPhone is-a PersonalElectronicEquipment  I would therefore &apos;extend it&apos; from the abstract class, and then for the abstract methods it inherits I would call the appropriate method in the other two classes.
						
						public class CameraPhone extends PersonalElectronicEquipment {
						MobilePhone m = new MobilePhone();
						DigitalCamera dc = new DigitalCamera();
						
						public viod turnOn() {
						m.turnOn();
						dc.turnOn();
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I think the java way of implementing this is a lot better.  Java achieves this by having all objects as a subclass of a type called Object - this is the root class.  Within this class the clone() method is implemented.  All objects now inherit this method automatically - no extends is needed as it is bult into the language.  So book would automatically inherit clone() from object. To avoid the nasty clashes of multiple inheritence clone() I expect is a keyword i.e. you cant have methods called this.  Also, clone() in Book would be exactly the same as clone() in InfoSource so there wouldnt be a clash.Clone() is perhaps more suitable than copy() as copy is a fairly common method name e.g. Book maybe have a method called copy that photcopies the book or something, not copy the object.  If this wasnt allowed in Java and multiple implmentation inheritence was allowed I would implement it just as above.  Being careful for name clashes etc.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						MCQAnswer and TextAnser I think are good uses of inheritence.  But I think that a new subtype is not needed for NoAnswerProvided.  This would be implemented better by parameterasation - by having a boolean variable within Answer which states whether the question has been answered.  This would also give the MCQ and Text the option of having no answer.  I would use a simular approach for NoAnswer required - getting rid of the class and using a boolean variable in Answer again.
						
						public abstract class Answer {
						private boolean answerProvided; // And appropriate get, set, and is methods.
						private boolean answerRequired; // And appropriate get, set, and is methods.
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A general solution (i.e. structure of objects etc) to a common problem but can be taliored to the specific problem you need to solve.  The pattern has usually been designed by an expert who knows that this is the best way to solve this type of problem e.g. whats the best way to make an object that can only be created once (singleton).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The exam is made up of questions; the questions are made up of subquestions. The composite design pattern is used when &apos;big parts&apos; are composed of &apos;smaller parts&apos;.  It would have a class representing an ExamElement and then a subtype of this for question.  ExamElement would also have a subclass class Exam, which would also link back to ExamElement in a 1 to Many relationship i.e. an Exam is made up of many ExamElements.  This relationship would just be a list of ExamElements.  a List is used for flexibility, the particular implementation of list can be decided dynamically at runtime e.g. ArrayLst.  Exam could then have more subtypes for particular exams with the List Filled in the with appropriate Questions.  Question would have subtypes for the different types of question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						Proxy - As communication is across a network and needs to be secure the Proxy pattern should be used.  This pattern works by having a Proxy object to handle communication between two other objects - as communication is over a network and not just simple message sending.  Two specific types of Proxy objects would be suitable here - a Remote Proxy (for message sending between Applet objects and Server objects over the internet) and a Access Proxy (for secure logging in with ID and password).
						
						Factory - As the software needs to deal with different question types.  This pattern would work by having a structure to represent the different question types, and then a structure for how to create these types.
						
						Strategy - As different algorithms will be used to present the information.  This works by allowing algorithms to be represented as objects and then with the use of inheritence the programmer can easily switch between this &apos;strategies&apos; without having to change his code much.  An abstract class is used to define the interface (i.e. the methods other objects will use e.g. display(Answer answer)) that all the presentation algorithms must have.  Then subtypes are made of this which specify exactly how the answer will be be displayed - implementing the inheriteted abstract methods (e.g. display(answer))
						
						Observer - As the Applet is likely going to use a Graphical User Interface (GUI).  This pattern has to types of object - an observer and an observable.  The observable object has a state which can change at anytime.  The observer object registers that it is interested in being informed when the obseravble object changes state.  When informed it can do whatever it needs to do.  In this context the observable object, for example, would be a button to start the exam and the observer would be a listener which &apos;Starts the exam&apos; when the button is clicked.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<compositea marksAwarded="5" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							A contract needs to be defined to say exactly what the software will do.  This is important in this context as other programmers will want to know exactly how the library behaves.  Particularly if they are implementing some software which must fulfill a contract they have with a business - they will want ot know exactly what your library does so they know exactly what their code will do.  To define the contract pre-condition and post-conditions must be specified for every method, and then class invarients must be specified.  Pre-conditions are effectively what inputs this methods will work correctly on e.g. 10 &lt; x &lt; 20 for input x.  The post-conditions are what output will be given from the correct input/preconditions e.g 100 &lt; x &lt; 200 for a method that multiplies x by 10.  The class invarients are conditions that must hold at all times (only when the state can be observed i.e. between methods) in a class.  For example, in a class representing a range of real numbers, the class invarient min &lt; max must always be true.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="30" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="33" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						All the above three examples pass the &quot; IS-A &quot; test and so it would normal to assume that it is a valid use of inheritance. However all three examples are also examples of roles being played. A striker is and a defender is a specific role within a football team. Also there is probably no need to differentiate between a defender and a striker by using different classes. Even defenders may score goals and strikers also have to defend. The details likely to be strored for the any position are also likely to be the same. it would far better to define a string data type, possibly called position, to denote weather the position is a striker or defender etc
						
						eg
						public class footballer{
						String position; // can store the position here as a string eg striker
						... // rest of details
						}
						
						The final example of the wayne rooney class is also not a good one. As with any role they are subject to change. He may for example start playing in a different position eg midfield. It would far better to have wayne rooney as an instance variable
						
						eg footballer waynerooney = new footballer(...);
						
						the footballer class would then store any details it needs for wayne roony eg position.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Although it could be argued that trafficqueue class is a type of array list it is a clear example of implementation inheritance. it would far better to declare the arraylist as an instance variable within the trafficqueue class.
						
						eg
						
						public class TrafficQueue{
						ArrayList queue;
						// remaing implementation and initilisation
						}
						
						It might be an even better idea to declare the queue as:
						
						List queue;
						
						this would than alllow us to change the type of list, possibly even at runtime.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						the first two classes, Mobile phone and Digital Camera, are good uses of inheritance as they pass the &quot;IS-A&quot; test. However the last example, Camerphone, is not. Multiple inheritance creates a lot of complexities and should be avoided if possible.
						
						Since a cameraphone is primarily a phone that has a camera a better example wouls be:
						
						public class CameraPhone extends MobilePhone{
						DigitalCamera camera;
						....// remaining implementation
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						the use of Multiple inheritance
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						They all pass the Is-A test, so are good uses of inheritance
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Is a pattern of communicating classes and/or objects that are used to solve a general problem in a specific context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The composte design pattern would be very helpful in this case. At the top of the class hierarchy would the an abstract class question, which would provide abstarct methods such as getMarksAllocated() which is to be implemeted by the subclasses. Two further subclasses will include the atomicQuestion class and the compositeQuestion class. The atomic question class will also be abstract and have subclasses such as a MCQ (multiple choice question) and other question types. These question types will then have to implemnent such methods such as getMarksAllocated
						
						The composite class, aswell as being subclass of the question, it will also contain subquestions suchas MCQ questions and other composite questions. The questions could be strored using a data structre like arraylist for example. this class will also have to implement the getsmarkAllocated() method, however it will use dynamic binding to find all the marks allocated to any subquestion that it may contain. So the compostequestion may look like the following:
						
						
						public class compositequestion
						{
						
						ArraryList subquestions;
						....// remaing implementation
						public int getmarksAllocated(){
						int marks = 0;
						for(int i = 0; i &lt; subQuestions.size(); i++){
						question q = subquestion.get(i);
						marks += q.getMarksAllocated();
						}
						return marks;
						}
						}//end of class
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						One pattern that would be very helpful is the factory method. Factory methods are used to ensure that the correct classes are created at runtime, usualy using dynamic binding. Since the answers will be marked using a human-computer collabritive manner, the factory method could be used to ensure that the correct marking schemes are used to mark the student answers.
						
						Another pattern that could be used is the observer pattern. This would be used to store any input from the user, incase the applet/ computer crashes.
						
						The proxy pattern may also be helpful as it could be used to manage the remote connections to the server.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							contract are very useful as they allow us to specify the right and responsibilities of particular methods, and classes. Pre-conditions are used to define the conditions that a caller must satisfy in order to properly call that particular method. post-conditions are used to specify what the method will in return garuntee as long as the method has been called properly. Class invariants are invariants that must always hold whenever that particular class is in an observable state.
							
							In java the keyword assert is used to specify any pre-conditions (in private methods), post condtions and class invariants.the syntax is
							
							assert experssion1;
							or
							assert expression1 : expression2;
							
							expression1 is always evaluated. if it returns false then expression2 is evaluated and passed to the assertionException.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							SqRoot class:
							Since it only has one method we will have to ensure that the method is called properly. The first pre-condition required is that any values passed to the method are not negative, that is they are greater than zero. if this methodis a public method it would not be useful to use assertions, as they will only throw an assertion error for any invaild values. It would be better to check the values explicitly and throw the appropriate exceptions. if it a private method than the use of assertions would be good idea. The post conditions would possibly include asserting that all the values processed are positive.
							
							Stack class:
							the primary methods wil have to add and remove numbers to the stack. If we are to add number to the stack we need to check to make sure that the stack is not full otherwise we will get a runtime error, most likely an overflow exception. So a precondition would be that the stack is not full and the post condition will be that the value is added to the stack.
							
							If we need to remove a value from the stack we need to ensure that the stack is not empty. so a precondidtion would be that the stack is not empty and the post condition is that the value is removed.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class sqroot{
						
						public stack squareRootStack( Stack stack)
						{
						stack stack2; //
						
						if(stack.isEmpty())
						throw new stackErrorException();
						else
						//obtain each element from stack
						// send to squareroot();
						// add the values returned to stack2
						// then return stack2, with correct square root values
						}
						
						//method for finding the squareroot of a given value
						private double squareroot(double value)
						{
						assert value&gt;0 : &quot;the value: &quot; +value+ &quot; is not greater than zero&quot;;
						// rest of implementation
						//return square root value
						}
						
						}//end of class
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="31" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="42" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Having a class football is a reasonable assumption, as if we are just dealing with players then they will all come under this class. Defender is a type of footballer, so its true that an instance of defender is also always an instance if footballer. The same thing can be said about Striker. Wayne Rooney plays the role of Striker, and is a striker so you would think that, that would be a reasonable assumption to make. The problem comes with the Wayne Rooney class, is what happens if he decides to play a different role in the game. So he becomes a defender instead of a Striker. If this happens then the inheritence of striker is wrong. Doing this also makes the class very inflexible. A better alternatibe would be to delegate the roles.. striker and defender etc to a different class.
						
						e.g
						
						public abstact class Footballer {}
						
						public class Striker extends Footballer{}
						public class Defender extends Footballer
						
						public class FootballPlayer extends Footballer {
						
						Footballer []footballer;  &lt;- an array of the football players we want.
						
						//Then we can have a method to create instances of striker and defender, as they are the roles played by the team. These can be stored in the array above.
						
						}
						By doing this it should be possible to have a team memember having different roles in the game. Eg sometimes hes a striker and sometimes hes a defender.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It depends on the model you use for traffic i suppose. You could argue that trafficQueue is an instance of array least also but i think the link between them is weak. It might be more appropriate to argue that traffic queue was an instance of a vector. As in a vector you can remove objects in the middle without leaving a hole as the vector class automatically manages holes. This would model the behavour of a car doing a U turn in the road and leaving the middle of a traffic queue..... and then the hole in the traffic will get filled. In a similar way it might happen in real life. The problem with this is also any methods in array list are also inherited in trafficqueue and we may not want that, but we have no way of stopping it unless we create an extra class which wraps the class up in. But that is a ugly way of laying out code and only obfiscates it.
						
						so
						public class TrafficQueue{
						
						private Vector vector;
						
						public returnType someMethods() {}
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Having Mobile phone inheriting from electronicequipement is logical inheritance. Because an instance of mobile phone, its true that its also an instance of Personal ElectronicEquipment. The same thing can be said about Digital Camera. Its also logical to assume that the class Camera phone is an instance of both Mobile phone and Digital Camera, because it has the features of both. This could be seen as a good use of inheritance. Also mobile phone and digital camera are reasonable different so there shouldn&apos;t be too many methods which have to be overloaded leading to programmer confusion. However there may be some methods which have to be overridden because they are both instance of electronic equipment and being so are going to probably have at least some features that are going to clash. The problems comes trying to resolve these. How does a programer know always which method is being called from which inherited class. For someone that knows what they are doing its not a problem .. however ..
						
						However it might be easier and a lot cleaner to have code something like this
						
						public class Mobile phone extends PersonalElectronicEquipment{
						
						private DigitalCamera digitalCamera;
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Its a reasonable assumption to assume that a Book or class book is also an instance of Information source. Its not true that a book is also an instance of copyable. It is copyable .. but that doesn&apos;t make it the same thing. It would be better to forget the multiple inheritance using copyable  and have the book copied if need be outside the class because its very simple to do.
						
						so we could have something like
						
						public class aBook impliments copyInterface{
						
						private Book book;
						private Book copyOfFirstBook;
						
						public void copyBook();	//required by interface ..
						
						instance of book = copy of book; ( pseudo code )
						
						}
						
						By specifiying an interface we can elimintate the &apos;problem&apos; of over overriding methods for the object class, as we might need to use the normal copy method for something else. And if we override it we can&apos;t.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first few classes area a reasonable use of inherience. It&apos;s true that an instance of multiple choice answer is also an instance of answer. And the same can be said about text answer. However is noanswerprovided really an instance of answer also because by definitition its not actually an answer. The same can be said about noanswerrequired. Perhaps it would be better for these 2 classes to be part of the abstract answer class. For example ...
						
						
						public abstract class Answer{
						
						private boolean noAnswerProvided;
						private boolean noAnswerRequired;
						private boolean textAnswer;
						
						//get and set methods for above
						
						}
						
						By doing this there is then no need to have the extra classes NoAnswerProvided and NoAnswer Required, which only seem to add complexity to the system. Perhaps also we can have a boolean for text Answer. The reason for doing this is there could be confusion perhaps between the above classes. For example you could have a multiple choice question consisting of text. Using this method and the booleans you can show this behavour.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of communication classes and/or objects which can be configured in such a way that they solve a general design problem, in a given context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						A whole exam is made up of lots of small parts which are questions. To work out the entire mark for the exam we need to work out the mark for each of the sub sections of the exam, and then in turn the marks for each question individually. Its logical to think of a single question the same way as a section in an exam. And sub sections of exams and exams themselves in the same way. For example when we want to add up the marks for everything to get the final mark. We can use the composite design pattern for this.
						
						we can have something like ..
						public abstract class Answer{
						public abstract int getMarks()
						//....
						}
						
						public class SingleAnswer extends Answer{
						public int getMarks();
						//......
						}
						
						public class ExamSection extends Answer{
						
						private Answer []answer;
						
						public int getMarks() {
						
						looping through the array of answer to add up all the marks
						then return result
						
						}
						
						By using the composite design patter we can treat all the small subsections of the exam in exactly the same way as the whole exam itself which grealty simplifies everything. Also we can have different AnswerClasses which work in completely different ways. As long as they still extend the class Answer we know these classes will work in the rest of oursoftware. Eg to add up all the rest of the marks. We use dymanic binding for the last method for this.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						Because everything is happening remotely using servers and applets we could use the proxy design pattern. This lets the applets communicate through the proxy to the central server. It should be transparent to the applet and the interface will be very similar to that of the real class.
						so applet -&gt; proxy -&gt; server
						
						Because the server will have information coming in from all over the place it doesn&apos;t want to poll the clients constantly to see if it has new answers. A better solution to this would be to use the observer pattern. The server would be the observer and the clients would be the observables. The server would register its interest in the clients and the clients would notify the server when something changes, for example and answer or when a test finishes.
						
						In the program, for the applets they might have a class Question with certain properties and variables such as text for th actual question. The program might have an instance for each question in the exam. This could take up a lot of space, depending on how many questions there are in the actual exam. The flyweight pattern might come in useful here. The instance of the class should be created outside the factory. The reference to the classes then should be added to an array or something.. The class has intrinsic properties, ie the text for the actual question perhaps. We can externalise some of the properties of the class and put these in a seperate class. So there could be 50 questions and these would all have a mark out of 5. So 5 would be stored in the class itself and the extrinsic properties of the class.. ie the actual text for the question could be stored externally to the class. This adds significant complexity and potentially significant decrease in space needed for storage.. it depends on the amount and type of questions i suppose ..
						
						When marking the questions there is going to be different ways of marking it. Eg using a class to mark an exam or using a human to mark it and manually put in the results. Either way we want to easily be able to change the way the program is marked without making too many changes to the program. The strategy design pattern fits this bill. The idea is you create an abstract class with a set of interfaces. The inherited classes then use these interfaces and return the results required. And as long as the classes conform to the interfaces the marking class .. ie human or computer can be interchanged without making changes to the rest of the program.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							When creating a program for someone its very easy to create a progam that doesn&apos;t always work in a way that the client intended. For instance a program might give stupid answers if the client enters 0 for a calculation or some other number. It might be logical that a zero should never be entered into the program and therefore should&apos;t be worried about. However if the client hadn&apos;t specifically said he wanted his program to be designed so it handles this case then who is to blame. Design by contract allows formal specifications for public methods or classes or programs i guess. They introduce pre and post conditions into methods and classes. And class invarients. For pre conditions its like saying i will only handle numbers positive numbers. Then that method will only accept positive numbers. Post conditions say that it will return a valid result of for example positive numbers if the pre conditions of the method or class are satisified. Therefore its a way of insuring that the client gets exactly what s/he desires. Then when the program doesn&apos;t do quite what the client wanted and it was specified to be this way then its the fault of the client not the programmer. Class invarients are similar also. They say that the conditions of a class always have to be met. And if they are so then the class should give the correct (desired) results. For example the invarient for a tree class could be that its always balanced.
							
							in a language like Eiffel we can use require and ensure statements
							
							so we can have a method ..
							public returnValue methodName(int x) {
							
							require x &gt; 0   &lt;-- pre condition
							
							some calculations
							
							return ( ensure x &gt; 0 ) etc &lt;-- post condition
							
							}
							
							In java we use assert statements
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							Logical assumptions for this class are. If the client gives positives numbers then the class will be able to produce valid results. Valid results are also positive numbers. So these should be the pre and post conditions for the square root class.(positive numbers)
							
							public class SquareRoot{
							
							assert statement1;
							assert statement1; statement 2;
							
							public double squareRoot(double x) {
							
							assert X &gt; 0
							
							//(math for computing result ....)
							
							return (assert X &gt;0) x;
							}
							
							The assert statments in java can be turned off. But if they are on and the pre-conditions or post conditions evaluate to false then an assert error will be thrown by the class. Normally a gerneral assert error is thrown as assert statements are booleans. However in the case above statement1; statement2 the 2nd one doesn&apos;t have to be a boolean. It can be a reason for the pre/post condtions being broken. This can be used to fill the constructor which handles the error messages.
							
							For a stack class we might want it to only use up a certain amount of memory, therefore a class invarient might be that the stack never has more than 100, therefore ..
							
							public class Stack{
							
							int numberInStack;
							
							public push(double value) {
							
							//code
							checkInvareient();
							
							}
							
							public double pop() {
							
							//code
							checkInvareient();
							return number;
							
							}
							
							private void checkInvarient() {
							
							assert 100 &gt;= numberInStack;
							
							}
							
							Therefore in this class whenever a method is called the private method check invarient is also always called. By always calling this method which can always make sure that the class satisfies the invareitn. If the class breaks the invarient either its broken the pre-conditions specified for the class or the class has failed to do work properly. In this the assert statement will evaluate to false and an assert error will be thrown by the class.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Program outline. The program would contain an instance of the stack class which all the numbers held in it. It would also contain an instance of the square root class..
						
						eg
						
						public class Program{
						private SquareRoot squareRoot;
						private Stack stack;
						
						
						}
						
						All the numbers would be held in the stack class. The pop method in stack would be called. The value would be returned then put through the method squareRoot in the squareRoot class. Another stack could be used to store all the results. The benefits of this program are because we have used designed by contract to build these java classes and have coded assert statements into it. If while making the program the program breaks the assert statements because it has failed the post conditions whilst the pre-conditions were satisified then we know its something we did wrong in the class implimentation, and hence it can be debuged. When the program is finished and if the client complains it hasn&apos;t work 100%. If the client has broken the pre-conditions for the program/classes then its his fault for not correctly specifiying the contract correctly not the programmers fault for poor implimentation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="32" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="34" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This seems a good use of inheritance, as the classes follow the is-a rule: WayneRooney is-a Striker and a Striker is-a Footballer. However, something to consider would be, that a Footballer can change his role throughout the game (the real, problem-domain Wayne Rooney tends to chase the ball wherever it goes, often as far back as his own goal..) so a Footballer could be a Striker and a Defender in the same game. From this we can see that Striker and Defender are more characteristics of a Footballer, than clear, coherent classifications, and seeing as it hard to change an inheritance structure at runtime, it would be best to implement the functionality via delegation:
						public class WayneRooney {
						private Striker strikingQualitites;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Could be argueud to be a bad use of inheritance, because it looks like it is performed for the sake of convenience (implementation inheritance), rather than being a logical classification of something. That is to say a TrafficQueue, representing a real-world queue of traffic is not a type of Java ArrayList data structure, so it would be more sensible to use delegation. A TrafficQueue has an ArrayList:
						
						public class TrafficQueue {
						private List queue;
						public TrafficQueue() { queue = new ArrayList(); }
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						(Full) Multiple inheritance sould always be considered carefully, as:
						- A performance overhead is incurred (extra cost of dynamic binding and managing store)
						- Programming becomes more difficult as there is a need to disambiguate names, and this can make the code verbose and ugly, which makes it harder to follow.
						There is usually a better solution than multiple inheritance. In this case, delegation:
						A CameraPhone is a MobilePhone with a Digital Camera:
						public class CameraPhone extends MobilePhone{
						private DigitalCamera camera;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is full multiple inheritance which should be considered carefully for the reasons outlined in the previous question (performance, and ease of programming).
						In this case, full MI seems to be an elegant solution to the problem, although it is fair to ask whether there is call for for a Copyable class (particularly one which is not declared abstract) as, each Object that is Copyable (or a large majority), would have to implement its own version of the copy() method. Copyable could therefore be implemented as an interface:
						public interface Copyable {
						public Object copy() { ... }
						}
						public class Book extends InformationSource implements Copyable { ... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This seems a good use of inheritance as far as MCQAnswer and TextAnswer are a suitable, logical classification of an exam Answer. NoAnswerProvided and NoAnswerRequired, are more difficult, as they are not exactly answers to a type of exam question, like the other two, but none-the-less are valid classifications of an answer.
						An alternative to this approach would be to flag answers as not provided, or not required, which might lead to a cleaner abstraction for the system, but the price payed would be the ability to treat all the subclasses the same as they all extend the same superclass. I would leave it as it is.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It is important for OO software that encapsulation be available as OO software construction relies on the interface to a class being the only way to use it. An interface is made of all the items in a class that are made available to other classes. It is necesary that this be the only way that an object is used as the implementation could be changed, although the interface should remain the same.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation helps with manual storage management becase a large object stored in memory, can manage the space it stores for itself. An example of this would be where an object is deleted after has been used: if a signal is sent to the object to instuct it is being removed, as in the case of a destructor in C++, then it can remove its own sub-objects, from the memory before ending.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design by contract needs encapsulation because otherwise an outside class would be able to any variables or methods in another class, and only the ones defined in the interface have guaranteed outcomes (postconditions) given their operation and a precondition that was met when they were called.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is an way of solving a general design problem in a specific context, the problem being too general to have a simple answer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The Composite design pattern could be used to construct trees of questions and subquestions on the exam paper.
						The way the pattern would be applied in this scenario would be to have an abstract superclass Question, and two concrete subclasses inheriting from that for AtomicQuestion and CompositeQuestion. The AtomicQuestion represents a single answer question, whereas the Composite question maintains a List of the Questions it has as sub-questions. This would construct a tree of questions which could all be treted uniformly using the interface defined in the abstract superclass.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						The Proxy design pattern would be used to delegate the remote communication to another object, which would delegate the processing to the central server. This hides the complication of remote communication from the client object by having the proxy object provide (at least part of) the same interface as the server, simplifying the operation of the client. This makes the work of the client clear, without cluttering it with remote communications code - the client, and server are coherent objects. Also the proxy is likely to provide some added-value such as cacheing of the data from the server.
						
						The Observer patter would be useful for questions that require Human-Computer collaborative marking. It splits the operation of an object into parts:
						Observables - objects that have a state that is likely to change at some unpredictable time
						Observers - objects that have an interest in (will react to) observables
						In this case it is clear for the computer and marker to work together the computer will prompt the marker (with an observable), and the computer uses the marker&apos;s inuput to mark the paper away from the Human Computer Interaction (HCI) code - the observer.
						
						Strategy would be used to switch between the different kinds of strategies used to present the information to the marker. There would be an abstract superclass from which some concrete subclasses representing the different strategies for presenting the informatin would inherit. Dynamic binding would allow the correct strategy to be slected at run time.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="33" examId="CS310105" timeTaken="6417" isSubmission="true" allImages="true">
		<compositea marksAwarded="49" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of inheritance shown here is a case of the &quot;Roles&quot; problem. That is, classes are created that are roles played by people. The first two (Striker and Defender) clearly pass the is-a test, but to a certain degree can be viewed to be cast in a particular role (imagine when a defender is sent off, it is possible for a striker to become a defender). Depending on the way these classes are used, this is possible, but marginal. A better representation might be
						
						public Class Footballer { FootballerRole currentRole; }
						public interace FootballerRole { /* the required opperations, eg think() */ }
						
						The latter (WayneRooney) is clearly an instance of the class Footballer (or Striker, in the example) and should not be defined as a class (regardless of skill!)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This use of inheritance is problematic because by extending the ArrayList class, the TrafficQueue class inherits (and exports) all of the public members of ArrayList. That is, it would be possible for a user of the class to arbitrarily insert elements into the queue, without calling the methods implemented in TrafficQueue. Moreover, this method binds the implementation of TrafficQueue to using an ArrayList, which is not easy to change. A better way of doing this is with delatagion, and the use of the LIst interface:
						
						public class ArrayList { ... }
						public class TrafficQueue { List list; }
						
						Here we can change the internal representation without having to change user code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This seems to pass the is-a test, in that a CameraPhone sort of &apos;is-a&apos; MobilePhone and sort of &apos;is-a&apos; DigitalCamera, but in reality it is possibly more one than the other, or neither. It may therefore be better to delegate the functionality of the seperate parts withing the class, eg
						
						public class CameraPhone extends PersonalElectronicEquipment {
						DigitalCamera cam;
						MobilePhone phone;
						}
						
						this way, we avoid all of the problems associated with Multiple Inheritance (especially as both inherited classes inherit from the same source) and can still use CameraPhone in collections of PersonalElectronicEquipment
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is an example where MI appears to be the best solution to the proposed problem. However, a language like java supports natively a method for solving this problem, and re-solving it is not often the best solution. That is, it is always possible to override the default clone implementation, on a class-by-class basis.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this example, unless there was a considerable difference between the implementations of the particular classes, it may be more suitable to use parameterisation to accomplish the task (within the answer class). The likelyhood is that the implementations will be only slightly different. For example, you may define:
						
						public class Answer { bool answerProvided; bool answerRequired; String answer; int choice; }
						
						with appropriate constructors, accessor/mutator methods etc.
						
						In the case where the actual operations performed by each answer are very different (which I doubt) then the given solution may be appropriate.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						&quot;A collection of communicationg objects and/or components which can be adapted to solve a general design problem in a specific circumstance&quot;
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						In the application, it is clear that the implementation will contain a bespoke type of tree, containing Questions, representing the exam. This allows for arbitrary nesting of the question parts. The composite design pattern encourages you to define types of &apos;things&apos; and types of &apos;composite things&apos; - that is, there is a BasicThing and a CompositeThing containing an arbitrary number of other Things. This can be applied directly to the exam software. Here we define an abstract class Question, and classes BasicQuestion and CompositeQuestion. To illustrate the flexibility of the pattern i have defined one method drawQuestion, which draws the question to a Graphics object:
						
						public abstract class Question { ... public abstract void drawQuestion(Graphics g); }
						
						public class BasicQuestion extends Question {
						String questionText;
						...
						public void drawQuestion (Graphics g) { g.drawString(questionText); } /* or whatever */
						}
						
						public class CompositeQuestion extends Question {
						ArrayList subquestions;
						...
						public void drawQuestion(Graphics g)
						{
						for (int i = 0; i &lt; subquestions.count(); i++)
						{
						Question q = (Question)subquestions.get(i);
						i.drawQuestion(g);
						/* perhaps do something else */
						}
						}
						
						It is clear that a CompositeQuestion may contain any number of BasicQuestions and other CompositeQuestions, by using polymorphism of the Question class
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						1. Observer
						In order to deal with the user interaction, it will be neccessary to abstract the implementation of GUI objects and the objects which react to the events (such as button presses, etc). This is a classic use of the Observer pattern, in which a button may be thought of as Observable, as it is only interesting when its state changes, and a class in the application (such as HelpPanel) is an Observer, as it reacts to the change of state of the Observable. This is usually implemented in Java with &quot;Listener&quot; interfaces (in the case of buttons, ActionListener) Other examples of this in the software could be a ServerMessageObserver, reacting to messages send via the network to the client. This works nicely with the Proxy pattern, explained below. (consider the proxy as being Observable)
						
						2. Proxy
						As this is a distrbuted application (in the sense that it has a client/server architecture), there will be a considerable amount of work performed by Network IO classes, including data/redundancy checking and of course sending/receiving data. Clearly it is not desireable to handle this code everywhere it is needed, and a proxy class may be set up, with an identical interface as the network library, which performs this checking. This can also allow the system to carry on working if there is a temporary delay/failure in the network transport as the proxy may spawn a new thread to complete its communication with the server, and perform any other opperations. This abstracts the deiificulty of network communication from the rest of the application.
						
						3. Flyweight
						Bearing in mind that the questions will have many different answer types, it is quite possible that at any given time a large proportion of them may be empty, eg EmptyAnswer. if, for example, there are 100 questions, then that may require 100 EmptyAnswer instances. Applying the flyweight design pattern, using an Object Pool, it is possible to reduce this to precisely 1 EmptyAnswer instance, by sharing the instance accross all Questions. This is clearly a benefit, especially when network bandwidth is taken into consideration. Note that the flywieght pattern uses a factory method to get instances of classes, and will only return a new instance if the requested instance does not exist. In addition, there may be many MCQAnswers which have 1 as their value. The flyweight pattern can be applied to this and, if for example there are only 4 options for all questions, can reduce the number of instances to 4.
						
						4. Visitor
						In the marking process there may be a number of different algorithms for marking different question types. The visitor design pattern can be used to remove the implementation of the marking code for a specific question to one coherent module. In this pattern, each Answer &apos;accept()s&apos; a Visitor and calls something like visitor.visitSpecialAnswer(), thereby allowing the marking code to be contained in one class and not distributed over many different classes, causing ugly and difficult to debug code. This is a controvertial use of OO, but quite appropriate for systems with algorithms which need to opperate on a large number of objects.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts help to ensure both the correctness - satisfying a consise specification - and the robustness - ability to react to situations not in the specification - of code. They work as a collaboration of the client and the library, in that IF a client GUARANTEES to call a method in a certain way, the library GUARANTEES to return in a certain state. More formally, you can define contracts as pre- and post-conditions for methods, and invariants for classes. That is, if P and Q are predicates, and S is an arbitray length program (eg method, intruction) {P}S{Q} means IF S is executed in a state satisfying P, then when S terminates Q is GUARANTEED to hold. In both cases there is an obligation and a benefit for both parties (the client and the library). Additionally, in any observable state (that is, when a method is not currently executing) a class invariant is GUARANTEED to hold for the class. This provides robust code that can be proven to be correct with respect to the given pre-conditions and invariants.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							The SqRoot class needs only one public static method. The precondition required for this method is that x is any real number (implied by the type float) and precision required is greater than or equal to some (arbitrary?) constant, and the postcondition is that retval (the returned value) is the square root of x . It is possible to check at runtime that the latter is true, and this has been demonstrated, tho it is not essential.
							
							public abstract class SqRoot {
							
							/** pre: precisionRequired &gt;= 1e-10 AND x = N*/
							public static float squareRoot(float x, float precisionRequired) {
							if (precisionRequired &lt; 1e-10)
							throw new InvalidArgumentException(&quot;Contract broken: precisionRequired &lt; 10e-10&quot;);
							....
							retrun retval;
							}
							/** post: retval * retval = N */
							}
							
							Clearly this class has no state, and an invariant would be unneccessary.
							
							The stack class, on the other hand, will have state, and nonstatic methods, push and pop. If we implement the stack as a bounded array, we can reason about the methods and the class. Firstly we can say that given a stack pointer (sp) rangng from 0-(MAX_STACK-1) (that is, the array boundaries of stack) we can decalre a class invariant that sp will always be within those bounds. This invariant is also the postcondition for the constructor of the class, as it must be left in an observable, valid state. For the push method, it is required that there be space on the stack (ie. sp is less that (MAX_STACK-1)) to put the new value in. The postcondition is that the new value is placed on the top of the stack, and the stackpointer is updated. Similarly for the pop method, the pre-condition is that the stack is not empty (ie sp &gt; 0) and the poscondition is that the value on the top of the stack is returned and the stackpointer is decremented. Again, specific checks for these values (or even, but less likely assertions) can be made to check that the contract is being adhered to. in this example i have ommitted them.
							
							public class Stack
							{
							public static final int MAX_STACK = 100;
							Object [] stack;
							int sp;
							/** inv: sp &gt;= 0 AND sp &lt; MAX_STACK */
							
							public Stack() { stack = new Object[MAX_STACK]; sp=0; }
							
							/** pre: sp &lt; (MAX_STACK - 1) */
							public void push (Object x) { stack[sp++] = x; }
							/** post: stack[sp] = x AND sp&apos;=sp+1*/
							
							/** pre: sp &gt; 0 */
							public Object pop () { return stack[--sp]; }
							/** post: retval = stack[sp] AND sp&apos;=sp-1 */
							
							public boolean isFull() { retrun sp == MAX_STACK - 1; }
							public boolean isEmpty() { return sp == 0; }
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Given that we can verify the correctness if the SqRoot and Stack classes, based on their pre- and post- conditions (which we should for DbC), and that we guarantee to adhere to the pre-conditions, then we can use the classes and be assured that the values will be as we expect. For simplicity we can imagine that that we only want to consider square roots of integers, and we can clearly use the Integer class in the Stack object. For demonstration purposes, I have added numbers to the stack from the command line, but it is equally plausable to have a method which takes a (non-empty) stack as a parameter.
						
						class RootStack {
						public static void main (String [] args)
						{
						Stack stack;
						int i;
						while (!stack.isFull() and i &lt; args.length)
						stack.push(new Integer(args[i]); /* ignoring exceptions */
						
						float precision = 1e-9;
						while (!stack.isEmpty())
						System.out.println(SqRoot.squareRoot( (float)(((Integer)stack.pop()).intVal()), precision) + &quot;\n&quot;);
						}
						}
						
						The benefit of using the SqRoot and Stack classes is that, given that we have obeyed our part of the contract, we can be sure that the classes will behave as expected. This is the DbC advantage, regardless of the numerous advantages of code reuse and portability.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="34" examId="CS310105" timeTaken="6781" isSubmission="true" allImages="true">
		<compositea marksAwarded="29" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The above is a sensible use of inheritance in that Striker and Defender both pass the is-a test. These are therefore both acceptable uses. However WayneRooney is not a valid subclass of Striker. In this case it would be more appropriate for WayneRooney to be an instance of the striker class as shown here
						
						Footballer wayneRooney = new Striker();
						
						With Striker and Defender they would both use the same methods and instance variables as footballer, maybe such things as a tackel() or shoot() methods.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is not really sensible use of inheritance, it would be better to make TrafficQueue a client of the array list class, in that in the class somewhere is an ArrayList embedded, as shown below.
						
						public class TrafficQueue{
						ArrayList carsInQueue = new ArrayList(...);
						}
						
						This would probably be a more sensible way to use the class, as inheritance is not appropriate. It could not honestly be said that a TrafficQueue is an ArrayList, it just uses the structure to represent what is happening in that environment.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Again this is rather fuzzy. Using inheritance in this way is possible but I&apos;m not sure its the right thing to do. For a start, MobilePhone would have a whole different set of methods, variables and structures needed to be implemented over the PEE class, this alone would make it a bad choice. The same can be said for DigitalCamera.
						
						In the multiple inheritance example, many OO designers would dismiss this as a bad idea right from the start, because of the beleif that MI is bad practice. However as far as I can see, in this example the use is fairly sensible, a CameraPhone would use all of the methods a Camera and Phone do, making this a plausible solution.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is the wrong way to implement such a feature in java code. Here the correct way to do things is the use the &quot;implements&quot; keyword. It cannot be said that a Book is a type of Copyable, but yes, it is a type of Information source, an acceptable use. The following, ignoring possible syntactic errors is a more realistic approach.
						
						public class Book extends InformationSource implements Copyable{...}
						
						This allows the Book to be copied when the method is called, but does not place a book in the subtree of the object Copyable.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The MCQAnswer and TextAnswer classes are perfectly valid uses of inheritance in this example, they are both valid types of question and would have variables such as int marksAwarded. However NoAnswerProvided is incorrect in this example. A question where no answer is provided is not a specific type of answer, it is just a question in which a blank answer box was given for example. This would be better expressed as 0 mark awarded in either of the above 2 classes, MCQ or Text. This is fairly difficult to visualise, and depends on what the programmer is expecting from the system, but the logical thing to do would be to not build a class for this.
						Again with NoAnswerRequired this is probably wrong. The questions which are not marked are randomly chosen at marking time, so allocating a separate class for this would seem illogical, we do not know beforehand if a question is of type NoAnswerRequired. It would be better expressed, still, as of type MCQ or Text, but maybe a variable to the answer class can be implemented, such as &quot;boolean answerRequired&quot;.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is fundamental to OO programming as it hides the implementation of the inner workings of a module or class. The programmer  doesn&apos;t know what is happening behind the scenes nor do they need to worry about it. Abstraction goes hand in hand with this notion. Abstract classes for example can define method headers, and show how they should be called, and with what paramters. Lower classes build upon these classes to implement concrete functions.
						It can therefore be said that encapsulation is necessary for abstraction.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This statement is very much true. Encapsulation can help improve performance by ensuring tasks are performed in the fastest way possible. Functions which already exist are called instead of having to worry about creating new methods or classes to handle the requirements manually.
						This can provide a method for code re-use which is always a good thing in programming environments, when compiled, it can be optimised and will be faster.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is true in that encapsulation provides a way to hide the inner workings of the system away from the programmer. They need not know about how data is written or organised on the disk, how IO on the specific operating system is being handled etc.., this is handled by the function being called, programmed by someone know knows what they are doing, and how to increase the performance of such applications or classes.
						For example in java encapsulation is critical in the number of functions being called. Methods are proivided that help with writing to the disk, serial data, binary data, text data etc.. All handle the data in different ways, but the user need only know the function, and how to pass the paramters. This makes things incredibly easy for the programmer calling these functions.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design by contract tries to ensure the correct operation of classes using agreed rules between classes. For example a BodyMassIndex class used to calculate a humans BMI cannot be passed negative height or weight parameters else this would violate the contract. These contracts are expressed between classes which are encapsulated. For the dbc to work, this needs to be the case.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Contracts are like a set of rules and ensure that classes operate as they should do and no data is passed to methods etc. that violate them. It could be said that contracts are like an agreement between classes that specify what can be passed in and out to each other. When dbc is not used it is more likely that the system will fail from exceptions, as was shown in the infamous rocket crash, where the number passed in software was not properly checked, a different word length was being used than was expected. This kind of thing can be checked using contracts as soon as data is passed to the method, and again when data is passed out, using such things as &quot;ensure&quot;, in eiffel.
							
							Therfore in each method in the class library it would be sensible to provide some kind of contracts in the methods that check for valid data being passed in and out. As soon as the method receives a variable through a parameter, such a function like &quot;assert&quot; can be called from java, that ensures it is in the required range, if not, it can be dealt with cleanly. Again when values are returned they can be checked to withold the contract rules. Using this technique we can ensure a more stable operation between classes.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Obviously in a class such as SqRoot you are going to have a critical function that calculates the square root of a number, lets call it double findSqRoot(int number);. There is an obvious rule when calculating square Roots of numbers also, in that the number passed in to the function must be greater or equal to 0, otherwise the function, assuming it works on Real numbers, not Complex numbers, will fail. Therefore we need some kind of checking when we go into the function, this could be done in the following way using java code:
							
							class SqRoot{
							double findSqRoot(int number){
							assert number &gt;= 0;
							double result = squareRootOf(number);
							return result;}
							}
							
							We have now ensured that the number passed into the function is a valid one, using dbc, a number of less than 0 will fail the assertion test and will be dealt with. This is critical to the function and if it was not present the program would fall over when dealing with invalid paramters.
							
							Likewise with the class Stack, we need to ensure that the stack is properly maintained by the class at all times, a method such as pop, should provide an assertion that there is is at least 1 value on the stack to pop off, before it performs the pop, this would therefore be placed on method entry, before any of the other code is executed. Likewise with the push, the program should ensure that the stack is not full before it performs this operation, failure to do so could, or would, cause program errors so dbc in this situation is a healthy idea.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This program would have to pull numbers off of the stack sequentially using the pop operation on the Stack class, using the number returned we can now call SqRoot on them to get the required result.
						
						The benefits of usinging SqRoot and Stack are now obvious, we can ensure that our program runs without worrying about an overflowing or underflowing stack, and that our SqRoot method is only called on valid positive numbers, resulting in fewer checked exceptions. It would be logical to check the validity of parameters being passed by this program also, using the assert function before they are passed.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="35" examId="CS310105" timeTaken="6983" isSubmission="true" allImages="true">
		<compositea marksAwarded="46" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This use of inheritance is reasonably sensible, in that Wayne Rooney &apos;is-a&apos; striker. It is also true that a Striker &apos;is-a&apos; Footballer and that Defender &apos;is-a&apos; Footballer. However, a footballer may change position during the course of his career, for example Sol Campbell started as a Striker and then became a Defender. This would be very hard to simulate using the above configuration due to the fact that the position played is the role played by a footballer. It would be more beneficial to have a class FootballerDetails which contains details of all of the footballers, and then the classes Striker, Defender etc can reference these footballers. This would allow footballers, (eg. Wayne Rooney in above configuration) to change position, or indeed have multiple positions as is true of real life football.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This seems like an obvious solution to the problem of a TrafficQueue as, from the ArrayList it is possible to remove the top element, ie the first car in the queue, and shift all of the other elements up. However, a TrafficQueue is not an arrayList. In an arrayList it is possible to access and remove objects from inside the structure. In a real-life traffic queue, it is impossible to &apos;remove&apos; a middle object, and so this is not quite correct. The main reason for this being not quite sensible is the first rule of inheritance, that TrafficQueue &apos;is-a&apos; ArrayList.
						It would be more sensible to delegate to a structure, be it arrayList or vector or anything. This would also serve to help enable the ability to be able to change the type of strucutre used without having to change lots of code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This use of inheritance is very sensible. The class PersonalElectronicEquipment will contain methods such as &apos;chargeUp()&apos; which will be used for any subclass of it. The inheritance used for DigitalCamera and MobilePhone are examples of Sub-type inheritance, where it is easy to argue that they are &apos;PersonalElectronicEquipment&apos;, and they will require all of the methods available in the abstract class.
						The class CameraPhone, which extends both MobilePhone and DigitalCamera, is plausible. However, it will be prone to coding bugs. For example, a digitalCamera and a MobilePhone will both have methods to increaseVolume(). This will mean that when creating CameraPhone, explicit coding of which class a method is inherited from will be essential.
						I would suggest that a CameraPhone &apos;is-a&apos; mobile phone which &apos;has-a&apos; digital camera. With this new definition, CameraPhone would inherit from MobilePhone, and delegate to DigitalCamera, by creating an instance of it inside the class. CameraPhone would become a client of DigitalCamera.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						An immediately obvious problem with the proposed replacement is that there would never be a need or use for creating an instance of Copyable (Copyable x=new Copyable()). The class should therefore be declared &apos;abstract&apos; meaning that it is only implemented through classes that inherit it.
						The class Book seems to be sensible. A book &apos;is-a&apos; InformationSource and is a &apos;copyable&apos; object. This use of inheritance would be workable. As an alternative to this method, I would suggest making Copyable an Interface, and then it would be come:
						public class Book extends InformationSource implements Copyable{....}
						I recommend this because copyable is not an object. It is a type of behaviour, thus an interface should be used to model it.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						MCQAnswer extends Answer is a good use of inheritance. MCQAnswer &apos;is-a&apos; Answer, as is TextAnswer. These are both good uses of inheritance in the pure sense.
						The class NoAnswerProvided is not needed in my opinion. This class, which represents an answer that a student failed to provide, could more easily be represented as an attribute in either a MCQAnswer or TextAnswer. For example if MCQAnswer has possible answer values 1,2,3,4, then could add another value of NO_ANSWER. This would mean that less space is utilised by removing this class.
						The class NoAnswerRequired is an example of implementation inheritance in that the argument for NoAnswerRequired being an Answer requires a certain level of creativity. Presumably this class has been created to allow polymorphism to take place where these classes are instantiated, and so although its not completely correct, it can still be used. An alternative would be for the Question class associated to contain the information on whether the answer is required or not.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A Design Pattern is a description of a way of designing something which can be implemented in different contexts. It enables less experienced programmers to gain from the experience of experts.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The composite design pattern describes how to create a tree-like structure in which all nodes can be treated uniformly, ie understand the same messages. It could be used in the design of the on-line examination software by creating correct hierarchies of questions. For example, according to the pattern, it would be beneficial to have an  class &apos;Question&apos; with subclasses &apos;CompositeQuestion&apos; and &apos;SingleQuestion&apos;. A CompositeQuestion is made up of various objects of type Question. These objects can either be of type SingleQuestion or CompositeQuestion, and so on. This would mean that, once the answers have been marked on a given exam paper, it would be possible to send a message &apos;getExamMark()&apos; to the exam paper (which is itself a composite question made up of composite questions, made of single questions), and the message would be sent down the chain, returning the answer to the head node. In this way, the composite design pattern could be used to implement such a system.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						The Strategy pattern could be used to implement the algorithms that present the information efficiently. Depending on the type of question or exam or marker, there will be a different optimal presentation format. This is decided upon by an algorithm. Rather than having a set of algorithms in the code that are chosen between and hard to add to, this pattern suggests creating each algorithm as a seperate object. These objects are implemented during run-time using dynamic binding.
						
						The proxy meta-pattern could be used in the global implementation of the system. A proxy adds a level of transparency to the system, so someone in Brazil thinks that they are talking directly to the server in Manchester, when actually they are talking to a proxy. This proxy has the same interface as that of the server in Manchester, and has the ability to store pages of information. When some communication takes place, the brazilian sends information to the proxy and it communicates on behalf of the brazilian with the server. Stored information in the proxy can be accessed by the brazilian, allowing faster transfer of data.For example, if he wants to do the same exam twice, the exam may be stored in the proxy and loaded from there, rather than having to send it across from Manchester.
						
						If there is a need or requirement that only one instance of a particular exam exists, for example there is only 1 English A-level from the AQA board every year, then the Singleton pattern would be of good use. This pattern ensures that there is at most one instance of a class present in a system, and none if it is never used. It does this by checking to see if the object has already been created. If it has, it returns that object. If it hasn&apos;t then it creates a new one and returns that. Thus if AQA do not set an English A-level exam then none is created.
						
						If there are a lot of small questions in different exams which are the same. It would be possible to use the flyweight pattern. This pattern moves its intrinsic state to an extrinisic position. It does this by placing characteristics about itself in a seperate class. In this case, it would be possilbe to have a sequence of questions in a class QuestionArray, and then SingleQuestion could index into this array and retrieve the appropriate question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<compositea marksAwarded="11" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of introducing contracts is so that each class of the library knows how to interact with the other classes in the library. Contracts define the way classes interact as each party having a set of rights and obligations. It is through this set that we can test the library for correctness and robustness, ie. reliability.
							In order to define the contracts, pre-conditions for each method are set. These define the clients obligations, and are a benefit to the supplier. Post-conditions are also set for each method. These define the suppliers obligations, what the supplier guarantees, given that the pre-condition is met. They are a benefit to the client. Class Invariants guarantee some features of the state of the class before and after every method.
							Class contracts also help to achieve encapsulation in the library, hiding the implementation of the class from one to another.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							The class SqRoot would have preconditions set that the number it is to find the square root of is non-negative, non-zero. This would be done by checking the input parameters inside the method which collects the input, throwing an IllegalArgumentException if the pre-condition is not met. The post-condition of the calculating method would be that the returned value is also greater than zero. This would be enforced, or checked by using an &apos;assert&apos; statement at the end of the method.
							
							The class Stack would be defined with a constructor with a pre-condition that its size is greater than zero. This may not throw an IllegalArgumentException, and just create one with some default size instead. A class invariant implemented in this class would be:
							ensure currentSize &lt; stackSize;
							A pre condition to addElement() would be that there is space in the stack, and a postcondition would be that the number has been added. In removeElement(Element e), the pre-condition would be that e exists in the stack, and the post-condition that the element has been removed.
							Some methods, eg sortStack(), may not have pre-conditions, but all should have post-conditions.
							
							Java has some built-in fetaures of design-by contract which would apply to both classes. These are the pre-condition that the argument type of the client matches the argument type in the supplier&apos;s method. Also the post-condition that the return type is the same as that stated in the method signature. Class invariants that are built in include that variables are of the same type as the one given to them on creation.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						This program would create an instance of Stack, and add numbers to it. It would then use the class SqRoot to calculate the square root of each of these numbers and then, perhaps, store these in a different instance of Stack.
						The main benefit of using these two classes together is that they provide the desired functionality for the system. Additionally, due to the use of Design By Contract, we can be sure that providing our class meets the pre-conditions of both classes, the post-conditions will be met. The reliability of the two classes mean that we can be sure that our program will work successfully providing some checks are done on the numbers in the stack. This, in turn, gives us confidence when programming and, when a problem happens, eliminates a possible source of the problem.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="36" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="21" isMarked="true">
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is not a very appropriate use of inheritance, each type of footballer inherits from an abstract class. This means that the the class of footballer would have no implementation, this is wasteful and inefficient because each of the further subclasses will have to implement the class of footballer in its own right. Better would be to have a class of footballer from which the other classes extend, followed by an instance of a striker WayneRooney, since WayneRooney is not a type of Striker he IS a striker.
						
						public class Footballer { .. }
						public class Striker extends footballer { .. }
						public class Defender extends footballer { .. }
						
						Striker WayneRooney = new Striker();
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this use of inheritance I assume a car is analgous to an element in the array list. This is an inappropriate use of inheritance if it is to be the case that the TrafficQueue class does not add to of remove from ArrayList in any particular matter. In this case it is better to simply make a TrafficQueue that is an instance of ArrayList, with such an implementation cars can be added and removed from as using methods from the ArrayList class as appropriate.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is an appropriate use of inheritance. PersonalElectronicEquipment will have operations such as turnItOn, turnItOff, batteryLevelStatus and other operations that are common to all types of PersonalElectronicEquipment. For different types of PersonalElectronicEquipment these operations would need to be implemented in different ways, hence it is efficient to make PersonalElectronicEquipment abstract such that subclasses can implement the operations in their own manner. CameraPhone would inherit from two classes.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is an uncessary use of inheritance this mathod produces much more &apos;mess&apos; in terms of coding than there needs to be. Since the copy method is to be commonly available to all java objects methods it is better to as a root classes from which all others extend as shown below:
						
						public Class Copyable {
						public Object copy() { .. }
						}
						
						public class InformationSource extends Copyable {..}
						public class Book extends InformationSource {..}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is an appropriate use of inheritance. Since each answer type is different the manner in which it is implemented is also different. It is therefore better to not give an implementation of the class Answer and allow for each subclass to provide for an implementation of its particular type of answer. Things common to all Answers such that the marksAvailable for it will be passed down to instances of Answer through the subclass hierarchy from the root class Answer
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is the process of information hiding, the implementation of an object is contained within the object itself and the interface to the object its presented to the &apos;outside&apos; world. An object external to any other given object can only see the interface to the object and has no idea whether information within the object is calculated or stored.
						
						A good example of encapsulation in action is a Visual Display Unit, all that is presented to the outside world is the screen, the process of getting information to display on the screen is hidden from the users.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						In runtime blocks of code are executed by the CPU on the computer. Runtime performance depends on a number of issues, primarily how fast a computer is able to execute a given body of code. If areas in the body of the code can be modularised, by encapsulation, then it becomes possible to make decisions on whether or not to execute a given module in the body of the code. By not executing those modules which do not need to be executed there is a decrease in runtime, thus increasing (improving) runtime performance.
						
						In java a good example of this is method, whereby a method is only executed if it is necessary.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						When it comes to manual storage management encapsulation is able to help by providing a way of efficiently organising data as it is stored. All data of a given type can be stored in one location and data of another type can be stored in another location thus making it possible to decipher exactly where one needs to go in order to access the data in question. This greatly improves the efficiency and effectiveness of data look up.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This refers to encapsulation producing modular entities from a singular entity. Once an entity is modularised such that each inidividual module is highly cohesive but losely coupled it is possible to get the individual modules to interact with each other in an efficient manner. In DbC a module presents information consisting with its postcondition after being given information consisting with its predicondition. It is this modular nature as of information checking &amp; transmitting that makes encapsulation necessary for DbC.
						
						E.g. a human as an encapsulation presents a calculator, an encapsulation, with a precondition that the human must provide it with numbers and operation on those numbers then the calculator will provide the human with a correct answer. The human meets the precondition of the calculator by entering the numbers to the calculator via its keypad, its interface. The calculator presents the correct answer to the human via its screen.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<compositea marksAwarded="4" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to provide for specification such that interaction between two different classes is made smooth and efficient so that it is clear cut what it is that each class can and cannot do. The introduction of contracts allows for a class to be called correct with respect to in the inputs the class will accept as valid inputs as agreed in its contract. Such contracts are defined in using assertions and predicates with the precondition followed by the assertion followed by the postcondition.
							
							{P} A {Q}, P is the postcondition, A is the assertion implemented if the precondition is meet, Q is the post condition - the results of the implementation will always meet the postcondition
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="0" isMarked="true">
						<answerString>
							SqRoot(long number, long precision) {
							
							if( number &gt; 0 ) //Answer is computre
							
							return Answer, answer returned is never less than 0
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						If the stack is not empty the program takes a number of the top of the stack and computes its square root and presents its answer. The program continues doing this until the stack is empty.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="37" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="50" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						A striker and defender is a type of footballer, however they can be seen as a role of a footballer and these can change over time. It would be best to delegate this roles e.g.
						
						public abstract class Position{..}
						
						public class Striker extends Position{....}
						
						public class Defender extends Position{...}
						
						public class Footballer{
						
						public Footballer (String name){..}
						private Position currentPosition;
						
						....
						}
						
						Making a class for each individual player would be costly. Using the Football class above you can get around this:
						
						Footballer wayneRooney = new Footballer (&quot;Wayne Rooney&quot;);
						wayneRooney.currentPosition = new Striker ();
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Inheriting ArrayList is a bad example of implementation inheritance. It provides the user of the TrafficQueue class the ArrayList interface thus allowing them to do illegal functions like add an element into the middle of the array. It also fixes the storage to being an ArrayList which does not allow it to be changed at runtime. A better option would be to delegate the implementation of List to the TrafficQueue class:
						
						public class TraffficQueue{
						private List queue;
						.....
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The use of multiple inheritance on the CameraPhone class is not desirable. Problems could occur with inheriting methods such as capacity from MobilePhone and DigitalCamera - MobilePhone capacity method could be the number of phone numbers the phone can store, and the DigitalCamera capacity could be the number of photos it can store. In my view a camera phone is firstly a phone that can have features added to - such as a digital camera, mp3 player. Using this as a guide i would suggest to have a mobile phone class that has-a list of features of type PersonalElecronicEquipmet:
						
						public class MobilePhone extends PersonalElectronicEquipment{
						
						List features = new List();
						
						public void addFeature(PersonalElectronicEquipment p){
						feaures.add(p);
						}
						
						....
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Inheriting from InformationSource is fine - a book is a type of information source. By contrast copyable fails the is test with book. By inheriting Cobyable you expose the interface to the clients of book. Best to make the book extend InformationSource and to add the copy method to the book class.
						
						public class Book extends InformationSource{
						
						public Object copy(){...}
						....
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a good use of inheritance. Instead of checking if each question has an answer provided or is not required by a series of null test it is replaced by an object that does nothing so therefore making the code more adaptable and reusable. It also makes the system more robust as it does away with the need for the client to check for null cases which it could forget to do.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of classes and or objects that can be customised to solve a general design problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Composite design pattern structures the objects of a system into a tree and allows the individual objects and compositions of object to be treated uniformly - they can accept the same calls. In this example there are a number of atomic questions that can be composited to form an composite question i.e. a question made of sub questions like question 3.
						
						There is question interface that allows its subclasses to share a common interface to understand the same calls, for example getting the number of marks the question is worth:
						
						public abstract class Question{
						
						public abstract long getMarks();
						}
						
						the classes AtomicQuestion and CompositeQuestion inherit from Question. CompositeQuestion delegates Question as it has a list of questions. Both of these classes implement the abstract methods defined in Question.
						
						public class AtomicQuestion extends Question{
						
						long marks;
						
						public long getMarks(){
						return marks;
						}
						}
						
						public class CompositeQuestion extends Question{
						
						private ArrayList questions;
						
						public long getMarks(){
						long marks = 0;
						for (int i = 0; i &lt; questions.size(); i++){
						marks+= ((Question)questions.get(i)).getMarks();
						}
						return marks
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						Use Singleton design pattern to allow only one instance of the exam to be given to each registered student taking the exam. If this wasn&apos;t done it could be possible for a student to optain multiple exams and lead to difficulties on which one to mark.
						
						Use Proxy design pattern to delegate communication between exam server and java applet on the local machine. The applet on the client machine could treat the examserver as a local object. The proxy object would have the same intreface as the server so the client can treat it as a local object, and the proxy object could also add some functionality to the exam server.
						
						Use the Stratergy design pattern to present the information to the maker in differnt ways. Each stratergy to present data would need to be encapsulated in its own class. Also each stratergy would have a common abstract superclass that would give every stratergy a matching interface. The client can easly switch between each stratergy easily depending on how the client wasnted to view the information.
						
						To invigilate the exam it would be best to use the Observer pattern. Parts of the system would need to be split into observables and observers. The observables are object that changes its state at a random time. The observers register with a number of the observables and are notified whenever the state changes. Examples of its use could be when the user clicks the start exam button (an observable) the exam server could set the time left counter. This is an adaptable pattern which makes it easy for the observer to register with new observables.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The relationship between a class and its client is a contract with each party having rights ans obligations. Contracts allow both the class library and its clients to develop trust and therefore have simpler processing. To define a contract the use of preconditions and postconditions are required. A precondition describes the constraints under which a method would function correctly and postconditoin describes the properties of the state resulting from a methods execution. The contract can be expressed by the library as:
							
							If you promise to call a method with its preconditions satisfied i will guarantee to return a state satisfying the called methods postconditions.
							
							The precondition binds the client of the library. Its an obligation for the cilent and benefits the supplier (the class library). The postcondition binds the supplier. It is an obligation for the supplier and a benefit for the client.
							
							With the introduction of contracts the class library can assume that every call to its methods have their preconditions satisfied so there is no need to test them - simplier processing. The client of the class can assume that the return state of a called method will satisfy the methods postconditions - again there is no need to test the result.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							To define the class SqRoot using DbC, the pre and post conditions on the method are required.
							
							class SqRoot
							Attribures: double answer
							Method: SquareRoot(x)     precondition:   x =&gt; 0
							postcondition:  answer * answer = x
							Invariant:
							
							The attribute answer is used as a test value in the postcodition.
							The precondition on the SquareRoot method is that the value passed to it is not a negative number as you can not find the square root of negative number.
							The postcondition is that the answer obtained when multiplied with itself will equal the parameter passed to the method.
							I have ignored the unit of precison on the answer.
							
							
							class Stack
							Attribures: int capacity
							int count
							Method: push(x)     precondition:   count &lt; capacity
							postcondition:  x on stack
							pop()        precondition: count &gt; 0
							postcondition: top element removed from stack
							Invariant: count &gt;= 0
							count &lt;= capacity
							
							The attribute capacity indicates the max number of number elements allowed on the stack.
							The attribute count indicated the current number of number elements in the stack
							
							The method push(x) has the precondition that the stack must not be full (you cannot add elements to a full stack). It has the postcondition of updating the stack with the value passed to method on the top of the stak
							
							The method pop has the preconditon that the stack is not empty (you can not remove elements from a stack that is empty). Its postcondition is that the stack is updated by removing the top object on the stack.
							
							The class invariant represents the global properties of the class, which must be maintained at stable time i.e when initially constructing class and before and after every method call. This assert that the number of number elements within the stack must never fall below 0 and must not exceed the stacks capacity.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Firstly numbers must be added to the stack. As the client is bound to the preconditions of the class there must be a check to see if the stack is not full. Add a method in the program for adding numbers to that stack:
						
						Stack stack = new Stack()
						
						private add (int x){
						assert (stack.count &lt; stack.capacity)
						stack.add(x)
						}
						
						Same can be done with pop but assert that (stack.count&gt;0)
						
						To go through stack and find square of numbers
						
						private findSqRoot{
						
						assert (that all value in stack are positive)
						cycle througth displaying all th
						
						
						
						As the preconditions are an obligation to the user of the class it is required that a check is made before the call is made to each The user can assume that the answer it obtains is correct and does not need to check for this.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="38" examId="CS310105" timeTaken="5904" isSubmission="true" allImages="true">
		<compositea marksAwarded="40" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a bad use of inheritance.
						
						A footballer can have many positions over the course of his career and still remain a footballer.
						Striker and Defender are roles played by a footballer. Wayne Rooney is just the name of a footballer. They shouldn&apos;t be subclasses of footballer.
						
						public abstract class Role {..}
						
						public class Striker extends Role {..}
						
						public class Defender extends Role {..}
						
						public class Footballer
						{
						Role currentRole;
						String name;
						
						
						public Footballer(Role position, String footBallersName,....)
						{
						currentRole = position;
						name = footBallersName;
						}
						public void setRole( Role newRole)
						{
						currentRole = newRole;
						}
						
						public Role getRole()
						{
						return currentRole;
						}
						
						public void setName( String newName )
						{
						name = newName;
						}
						
						public String getName()
						{
						return name;
						}
						
						//Other &apos;important&apos; information about footballers...
						}
						
						The reason that the name should be changable is because a person can change their name either by deed poll or by marraige and footballers can be women.
						
						So to instantiate the Wayne Rooney you would use:
						
						Footballer wayneRooney = new Footballer(new Striker(..), &apos;Wayne Rooney&apos;);
						
						Just because Wayne is a good footballer doesn&apos;t mean that he needs a class of his own.
						
						NB Apologies if Wayne is not a striker, I don&apos;t follow football...
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a bad use of inheritance.
						
						There are lots of methods in ArrayList that are probably unwanted in the TrafficQueue class. Generally speaking there&apos;s a specific object required for the Traffic Queue where as ArrayList can have a multitude of different objects.
						
						Therefore all you need is an internal variable which you access using the methods of ArrayList that you want.
						
						public class TrafficQueue
						{
						ArrayList queueList = new ArrayList(..)
						
						//implementation of the get sets and other fun things using your specific traffic class here!
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						While this is a plausable use of inheritance, multiple inheritance is generally a bad idea because you can get conflicts within the two classes when it comes to which methods are overwritten.
						
						This is also not legal java code so implementing this in Java would be impossible...
						
						Plus camera phones can have other cool add ons like calanders, java games, video playback and such, a camera phone is just another accessory.
						
						public abstract class PhonePlugin{..}
						
						public class CameraForMobile extends PhonePlugin{..}
						
						public class CameraPhone extends MobilePhone
						{
						PhonePlugin[] plugins;
						
						//implementation of all the various plug ins.
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is a bad use of inheritance.
						
						If you have an electronic book then there are certain ways to copy that have to be accounted for with respect to copyright. Inheriting a Copyable class might allow ways to copy that are not allowed for the medium. For instance, with Amazon.com you can have sneak peeks at parts of books, but some of the illustrations are not fully shown because of copyright issues. A hapless programmer could copy these images in the blind copy without realising.
						
						public class Book extends InformationSource
						{
						public Page[] copy()
						{
						//return non copyrighted pages
						}
						
						public Page[] copyCopyRightCleared()
						{
						//return book because it&apos;s for educational purposes or rights are bought
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a GOOD use of inheritance.
						
						The only other solution would be to parameterise every method but that would be messy and rather a stupid thing to do.
						
						public class Answer
						{
						public Answer(int answerType,....)
						{
						type = answerType;
						// other answer stuff
						}
						
						public String[] getAnswers()
						{
						switch(type)
						{
						//cases here such as MCQAnswer
						}
						}
						
						This switch statement would have to be repeated for every method so would be a BAD substitute...
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a means of showing the communication between objects and components in general ways that can then be tailored for specific tasks
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Composite design could be used in the construction of the questions themselves. Because a question is generally made up of smaller questions or even different types of questions then it would be sensible to collate them into one class for ease of marking
						
						Question - abstract class
						
						A type of question - class
						
						Composite question - a class that uses a list of questions so it can encorporate all different types of questions into one class for one question.
						
						public abstract Question
						{
						public abstract Question getQuestion();
						}
						
						public class MultipleChoiceQuestion extends Question{..}
						
						public class AtomicQuestion extends Question{..}
						
						public class CompositeQuestion extends Question
						{
						Question[] questions;
						
						public Question getQuestion()
						{
						//concatenate questions using the get question method from the other questions
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						Proxy design pattern can be used for the networking side of the exam. This would allow different computers to talk to the central server without having to worry about conflicts in the hardware or system being an issue.
						
						Singleton could be used for the final exam answers because there are only one set of answers per candidate so only one instance of their answers needs to be had. This is very important for security because there must not be multiple copies of answers by the candidates on the same system.
						
						Strategy method could be used for the various strategies employed to present the information to the user. As better strategies are developed, existing strategies can be changed without effecting the overall interface.
						
						Factory method can be used to split up the types of exam. One geography test is much like another so if they agree on a world standard, then a geography test can be shown in the applet, however if someone is taking a science test then the style will be different and so a different set of rules apply. Once the exam styles are set, they are rarely changed but if they are then the factory just has to be updated.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							The purpose for using contracts is so that information that have to lie within certain parameters is kept within these parameters. If the variables went outside the parameters then it could produce very nasty results, in the best case it could result in an error in calculation, in the worst case, human lives could be lost.
							
							For each method I would define a set of pre conditions and post conditions and then for the class I would use invariants.
							
							Pre conditions are conditions that have to be met before the method can be executed. For example x &gt;= 10;
							
							Post conditions are conditions that have to be met after the method has been executed. For example result != null.
							
							Invariants are conditions that have to be true at every observable state. These are the states inbetween method calls. For example in an insert algorithm low always has to be below high but while sorting, this condition can not be met. However as long as when the method has finished manipulating these figures, the low is lower than the high, there&apos;s no effect to the other methods and therefore the invariant is held.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							Preconditions for SqrRoot: assuming that this doesn&apos;t take complex numbers into account and deals purely in normal numbers rather than having an i component, the number that goes in has to be greater than or equal to zero. I&apos;m not 100% sure that you can square root zero but if you can&apos;t then it&apos;s just a matter of removing an equals sign.
							
							The postconditions for SqrRoot is that a valid result is returned. If not then an exception should be thrown so that the program that is using this class doesn&apos;t deal with invalid data.
							
							public class SqrRoot
							{
							public static float getSqrRoot (int numberToSqrRoot)
							{
							//pre-conditions: number has to be greater than or equal to 0
							if (numberToSqrRoot &gt;=0)//Check to see preconditions are met could also use assert but it&apos;s unreliable.
							{
							return(Math.sqrRoot(numberToSqrRoot)); //Can&apos;t remember the exact method call
							}
							else
							{
							//Throw an Exception here to put the responsibility of finding a safe alternative in the user class
							}
							
							}
							}
							
							
							The preconditions of the pop is that the Stack can&apos;t be empty. Otherwise there is nothing to return.
							
							The postconditions of the pop is that the number of objects should not be negative.
							
							The preconditions of the push is that the Stack can&apos;t be full. Otherwise there is an overflow error/
							
							The postconditions of the push is that the number of objects should not be greater than the stack capacity.
							
							The invariant is that the number of objects can&apos;t be negative and greater than the stack capacity.
							
							public class Stack
							{
							List stack = new List();
							int numberOfObjects;
							
							public Object pop()
							{
							//preconditions Stack is not empty
							if(numberOfObjects &gt; 0)
							{
							numberOfObjects--;
							return stack(numberOfObjects);
							}
							else
							{
							return null; // object cannot be returned.
							//Could throw underfull exception here.
							}
							}
							
							public void push(Object newObject)
							{
							//preconditions Stack is not full
							if(numberOfObjects &lt; stack.length)
							{
							stack[numberOfObjects] = newObject;
							}
							else
							{
							//Throw overflow exception
							}
							}
							
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Benefits of using this is that all the pre-conditions and post-conditions for the stack and the sqrroot are already sorted so all you have to worry about are the conditions for the sqrrootstack. By using exception handling you can define what&apos;s going wrong when and you can reuse your stack and sqrroot classes for different tasks afterwards
						
						public class SqrRootStack
						{
						public static Stack getSqrRootStack(Stack sourceStack)
						{
						Stack stack = new Stack(sourceStack.length)
						try
						{
						for (int i = 0; i &lt; stack.length; i++)
						{
						stack.push(SqrRoot.getSqrRoot(sourceStack.pop))
						}
						return stack;
						}
						catch negative number Exception
						{
						//meaningful message about the sqr root of negative numbers
						}
						catch overflowException
						{
						//details about where the overflow occured
						}
						catch underFlowException
						{
						// details about where the underflow occured
						}
						finally
						{
						//What to do in event of a failure
						}
						}
						
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="39" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="33" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This class structure would not be very useful if a footballer&apos;s role were to change, which is a likely occurrence in the real world.  To solve this problem, the classes Striker and Defender should be delegated to by the individual player classes, for example:
						
						public abstract class FootballerRole { ... }
						public class Striker extends FootballerRole { … }
						public class Defender extends FootballerRole { .. }
						
						public class Footballer { private FootballerRole currentRole; ... }
						public class WayneRooney extends Footballer { ... }
						
						It could also be argued that WayneRooney should delegate functionality to Footballer, since he could potentially have several other roles in life.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Although this approach will probably work, it forces the use of ArrayList as the data structure for storing the traffic queue.  A more sensible approach would be to make the class TrafficQueue extend Java&apos;s List interface, which is abstract. This way, TrafficQueue would be dynamically bound at runtime instead of being compiled as a static type.
						
						pubilc class TrafficQueue implements List { ... }
						
						Any method defined in the List interface can now be called on instances of TrafficQueue (obviously assuming that the methods have been inplemented in TrafficQueue and that the code compiles).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This class hierarchy uses multiple inheritance and is rather untidy.  It implies that a CameraPhone is both a MobilePhone and a DigitalCamera, but it is probably just a MobilePhone that happens to have the facility of a digital camera.  A more appropriate structure would therefore be:
						
						public abstract class PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment {
						private DigitalCamera theCamera;
						// other variables and methods for mobile phone
						... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						A default implementation of copy() in the Copyable class means that the Book class does not have to implement its own version of the method unless it needs to do anything extra.  However, if this method is redeclared (overridden) in the Book class, it will not necessarily do everything the version in Copyable did.  A possible solution would be to make both the Copyable class and its copy() method abstract, and make Book implement Copyable.  This would force Book to have its own implementation of copy(), specific to a book.
						
						public abstract class Copyable {
						public abstract Object copy();
						
						The fact that copy() returns an Object means that a cast is required to restore the original object type.  This could be error prone.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Since the classes NoAnswerProvided and NoAnswerRequired are likely to be empty, they are probably not necessary.  An appropriate alternative would be to add the following member variables to the Answer class:
						private boolean answerProvided;
						private boolean answerRequired;
						
						This parameterises the classes NoAnswerProvided and NoAnswerRequired.  Then &quot;get&quot; methods could be added to the Answer class for the new members:
						public boolean getAnswerProvided();
						public boolean getAnswerRequired();
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation allows developers to &quot;hide&quot; data and methods that do not need to be seen by the user of the class.  For abstraction to work, it must be possible to select an appropriate type for an abstract class at runtime.  This requires that the dynamic type of an object be a subtype of the abstract type, which can only realistically be achieved by encapsulating the data and operations used by the object, and using inheritance.  Example:
						
						public abstract class FarmMachine { ... }
						public class CombineHarvester implements FarmMachine { ... }
						
						Implementing the above data structure without encapsulation would be very difficult because the data and operations would not be collected together cohesively.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation can improve garbage collection because it helps to identify when data is needed, and when it can be deleted to free up memory.  Encapsulation can also reduce the need to have multiple copies of the same object, by allowing several references to one object.  Example:
						
						public class Chair { ... }
						public class Room {
						private Chair[] theChairs;
						private Room {
						Chair chair = new Chair();
						for (int i = 0; i &lt; 40; i++) { theChairs[i] = chair; }
						public Chair getChair(int n) { if (n &lt; theChairs.length) return theChairs[n]; // else do something else }
						}
						
						Encapsulation ensures that all the data needed for an object to function as a single entity is included in the object.  This reduces the need to retrieve data from external sources, which can be detrimental to application performance.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Manual storage management is often difficult to accomplish successfully because each item of data may be used by many different parts of a program&apos;s code.  Encapsulation can be very helpful in identifying what particular class (or classes) an item of data belongs to, and therefore when it is safe (or not safe) to delete that data from storage.  Encapsulation also helps to prevent wasted space by allowing data to be stored only if, and when, it is needed.  In the following example, the private data members are no longer needed (and can be deleted) when the instance of the class has been deleted:
						
						public class MyClass {
						private int myInt, myInt2;
						... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by Contract does not strictly require encapsulation, but encapsulation can make DbC much easier.  Any method/function can have pre-conditions and post-conditions that must be satisfied before and after its execution, but invariants are usually difficult to implement without encapsulation because there is usually no way to preven t data being modified when it shouldn&apos;t be.
						
						Class invariants can easily be implemented in classes through the use of (usually private) instance variables, whose values are changed only by the containing class and can be checked using a method call..  Example:
						
						public class Engine {
						private int minTemperature, maxTemperature;
						public boolean validTempRange() { return minTemperature &lt; maxTemperature; }
						... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern of comunicating classes and/or objects that can be customised to solve a general design problem in a specific context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Using the Composite design pattern, an abstract class (e.g. ExamQuestion) could be created to represent a question and several subclasses of this could be created to represent the different types of question.  Each question class  could implement its own data structure and methods and inherit the generic features of an exam question, such as variables for the number of marks available or the number of parts in the question.
						
						Each question class could contain a method that calculates and returns the number of marks scored, or returns a special value if the marking required assistance from a human (e.g. for a written answer as opposed to a multiple choice answer).  The algorithms used to present the data to the marker could be encapsulated in their own class hierarchy (e.g. an abstract interface PresentationAlgorithm, with several subclasses).  A PresentationAlgorithm could be stored with each question so that the central server can determine which algorithm to use.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						Factory Method:
						Exam questions, which are likely to be the same in most cases, could be supplied by a factory class (e.g. ExamFactory) on the central server when requested by the Java applet.  This would allow an exam composed of an arbitrary set of question types to be provided (assuming that the question types have already been implemented).
						
						Singleton:
						Have only one instance of any question string in existence at once on the server.  This could be achieved using a static class with a private class variable that is instantiated by the constructor of the class.  Example:
						public abstract class ExamQuestion { ... }
						public static class WrittenQuestion implements ExamQuestion {
						private WrittenQuestion theQuestion = null;
						private String theText;
						private WrittenQuestion(String text) {
						theTest = new String(text); }
						public String getQuestion() {
						if (theQuestion == null) theQuestion = new WrittenQuestion(text);
						return theQuestion; }
						}
						}
						
						Visitor:
						The algorithms for presenting the information to the marker could be implemented on the central server instead of within each ExamQuestion instance.  The server could then &quot;visit&quot; each of the exam participants, gather all the data from their answers and use this data in the locally stored algorithms.  The Java applet on each client&apos;s machine would have a method accept() (or something similar) implemented, which would be called by the central server on each &quot;visit&quot;.  If the server&apos;s request is relevant to the client, it can respond with the requested data or information.
						
						Object Pool:
						The number of ExamQuestion objects could be limited to the number of questions in the exam.  This would be aciheved by storing the number of instances of ExamQuestion that have been created.  Once this reaches the defined limit, no more instances can be created.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="40" examId="CS310105" timeTaken="5827" isSubmission="true" allImages="true">
		<compositea marksAwarded="17" isMarked="true">
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a sensible use of inheritance as far as Striker and Defender are concerned as they pass the is-a test.  However the WayneRooney class is not necessary as Striker is a role played by Wayne Rooney (and he is certainly not in a class of his own).
						
						In this case, we would make a class Striker called WayneRooney
						e.g. Striker wayneRooney = new Striker();
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						If I am correct in assuming that an ArrayList, once it is declared, it is very difficult to dynamically change the size of it then this is not a particularly useful inheritance, particularly when there are alternative options e.g. in Java a Vector.  This is due to the fact that a traffic queue is unlikely to be the same length each time one occurs.
						However, the above does maintain the idea that a traffic queue is made up ordered compnents (in the sense of joining, as we can append elements).
						
						I would suggest
						
						public class TrafficQueue extends Vector { ... }
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I am not so sure this is the best use of inheritance and this wouldn&apos;t be allowed in Java.  A digital camera is a device which is soley used for taking pictures and has a considerable amount of features whereas cameras on mobile phones are comparatively simple (just point and click).  I think it would be better to have CameraPhone to extend only MobilePhone and maybe make it contain similar features as a DigitalCamera object, or just simply have MobilePhone and say that it contains a DigitalCamera as one of its list of features, with some of its parameters nullified.
						
						e.g.
						public class CameraPhone extends MobilePhone { ... }
						{
						int zoomFactor, MAX_PIC_SIZE, ....
						}
						
						or
						
						public class MobilePhone extends ElectronicEquipment
						{
						public MobilePhone()
						{
						boolean cameraPhone = isACameraPhone();
						if(cameraPhone == true) DigitalCamera digitalCamera = new DigitalCamera();
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I&apos;m not sure this is correct.  A Book is not a type of copyable object - it may be copyable but we never say that a Book is a kind of Copyable.  I think in this case, if we just say:
						
						public class Book extends InformationSource { ... }
						
						then edit the Copyable copy() method to copy(Object obj) and then in another class declare both Book and Copyable we can still use the copy method by passing the Book as the object to be copied.
						
						i.e. public class Copyable
						{
						public Object copy(Object obj) { ... }
						}
						
						public class SomeOtherClass
						{
						Copyable copyable = new Copyable();
						Book book = new Book();
						Book copiedBook = copyable.copy(book);
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I do not think we need an NoAnswerProvided class as that is not a type of question - we just have MCQ or text type questions that do not contain an indication of what the answer is (e.g. int and String respectively) or have null as their value.  As for NoAnswerRequired I would consider that to be a type of question rather than a type of Answer as there is no need to find out what the user has entered if the system does not require them to answer it in the first place!  If we need to get an answer as a result of a generic getAnswers() method we can always return null instead.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a description of a solution to a certain situation that can be applied several times to other similar implementations.  It is designed to be reused and interoperable as it based on the experience of people who have come across a similar situation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The Composite design pattern is used in many situations that require an action on several similar object and it applies in this case as their are individual characters or words that would repeatedly come up in answers to similar questions.  It works on the idea of recognizing multiple repetitions of some object.
						In this case it could be used to analayse all the answers to a particular question and filter the words used, in particular keywords that are expected to appear. For example in an exam about Trees we may expect to see words such as &quot;Confierous&quot;, &quot;Deciduous&quot;, &quot;Mudslides&quot;, &quot;Oxygen&quot; etc and using this system we can possibly highlight the words themselves or the sentences containing them.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Flyweight - for essay like questions it may be better to store the positions of letters rather than storing every letter as it occurs.
						Structural - an exam can be structured like a tree for example from Paper -&gt; Section -&gt; Question -&gt; Sub-question etc.
						??? - when a generic method can be used for all sorts of questions e.g. getMarksAllocated()
						???- a design pattern that deals with interactions with storage facilities such as databases and servers
						
						(??? indicates I cannot remember the name)
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="7" isMarked="true">
				<compositea marksAwarded="4" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Design by contract is the principle that implies that a certain operation cannot take place unless it is in a state that satisfies its pre-condition and it guarantees that it will terminate in a state satisfying its post-condition.  In this library my pre-condition would be that if one class requires another then the calling class should not be null and also be able to accept the class in the first case.  Its post-condition would be that a class provides all the necessary funcionality that is required of that class without any problems.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Correctness rule:
							{P} A {Q}
							where {P} = pre-condition, A = action, {Q} = post-condition
							
							For the SqRoot class, square root method sqRt(x):
							{P} = x &gt; 0  &lt;-- We cannot square root zero or a negative number.
							A = works out the square root
							{Q} = (result of sqRt) &gt; 0  &lt;-- a result of a square root cannot be less than or equal to zero
							
							For the Stack class,
							{P} = at least one number  &lt;-- we must have at least one number in order to validate the existance of a stack
							A = store the numbers from {P}
							{Q} = a stack of numbers, as defined in {P}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The contract for this program would be that the pre-condition should indicate that we must supply a stack of numbers that contains at least one number i.e. n &gt; 0 where n is the number of numbers, the action should be the working out of each of those numbers and the post-condition should a stack of n length containing the square root values of the original pre-condition values.
						
						In essence the program would contain a method that accepted a stack of numbers as an argument and returned a stack.  By using separate classes for both the SqRoot and Stack we can repeatedly use the same simple code required for working evaluating a single number in order to work out an entire stack of numbers.
						
						e.g.
						public Stack squareRootStack(Stack initialValues)
						{
						Stack resultingValues = new Stack(initialValues.length());
						for(int i = 0; i &lt; initialValues.length(); i++)
						{
						resultingValues[i] = SqRoot.sqRt(initialValues[i])
						}
						return resultingValues;
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="41" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="55" isMarked="true">
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a bad use of inheritance as what is being expressed here are roles played by a footballer. Although the is-a test passes as a defender is a footballer and Wayne Rooney is a Striker, Wayne Rooney is in fact an instance of a striker. Since roles can change over time, there should be a concrete Footballer class of which Wayne Rooney is an instance and then this class should delegate to the position being played at the time. This would allow the position to be changed at runtime - say if they were told to play in a different position, and this means the class Position gives the extra functions that the classes extending Footballer did above. Having an individual class for each footballer is stupid because they will all have the same functionality of say Strikers, so there should not be a new class for each because the classes are doing no more than their super class.
						
						public class Footballer{
						private Position position;
						Footballer (Position p)
						{ this.position = p;} }
						
						Footballer wayneRooney = new Footballer(striker);
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a bad use of inheritance because a TrafficQueue is NOT an ArrayList (fails is-a test)- it HAS an ArrayList to store the traffic (say Vehicle objects). By using ArrayList as a super class, the whole interface of ArrayList is visible in TrafficQueue (implementation inheritance occurs) and so encapsulation is lost because the client of this class should not be able to see the original put() and get() methods that are in the ArrayList class. The TrafficQueue class should delegate to ArrayList and keep an instance variable of an ArrayList to store the traffic. This also means that by only showing the interface that we want to show with TrafficQueue, we are not tied to using an ArrayList as above (where the inheritance is bound at compile time). This means we could swap different collections to be used as and when are appropriate. We should also specify the interface such as List (or even Collection) rather than specifically declare ArrayList as the instance variable.
						
						public class TrafficQueue{
						List traffic;}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The is-a test passes here because a CameraPhone is a MobilePhone and it is a DigitalCamera. However, this is a bad use of inheritance that can cause many problems. CameraPhone here inherits from PersonalElectronicEquipment twice - this will almost certainly cause bugs! It may also inherit the same features twice (such as a method in both DigitalCamera and MobilePhone that has the same name e.g. switchOn())- this causes naming problems where one or both would need to be renamed due to the clash. The real reason for not using multiple inhertiance here is that MobilePhone and DigitalCamera are not disjoint enitities and this is the source of many of the problems associated with inheriting in this manner. Alternatively, we could make CameraPhone extend MobilePhone, then delegate to DigitalCamera by storing an instance variable of it so that we may use its extra functionality. (This could easily be changed to delegate to both of the super classes - and therfore define our own interface from scratch rather than be forced to use all of MobilePhones. It depends whether we will need to put CameraPhones in collections of PersonalElectronicEquipment objects!) It is not a good idea to model an exceptional case such as this with inheritance.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						One of the main uses for mulitple inheritance is the need to &quot;mix&quot; the actual properties of 2 classes. Although a book is-a information source, it is not really a copyable, it just merely has the properties that it CAN be copied (interface inheritance rather than implementaion inheritance as above). This is a bad use of inheritance, as Copyable needs to be either an abstract class or an Interface. In this case, the Book class will need to redeclare the copy() method so that it does not perform a shallow copy as that is not the purpose, and many mistakes could occur doing this. Default method implementations are a bad idea! Say for instance that in Book the overridden version was coded as Copy(), the original copy in the super class would not be overridden and so if the user called copy(), the shallow copy in the super class is called - a bug! I would personally make sure that the copy() method is declared abstract and so any mistake in the name spelling of the copy() method in the classes that use the Interface or (now abstract Copyable) class will return a compile error that can be seen and corrected.
						
						public class Book extends InformationSource implements Copyable {...}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In all cases above the is-a test passes as all the concrete cases are actually answers. This is an elegant and efficient solution for this purpose because presumably in an exam, we will have questions that contain composite answers and so with the common Answer interface, we can treat all of the Answer objects uniformly (composite design pattern). This means that we can have a collection of Answer objects and implement the same methods on each that have been defined by the common Answer class interface and not worry what sort of Answer we are actually dealing with - the correct implementation of the methods will be resolved through dynamic binding so there are no messy IF statements that can be fiddly! This makes it very easy to add new code for a new type of Answer by just creating another sub-class of Answer - with no need to change any of the other code!
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communicating classes and/or objects that can be customised to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The composite design pattern is based on the ease of being able to uniformly communicate with sets of similar objects in the system. An example is where we will have questions of different kinds (such as multiple choice or text box etc.) and also composite questions that contain a list of these questions of differing types. The whole exam for example is just a collection of the questions contained within it. By using composite, we define a common interface that we wish to be the same for every question in the form of an abstract Question class. All types of questions such as multiple choice then extend this Question class and implement the methods defined such as getNoOfMarks() or similar useful information. This means then that we can send the same message to any kind of question and they will all understand it and return the correct result. The result of this is that we can have a collection of Question objects in our Exam class and to calculate the total marks on the paper, we could merely sum the result of calling getNoOfMarks() on each member of the collection without worrying whether it is a text question or a multiple choice question. The correct implementation of the method will be resolved by dynamic binding - no messy IF statements that can be fiddly! We can then add new Question sub-classes for new types of question without affecting or changing the existing code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						The Remote Proxy design pattern could be used where any communication by a class over the Internet (or whatever link is being used) is managed through a proxy object that contains some/all of the interface of the server class to be communicated with. This means that objects in the exam system can communicate with other classes around the world (such as sending answers to a server) by merely using the server interface and not worrying about the actual communication of the data over a link. The proxy objects would take the call to send data then transparently to the calling object set up the connection (possibly encode or encrypt) and transmit the data to another proxy that would then send the message to the correct object.
						
						The Visitor design pattern could be used because obviously an algorithm such as collecting the total marks from such a large system with all kinds of question and exam objects would be very complex and would strongly interact with those objects. We could code all of the objects in the system to define an acceptVisitor method that merely calls the relevant method in a visiting object according to what object it is. A visitor can then define visit() methods for each possible object to be visited and encapsulate the algorithm that would usually be spread across many classes into a single class. For each added function required over the whole system, only a new visitor needs to be written. The objects visited must however show enough of their representation for the visitors to be able to work so there is a possible loss of encapsulation.
						
						The Singleton pattern could be used to ensure that only a single central server object is created, as having more than one &quot;central server&quot; would be a strange idea! In this case, we make the CentralServer class have a private constructor and a method such as getCentralServer() that returns a pointer to the central server. The getCentralServer() method when called will create a CentralServer object if one does not exist and return a pointer to that, otherwise it will return a pointer to the existing one. The method should also be declared synchronized to stop concurrency bugs. By doing this, we ensure that the CentralServer is only created when needed (its probably quite a big object), only one can exist and no classes may inherit from CentralServer.
						
						We can use the Factory Method design pattern to defer the object creation to the sub-classes of the questions and therfore to the specific questions to be asked. This means that we define a common interface for the Question composition and then instead of specifying the particular types of questions that must be instantiated, we can leave them specified only as Question objects and then only the correct types of questions are instantiated at run-time by the relevant sub-classes depending on what sort of question is to be asked. This could be used specifically for example in an exam that maybe is randomly generated by random selection from a question bank and so we do not know which questions will be on the exam until we execute the initialisation.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of using contracts is to create a level of trust in the system and enable us to sometimes prove code correct by verifying that it meets the specification. This allows code to be reusable and extensible. We must define a succinct and precise description of the behaviour of modules of our code (usually classes and methods in this case). A contract is usually defined a specification in the form {p} M {q} where {p} and {q} are logical predicates (assertions) for the pre- and post-conditions respectively. The pre-condition of a method defines the constraints under which the method will execute correctly and applies to all calls of the method from inside the class and also any clients. A correct method will never execute if the pre-condition of the method is not satisfied upon the call. The post-condition defines the conditions of the state that will result from the methods execution when called with the pre-conditions met. The pre-condition is an obligation for the client and a benefit for the supplier and the post-condition is an obligation for the supplier and a benfit for the client. The supplier basically says, &quot;if you call this method with the pre-condition met, I guarantee that it will execute and finish in a state where the post-condition is met&quot;. These assumptions allow code to be developed in modules (separately) by the assumption that if a methods pre-conditions are met when some piece of code calls it, then its behaviour will correspond to the post-condition. Class invariants may also be defined that are global properties of a class that must be preserved by every method (an assertion in the class definition) - these must be maintained at all stable states of a class - before and after any method call.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							In the SqRoot class, there is only a single method and no class invariant as far as I am aware because the class appears to be static. The method to find the square root must only accept non-negative numbers as otherwise the square root cannot be found (without complex numbers).
							
							static public float squareRoot(float x) {while(precisionNotReached){...}... return y;}
							The method could check if the number is 0 and return zero if it is, otherwise multiply 1x1 and 2x2 and so on until it find the interval, then begin doing the same for the interval(s) until the required precision is found.
							
							For squareRoot(x) method that takes number x as an argument and returns it square root y:
							{P}: x&gt;=0
							{Q}: y*y&lt;=x
							
							For the stack class, the methods that I would make available would be push(x) (add number x to the top of the stack) and pop() (remove the top number from the stack and return it). Using DbC, I need to define the pre- ({P}) and post-conditions ({Q}) of these methods and also the class invariant of the stack class. The class invariant in a stack that should always hold before and after every method call is:
							
							(count is number of items on stack, capacity is maximum number of items that can be stored on the stack and STACKEMPTY is a boolean value that indicates if there are any items on the stack.
							
							INVARIANT: count&gt;=0 AND count&lt;=capacity AND STACKEMPTY=(count==0)
							
							For the push() method, the stack must not be full beforehand and afterward the stack cannot be empty
							{P}: count&lt;capacity
							{Q}: count&gt;0 AND STACKEMPTY==false
							
							For the pop() method, there must be something on the stack to remove and also something must be removed
							{P}: count&gt;0 AND STACKEMPTY==FALSE
							{Q}: count&lt;capacity
							
							The capacity would be an instance variable stored in the Stack instance which could probably be sent as a parameter to the constructor for the array to be created at that size.
							
							pop() { count--; return get(count+1); }
							push() { count++; put(x,count); }
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						All I would do is create an array the same size as the capacity of the stack, then call the squareRoot() method on the pop() from the stack until the stack is empty, storing the numbers in my array as I go along so that eventually my array is filled with the square roots of the numbers originally in the stack. Something like array[i] = squareRoot(stack.pop()).
						
						By doing this, I can prove that my code will execute correctly so long as the SqRoot and Stack classes have been implemented without any bugs. This means that instead of rewriting my code for the Stack and SqRoot classes, it can be reused.
						
						For method that cycles through the stack and square roots the numbers and puts them in an array,
						{P}: STACKEMPTY==false AND count&gt;0
						{Q}: STACKEMPTY==true AND count==0 AND for every element in array at index [i-1], it is the square root of some number taken from the stack at the ith iteration
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="42" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="45" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The instances of the  two classes Striker and Defender are actually simply different kinds of Footballer instances. We can seperate the Striker and Defender by parameterisation. First make the Footballer class concrete and the constructor for the Footballer will have one parameter passed in indicating main job of the footballer.
						WayneRooney is an instance of the Footballer as a Striker. Only have to pass the main job striker to the constructor.
						
						alternative:
						public class Footballer{ public Footballer(String mainJob); .....}
						public class SomeClass{...
						WayneyRooney wr = new Footballer(&quot;Striker&quot;); .....}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a use of Implementation Inheritance. The TrafficQueue will inherit the functionalities of ArrayList for its convenience.
						However, problem is: 1. TrafficQueue extends the ArrayList with all ArrayList&apos;s public method inherited. The client of Traffic may access to the TrafficQueue via the methods defined in the ArrayList, which is not what is expected to happen.
						2.The elements stored in the TrafficdQueue is similar to those stored in the ArrayList, when retrieving the elements out, type casting has to be used, which is not preferred w.r.t the dynamic bynding.
						3.When the TrafficQueue extends, the functionalities inhereted from ArrayList may be very little use.
						Alternative. Delegate the TrafficQueue to List(ArrayList)
						public class TrafficdQueue{private List; ....}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						MobilePhone and DigitalCamera are sub classes of PersonalElectronicEquipment. It is ok for me. All subclasses passed the is-a test.
						The CameraPhone(CP) inherites from both MobilPhone(MP) and DigitalCamera(DC) may be a little doggy.
						CP will have both the variables and methods from MP and DC, it caused problems like name clashes, worse performance, etc.
						
						Alternative: delegate CameraPhone to  MP and DC
						public class CameraPhone extends PersonalElectronicEquipment{
						private MobilePhone;private DigitalCamera;....}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Obviously, Copyable will be better used as an interface (as its name indicated) than a conctete class. Book extending the Copyable will have very little functionalities inherited from Copyable.
						It is ok for the inheritance on InformationSource.
						Also, the copy() in the Copyable is nothing but the default java clone() method. it is not much use to inherite.
						alternative:
						public interface Copyable{public Object copy();}
						public class Book extends InformationSource implements Copyable{
						...public Object copy();}
						copy() can be specific to the Book. i.e. reference copy may be considered.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						1. The two classes of on answers can are not necessary here. We can have an boolean variable in the Answer class to indicate if the Answer instances shoulb be answered or not required at all. Also, another boolean variable can be used to indicate if the answer is answered or not. Subclasses of Answer will inherite these two variables.
						2.MCQAnswer and the TextAnswer pass the is-a test to inherite from Answer, seems ok here.
						alternatives:
						public abstract class Answer{pubic boolean isRequired,isAnswered;...}
						public class MCQAnswer extends Answer{...}
						public class TextAnswer extends Answer{...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design Pattern is the pattern of communicating classes and/or objects which can be customised to solve a design problem in a particular context. Design Pattern is a customarizale and reusable design.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The composite design pattern is used with inheritance and delegation working together. For the questions, we can have one abstract class Question that define the general structure and functionalities of the question. We can have subclasses AtomicQues(a single question) and CompositeQues(more than one question). Suppose there is one method in Question called: calculateMark(), both of the subclasses will have its own implementation of the method and we can delegate CompositeQues to AtomicQues to achieve composite.
						Code explainatation:
						public abstract class Answer{...
						protected int mark;
						abstract public int claculateMark();}
						public class AtomicQues extends Answer{...public int claculateMark{return mark;}}
						public class CompositeQues extends AnswerExams will involve structured questions involving various types of answers, some of which will be marked in a Human-Computer Collaborative manner where the software employs various strategies to present the information efficiently to the marker and enhance consistency.
						{ private List;
						public CompositeQues(){List= new ArrayList(); // for future extension....}
						public int calculateMark{ for(int i = 0; i &lt; list.length();i++) mark+=(Answer)list[i].calculateMark();//dynamic bynding}
						.....
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						1.Proxy pattern. Remote proxy pattern can be used here. Because the exam will be held in the web services sence. The user of the system is actually talking with the proxy server. the remote usrs can use the proxy to get the actual exam questions rather than contact directly to the central server. The end point performance and speed of the data transmittiong will be greatly improved. Also the networking traffic will be reduced.
						2.Observer Pattern. The exam system will no doube involve GUI component like buttons,text field,etc. The use of Observer Pattern is essential in GUI system. The system can interact accordingly to the user&apos;s action. Observer Pattern can also be used for the security part of the system as it may monitors the illegal accesses to the central server.
						3.Factory method pattern. for two reasons we may want to keep the database connection objects within a limited range.1) database connction is expensive and we can not have all the system memory dealing with the database connection objects.2) for each particular exam, there can only be a fixed number of people participating.(in some situation different, not general case),so there is no need for extra connections created. We therefore can make sure the connections are limited to a particular number with Factory Pattern.
						4.Stragety Pattern. For the marking part. we can have a abstract general marking method and then many different concrete marking methods for,say, each kind of questions.for example, MultipleAnswerQuestions may by marked by the computer, text based questions may be marked by the employees with the answer text displayed on the screen or printed on the pater. so different strategy applies to different question type to enhance consistency.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design by contract views the relationship between classes and its client as a formal aggrement,or contract. It binds the rights and obligation to each party of the relationship. DbC involves pre-,post-condition and class invarients. Pre-condition binds constraint to the client and benefits the code provider and post-condition binds constraint to the code provider and benefits the client. invarients are those properties that will be preserved by the methods.
							The classes in my library will be developped under the rules for DbC. It will bind the constraints to the library users how to use the library and the classes within the library will be guarenteed to prodeuce the expecting results if the user has satisfied the preconditions. By using DbC, both client and the library will trust each other and benefit from the realtionship.
							For public methods in the classes of the library, I will explicitly check if the pre-conditions are satisfied before the method will execute. After execution, i will use assert to implicitly ensure the post-condition is satisfied. for all the private methods, the the assert will be used to impkicitly check for preconditions and postconditions.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							SqRoot: (suppose on real number only)
							public class SqRoot
							{
							private static linkedList roots;
							public static  Link findRoots(real num)
							{ //precondition is num &gt;= 0
							if(real &gt;=0) then ...... //not care about the mathematics
							else throw numberRangeInvalidException(&quot;&quot;+num+&quot;is negative&quot;);//numberRangeInvalidException will be implementd within the library
							assert roots[0] and roots[1] are real numbers // hide the detail of the implementation here,just to illustrate that                                                                          // the public method will check for postcondition before it 				      // returens values
							return roots;
							}
							public static Link findRoots(int num)
							{
							//exactly the same as the previous one except the format of the argument is different.
							}
							}
							
							conclusion: pre- condition is checked explicitly and post- condition checked via assert.
							
							Stack:(Assume real number stack)
							public class Stack
							{
							private List stackList;
							public Stack{ stackList = new ArrayList();}
							
							public static real pop()
							{
							//      precondition checked explicitly: there is at least one element in the stack
							if(stackList.length()&lt;=0)
							then throw EmptyStackException(); //EmptyStack defined elsewhere within the package
							//implicit check for post-condition
							assert number at top is a real number
							else return stackList[stackList.length()-1];
							}
							
							public static Stack push( real num)
							{
							// precondition explicitly checked, num is real
							if(num is real)  // not bother the detail here
							stackList.add(num);
							//implicitly check the stackList is not empty
							assert stackList.length()&gt;0;
							return stackList;
							else throw NumberFormatException();//exception defined elsewhere within the package
							
							
							}
							
							
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						If I am going to use the library (number.jar for example)
						I will follow the DbC rules and the code is:
						
						public Stack SquareRootOfAStack(List oldStack)
						{
						private List newStack,tempStack;
						//check the precondition: the oldStack is a non empty list
						If(oldStack!= null &amp;&amp;oldStack.length()&gt;0)//first find the new list with square roots as elements
						for(int i = 0; i &lt;oldStack.length();i++)
						{
						tempStack[i]=number.SqRoot(oldStack[i])//precondition of SqRoot is satisfied and the results returned is as 			                   //expected
						}
						for(int i = 0;i&lt;oldStack.length();i++)//secondly, put the values onto the new Stack.
						newStack = number.Stack.push((real)tempStack[i]);//precondition of push is satified and the results returned 			                                  //is what we expected
						//before we return the value, we have to implicitly check newStack is not empty and values of newStack are square roots of the old values
						assere (newStack != null and (for int i = o;i,newStack.length(0;i++) newStack[i]=number.SqRoot(oldStack[i]);
						return newStack;
						
						
						}
						
						Benefits:
						Code Reuse! no need to generate code every time any more
						Library Code is correct! as long as the library classes are proved to be right, we can use the code from the library with auusmption that the code from the library will always gibes the right result.
						Better code representation: not many code any more.
						More Object Oriented.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="43" examId="CS310105" timeTaken="9000" isSubmission="true" allImages="true">
		<compositea marksAwarded="23" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Assuming that all these classes will model are footballers inheritance is a sutible mothod of representing the purpose of diffrent footballers. Using the &quot;is-a&quot; test it is possible to see that a Striker is-a kind of footballer in this context.  However, WayneRooney is a Striker and should be an instance of Striker not a sub-class, as it seam unlikely that would be muliple strikers called WayneRooney
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						For this representation of a traffic queue extending an ArryList might not be the best sollution.  As although a trafic queue could be described as a list it might be simmpler to use an array list within the client class of TrafficQueue; that is make TrafficQueue a variable of the class that will use it.
						
						ArrayList trafficQueue =new ArrayList [ ... ]
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						At first glance this inheritance higherarcy seam to work.  MobilePhones and DigitalCamras are indeed kinds of PersonalElectronicEquipment, and it could be argued that a CameraPhone is both a kind of MobilePhone and a kind of DigitalCamera.  However the problem is with the multiple super classes or parents of CameraPhone.
						Having multiple sources of inheritance could cause proble if any features (varrible of methods) of one parent are present in the other in a diffrent form, e.g. two methods with the same name but each performing a diffrent task.
						The simpleset solution for this problem would be to move CarmaPhone up the higherarcy and make it a sub-class of PersonalElectronicEquipment only.
						
						public class CameraPhone extends PersonalElectronicEquipment { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I belive this is an acceptible method for modeling the creation of new books from a master template, where instances of Book are the master templates - i.e. the orginal version rom which others are produced, and the Ojects produced by copy() are the books that are published.
						
						However, I belive a better method might be to have the  master-copies represented as abstract classes and the published books as instances there of.  This would allow indvidual information of each book to be stored - such as Eddition number if the book was so popular it had to go back to print for a second or third run, or if the book was pubished in both paper-back and hard-back.
						
						This would also help aliviate any problems that might arise from Book having two parent or super-classes.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Every sub-class of answer is diffrenent yet has similar requirements, for example each one will record the answer, be maked and the number of maks obtained will be recorded.  The format of the answer is specified by the sub-classes and the actual instaces will record the actual values.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation hides the internals (code, varible, etc) of one object or class from that of another object or class, alowing interaction to be made with the class in aprroved of ways, specifed by the interface.  This allows code to grouped to gether for object encapsulation - that is code that can only be accedded by
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						All encapsulated code has a function or task to do, when this task is needed the required encapsulated code is loaded into active memory, otherwise it can be left in storage, and afterwards it can beremoved from active memory.  This means that active memory is not clogged up with unwannted or unused code allowing more room for the desired code with makes locating it more efficient.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						It all the code for a specific task is grouped together and stored in one pace it makes it easyer to locate it.  Encapsulation helps as everything that encapsulates in to one group can only be accessed either by others within that group or through approved methods specified by the interface.  This means things relating to each other can be stored to gether easily.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design by Contract specifiyes the requirements to interact with an object or method.  If there is a way to gain access to the inerworkings of these objects or methods without following the rules laid out by the pre and post-condition then Design by Contract would fail.  As there would be no way to enforece reliyablity of the code and thereby ensure correctness of the result.  Encapsulation ensures that no unotharised access and be made to the encapsulated code and variables thereby ensuring that the code will work as it was designed to following its pre and post conditions.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							A contract is an agreement of what the client will provide a class with and what will be retruned as a result from the class in question.  A contract consits of a list of pre-conditions, or rules that need to be met for the class or method to function correctly, and a set of post-conditions with define what the result of using the class or method in question shall be. The contract dose not specifiy how the result will be obtained, this information is hidden from the client.  The client simply knows that providing its call to the class, or its methods, obays the pre-conditions of the class, or method, in question then the class will perform the required task which result in the post-conditions being correct.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Class SqRoot finds the square root of a number, to do this without resorting to complexed numbers, the number to be rooted need to be greater than zero, this will be a pre-condition for this class.  The resulting answere will be posotive but its negative equivelent is also an answer (i.e. (2*2) = 4 but also ((-2)*(-2)) = 4), as it is normally the posotive answer that is required this it what will be provided (if a fuction dose require the negative answer it can negate the answer its self), therefore the post-condition is to provide the posotive solution for the root of a given number.  The final assumptions is that both the incoming number and the out going soulution will be of the varrible type real numbers, to maintain a resonble level of accuracy.
							
							/* Globals: Real: num, result
							Pre-condition: (num &gt;0)
							Post-condition: (result = SqRoot(num) &amp;&amp; result &gt;0)
							Exception: (num &gt;0) -&gt; result =0
							*/
							Class SqRoot{
							Public Real getSqRoot (Real num){
							Real resut = 0; /* root of num */
							/* test to ensure pre-condition met*/
							if (num&gt;0){ ... /*method code*/ ... }
							return result;
							} /* end of getSqRoot */
							} /* end of class */
							
							
							Class Stack maintains a stack of numbers as before assumptions must be made as to what is required of this class and what this class requires to preform its task, these become the pre and post conditions.  As no other information is given it can be assumed that duplicates are acceptible within the stack.  A stack works on the principle of last in first out, such as a stak of paper you take the top sheet first, therefore the post-condtion for the access method would be last number in is the first number to be retived.  A pre-condition would be that all numberes within the stack are real numbers - this will prevent any inconsistanceies.
							
							/* Globals: Real: num, result
							Post-condition: (result = Stack[top])
							*/
							Class Stack{
							/* pop top number (result) from stack */
							Public getNumber (){
							{ ... /*method code*/ ... }
							return result;
							
							/* push new number(num) on to top of stack*/
							Public setNumber (Real num)
							{ ... /*method code*/ ... };
							} /* end of setNumber */
							} /* end of class */
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						As this new program will be using both SqRoot and Stack it will need atleast the pre-conditions of both.  This means that although all of SqRoot&apos;s and Stack&apos;s pre-conditions nee to be inclulded in this new classes pre-condition not all of the post conditions do, for example this could mean that this new program could process the numbers like a queue, first in first out, ignoring Stack&apos;s post condition of first in last out.  However as the description specifies roots of a stack of numbers it will be assumed that the result is deired in a stack format.
						
						/* Globals: Real: num, result
						Pre-condition: (num &gt;0)
						Post-condition: (result = SqRoot(Stack[top]) &amp;&amp; result &gt;0)
						Exception: (num &gt;0) -&gt; result =0
						*/
						Class StackSqRoot{
						
						/* a method for inserting positive numbers into an instace of Stack */
						Private fillStack(Real num){
						/* test to ensure pre-condition met*/
						if (num&gt;0){ ... /*method code*/ ... }
						} /* end fillStack */
						
						/* method for rooting Stack
						Private sqRootStack
						{ ... method code send each number in stack to SqRoot ... }
						} /* end sqRootStack */
						
						/* pop top number (result) from the instace of Stack */
						Private Real emptyResultStack (){
						{ ... /*method code*/ ... }
						return result;
						
						main (){
						/* creat two instances of Stack one to store numbers to be rooted in and one for the results */
						/* .. other code required by this class ... */
						
						
						The benifits of using these previously created classes, SqRoot and Stack, is that by reusing existing code it saves time having to re-write what already existis with defined pre and post-conditions.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="44" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="33" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						public abstract class Footballer { .. }
						public class Striker extends Footballer { … }
						public class Defender extends Footballer { .. }
						The is-a test is passed for the two sub-classes. This is an appropraite way of using inheritance as class Footballer can contain information and methods common to all football players, and the sub-classes can contain more specific information and methods to each type of footballer.
						
						public class WayneRooney extends Striker { … }
						The is-a test is passed for this class, however, this is when roles come into play: as WayneRooney is not always a Striker; it is just a role. More appropraite code would have been:
						public class Person {...}
						public class WayneRooney {
						Striker role; //or a list of roles
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I believe this is not a good way of moddelling the inheritence, as ArrayList is being extended which means that methods from ArrayList can be overriden. This is a bad design as the methods in ArrayList will already be optimised.
						It would be better to make TrafficQueue a client of ArrayList, hiding the internal data structure using encapsulation.
						It would also be better to use code to the interface List not ArrayList, just in case we would want to change the way the TrafficQueue was stored.
						This means better code would be something like:
						public class TrafficQueue {
						private List queue;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						The is-a test is passed for both classes, and is a good way of modelling the inheritance.
						
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						I believe this is bad use of inheritance as a CameraPhone is-a Mobile phone, but has-a digital camera, so I believe the inheritance for CameraPhone should be as follows:
						public class CameraPhone extends MobilePhone {
						DigitalCamera camera; //or a list of features
						…
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class Book extends InformationSource, Copyable { … }
						The is-a test suceeds. However, I believe this a bad way of modelling the inheritance as the details of the class &quot;Copyable&quot; can be overriden by sub-classes, and if we want this to be a replacement for &quot;clone&quot; then we want our implementations of the class to remain consistant. The best way to do this would be to make the Copyable class an interface which we can implement. The following code show this:
						
						interface Copyable {...}
						public class Book extends InformationSource implements Copyable { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public class MCQAnswer extends Answer { … }
						public class TextAnswer extends Answer { … }
						I belive these classes a a good use of the inheritance as they pass the is-a test. This cannot be done any other way as different questions have different kinds of answers - eg a MCQ answer will be a number and a text answer will be text.
						
						public class NoAnswerProvided extends Answer { … }
						I believe this is a bad use of inheritance as the is-a test fails here and also we do not know what type of answer should have been given. A better way to model this would be to have the answer within each class initialised to null, and only overriden when the quetion was answered (or returned to null if the question is unanswered):
						public class MCQAnswer extends Answer {
						int answer = null;
						...}
						public class TextAnswer extends Answer {
						srting answer = null;
						...
						}
						This way any answern can be tested to be a NoAnswerProvided answer, and we still know what type of answer it was.
						
						public class NoAnswerRequired extends Answer { … }
						I believe the is-a test fails for this class in the same way as NoAnswerProvided. A better way of modelling this would be to use an internal variable &quot;required&quot; which would be set to true is the answer is to be answered:
						public class MCQAnswer extends Answer {
						bool requied = true;
						…
						}
						public class TextAnswer extends Answer {
						bool required = true;
						…
						}
						However, my alternative means that when a question is used or selected, its &quot;required&quot; variable has to be set to true.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A Design Pattern is a general solution to a problem which is too specific to use coded examples.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The Composite design pattern could be used with create effect in the design of such software.
						This is because questions logically are composites, as questions can be built up of sub questions
						- eg Q 2.3 or Q 8 a i).
						There will need to be a parent class called question which should be declared abstract. This classs then as sub-classes for each type of question that will be used in the system (eg multiple choice question, and text question, etc).These would be concrete sub-classes of Question, meaning methods would be inherited and could be overriden if required.
						
						public abstract class Question {...}
						public class MCQuestion extends Question {...}
						public class TextQuestion extends Question {...}
						...
						There will also be another sub-class of Question; composite question (ie a question built up of smaller questions).
						This will be a class that will encapsulate the sub-questions that it contains. It will contain a list of Questions as the questions could be a question like MCQuestion or TextQuestion, or it itself could be another composite question.
						
						public class CompositeQuestion extends Question {
						List questions;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The proxy design pattern could be used in this software with great effect. This is because the Java applet running the software will need to communicate with the central server from anywhere around the world. It would mean the applet and central server would not need to know where each other where located. This would be the job of the proxy, which is an intermediate class - each class communicates to the proxy, then it communicates with the other class on behalf of the class. The proxy will receive a state from a class and it will transmit the state to the other class.
						
						The Singleton design pattern could be used in this software for questions like multiple choice questions where we might only want one answer to be selected, and not be able to be changed from outside the class without &quot;answering the question&quot;. This would be done by declaring the int answer as private
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to prove the libraries are correct with regard to the specification.
							The contract is that if the client starts in a state agreed by both parties, the program/method will terminate in a state agreed by both parties.
							I would define the contracts by using pre- and post- conditions (class invariants could be used, but they prove correctness, not the contract).
							A pre-condition is a state that the program must be in before execution of the program starts. This is agreed by the client and supplier and is compulsary for the client to be in this state before execution.
							A post-condition is a state that the program must terminate in. This is agreed by the client and supplier, and is compulsary for the supplier to be in after execution.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							SqRoot would need to be defined by what the client needs to supply before execution and what the supplier needs to supply after execution. The client will need to supply a number to be squarerooted. It may be agreed, for example, that the client agrees never to supply a negative number. The supllier will agree to give the sqareroot of the number given, given that it is not negative. This means if the contract is broken by the client - eg if a negative number was supplied, then the supllyer does not need to worry about supplying a correct answer, as the client has broken the contract. However, if the client keeps their side of the contract, the supplier has an obligation to supply the correct answer to the client. If the supplier does not, then it is the supplier who has broken the contract. The code will be something like:
							class SqRoot {
							public real sqrt ( real n ) {
							assert { n &gt;= 0 } //PRE-CONDITION
							//find squareroot fo n
							...
							assert { result = n * n }
							return result;
							}
							...
							}
							
							Stack would need to be defined by what the client needs to supply before execution and what the supplier needs to supply after execution. The client will either supply a number to push on the stack and the supplier will push it on the stack, or the client will ask for a &quot;pop&quot;ed number from the stack, and the supplier will supply it. The code would be something like:
							class Stack {
							
							public void push ( real n ) {
							//PRE-CONDITIION here
							//push number onto stack
							...
							//POST-CONDITION here
							}
							public real pop ( ) {
							//PRE-CONDITIION here
							//pop number from stack
							...
							//POST-CONDITION here
							return popped;
							}
							...
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The benefits of using SqRoot and Stack would be that hey would have already been proven correct with regards to their specifications. This means that when the new program using both is poofed, the method calls to SqRoot and Stack are know to be correct, if we keep to their pre-conditions. We would find that composition can be used for the pre- and post- conditions, as the post-condition of pop() should be a pre-condition of sqrt(), and the post condition of sqrt() is a pre-condition of push(). This means if the three methods are used in together in the correct order, we only need to prove the pre-condition of pop(), and the result will be correct. The code could look as follows:
						class SqRootStack {
						
						//PRE-CONDITION FOR doIt()
						public Stack doIt(Stack stack) {
						...
						for (int i = 0; i &lt; stack.size(); i++) {
						//PRE-CONDITION FOR POP() MUST HOLD HERE
						...
						}
						//POST-CONDITION FOR PUSH MUST HOLD HERE
						return stack
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="45" examId="CS310105" timeTaken="6727" isSubmission="true" allImages="true">
		<compositea marksAwarded="23" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is not very sensible. The IS-A test loosely passes. What i mean by this is that a striker IS-A footballer but this, and all the other statements show the role-played by problem. Strikers, footballers and defenders are roles. Roles can change, e.g player may no longer be footballer (retires) or changes position. What is more important is the properties held, which allows the differentiation. To capture this, we need to have a position class which defines position(s) played by a player. The class footballer is no longer abstract and is used to define player name and assign position(s) to:
						
						public class Footballer{
						String footballerName;
						PersonalDetails [] personalDetails;
						}
						
						public class Position
						{
						Position = {Defender, striker, goallie, midfielder};
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is not very sensible. The problem here is that TrafficQueue fails the IS-A test, because a the class TrafficQueue uses an ArrayList, it isn&apos;t a arraylist. This is fragile to change (if the data structure were to change). Also, as TrafficQueue grows, the arraylist will become a less significant part of the class. Finally, there is the problem of TrafficQueue being able to access variables in the Arraylist implementation as there is way of hiding these. The alternative would be to create the class TrafficQueue and to declare and initialise an Arraylist in the class:
						
						public class TrafficQueue {
						ArrayList TrafficList[];
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						(Multiple inheritance not allowed in Java, but assuming it is allowed):
						MobilePhone passes the IS-A test, because a mobile phone is a piece of personalElectronicEquipment.
						DigitalCamera also passes the IS-A test, because it is a piece of personalElectronicEquipment.
						
						So CameraPhone can be conceptualised as a Mobile Phone and a camera.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						(Java doesn&apos;t allow Multiple inheritance, but assuming it is allowed):
						
						Poor use of multiple inheritance. Book passes the IS-A test for InformationSource but fails IS-A test for Copyable because it isn&apos;t a copyable, rather it uses features of the Copy method.
						This is poorly done. The inheritance from Copy provides access of copy variables to Book, which cannot be hid in java. A better way would be simply import a library containing the class copyable and use the methods that way. Or you could create an instance of copyable in the class Book and performs methods using instance created. (We still can inherit from InformationSource, if needed):
						
						Public class Book extends InformationSource{
						Copyable copyable = new Copyable();
						copyable.copy(this.Book);
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						MCQ, TextAnswer both pass IS-A test.
						
						NoAnswerProvided is- a-kind of answer, not is-a answer, therefore alterntive would be to use parametisation:
						Public abstract class Answer{
						public answerProvided(Answer a){
						//check if provided any
						}
						}
						
						NoAnswerRequired should also be parametised
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern that is essentially a collection of objects and/or classes that for a particular context/situation, can be modified so that they provide a solution for design problem. Their are general solutions which provide the benefit of being able to reuse designs.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						What the composite design pattern does is allow all nodes is a tree to be presented uniformly. In this context, because there will be many different types of answers, the pattern will be able to make all such nodes uniform and consistent.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Proxy design pattern: This is useful because it will provide communication between servers.
						
						Flyweight design pattern: The pattern applied to store answers in a much smaller size, but is is more complex
						
						Stategy : The  classes employing various strategies (modelled a algorithms) to be able to be accessed as required at runtime
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to bind a class and its clients together. The contract provides a formal agreement between the class and its clients. The formal agreement (contract) expresses the rights and obligations the classes. This would be useful in a library due to the interaction of classes in a library. They would be able to maintain a significant degree amount of trust in the system and ensures data integrity. Contracts are defined by logical predicates precondition and postcondition. The precondition states conditions necessary for method to function properly and the post condition declares resulting state properties, provided the post condition is satisfied. The loop invariant is a global assertion that holds for all methods in a class in all stable states.
							The pre condition is an obligation for the client and a benefit for the supplier.
							The post condition is an obligation for the supplier and a benefit for the client.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							For class SqRoot:
							
							class SqRoot
							Attr:
							methods: Square (method that does the square rooted)
							pre: x&gt;=0	(the precondition ensures that the number to be square rooted is at least 0, as we cannot perform
							operation on less than 0.)
							post: x&gt;=0 	(answer will always be at least 0, provided pre-condition satisfied)
							
							
							
							For class Stack:
							
							class Stack
							Attr:
							methods: push
							pre: Stack not full and stack at least size 1
							
							post:stack 1 more larger in size
							
							
							for pop:
							
							pre: stack has at value to pop(at least 1 value)
							post: stack 1 size less
						</answerString>
					</freeTextAnswer>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="46" examId="CS310105" timeTaken="7186" isSubmission="true" allImages="true">
		<compositea marksAwarded="47" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first three definitions pass the is-a test since every Striker is a Footballer as is every Defender (assuming the sport under consideration is football of course).
						
						Of course in addition a Footballer could also be, for example, a team captain. This could be parameterised with a property such as isTeamCaptain. It is possible, although I beleive it is rare, that a footballer may change his/her playing position during the course of a career. If this needs to be modelled then it may not be wise to use inheritance.
						
						On the other hand, although WayneRooney &apos;is a&apos; Striker, he is also a Person, a Celebrity etc. Rather than modelling this through (multiple) inheritance it is probably wiser to regard each of these as &apos;roles&apos; played by WayneRooney. For example:
						
						public abstract class Role { .. }
						
						public abstract class Footballer extends Role { .. }
						public abstract class Celebrity extends Role { .. }
						
						public class Striker extends Footballer { … }
						public class SportsCelebrity extends Celebrity { … }
						
						public class WayneRooney
						{
						private Role job = new Striker();
						private Role star = new SportsCelebrity();
						//alternatively the various roles could be stored in a List
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						It could be argued that a TrafficQueue is an ArrayList but this is not a good use of inheritance for several reasons:
						* It is not possible to hide inherited methods in Java so TrafficQueue would contain unwanted methods inherited from ArrayList which clutters up the interface and may break encapsulation.
						* It may be necessary or desirable to change the internal representation of the TrafficQueue to another data type such as a LinkedList.
						
						A better solution would be to have the ArrayList as a property of the TrafficQueue:
						
						public class TrafficQueue
						{
						private List theList;
						
						public Object get(int i)
						{
						return theList.get(i);
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a possible use of multiple inheritance. However appart from the fact that Java doesn&apos;t sopport full MI, full MI can be messy, complicates the language and should generally be avoided unless entirely necessary.
						
						This situation would probably be better modelled as:
						
						public class CameraPhone extends MobilePhone
						{
						public DigitalCamera camera;
						//as long as DigitalCamera is properly encapsulated
						//it should be OK to make it &apos;public&apos;
						}
						
						since the camera is more a property of a phone than an integral part of it (though this seems to be changing...). Hence:
						
						CameraPhone myPhone = new CameraPhone();
						
						//instead of myPhone.takePicture() we use:
						myPhone.camera.takePicture();
						
						which I believe is an intuitive way of accessing the camera.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a sensible use of multiple inheritance though it may not be necessary to use full MI. Since the code for copying the Copyable object is likely to be class-specific, having Copyable as a Java interface which Book implements would suffice:
						
						public interface Copyable
						{
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable
						{
						public Object copy()
						{
						//implementation for Book
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The definitions of Answer, MCQAnswer and TextAnswer seem largely sensible. However it is questionable whether NoAnswerProvided and NoAnswerRequired are actually answers. They are likely to have some of the same methods but others will be meaningless.
						
						A better solution might be:
						
						public abstract class Response { … }
						public abstract class Answer extends Response { … }
						public abstract class NonAnswer extends Response { … }
						
						public class MCQAnswer extends Answer { … }
						public class TextAnswer extends Answer { … }
						public class NoAnswerProvided extends NonAnswer { … }
						public class NoAnswerRequired extends NonAnswer { … }
						
						on the other hand this may make algorithms more complex due to the need to differentiate between Answers and NonAnswers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation, or information hiding, is a fundamental aspect of OO software. It allows the designer of a class to only make available to the outside world methods and data which are relevant and safe to access. Abstraction is the separation of this world-viewable interface from the world-hidden implementation of the class. Without encapsulation, the implementation of a class would be clearly visible which would make abstraction more difficult.
						
						Example:
						in a procedural program it is common to import libraries of functions. These functions may need to use &apos;helper&apos; functions which are not strictly relevant to other programs. Without encapsulation it is impossible to prevent users of the library from calling these helper functions directly. If the implementation of the library is later changed and the helper function is replaced with a different one or removed entirely then this is likely to break any external code which used it. With encapsulation, the implementation of the library methods can be &apos;abstracted away&apos;. Any programmer using the library is only aware of the interface and has no way of accessing such helper methods.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Dynamic binding is only needed for publicly visible methods and data. Therefore, since dynamic binding involves significant processing overheads, if irrelevant methods are encapsulated, or hidden, performance is improved.
						
						Encapsulation also makes it much easier to change implementation details such as using a more efficient internal data representation or improving the algorithm(s).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						When using manual storage management it is imperative to keep track of what object and data are created and who has access to them so that they can be deleted when they are no longer in use.
						
						Using encapsulation we can make the data private thereby ensuring that only our methods have access to the data. Hence when we know that we have finished with the data we can delete it and reclaim the space. Without encapsulation it is possible that another object is using the data and we cannot be sure it is safe to delete.
						
						Reference counting is a common technique in manual storage management. This is easier to achieve if there is only one way that a program can create the data/objects.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by Contract in software development is the process of defining exactly what a piece of software should do. Encapsulation is very helpful in this as it allows the code to be modularised and each module to be carefully checked against the specification.
						
						In a procedural language every function and every datatype needs to be checked against the specification. Using encapsulation all the internal workings of the software are hidden so as long as the interface complies to the specifications (i.e. each public method does what it is supposed to) it doesn&apos;t matter, from a DbC point of view, what the rest of the code does.
						
						Furthermore by breaking the code down into smaller pieces or modules, each with a predefined interface, it is easy to delegate different modules to different software engineers. These engineers may not even work for the same company; as long as they all stick to the specification they need not ever meet!
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a way of communicating an general design principle which can be applied in a particular context. These patterns have been established in the field but are too general to be coded specifically.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The basic unit of an exam is the question. There are many types of question for example question 3 on this exam is composed of subquestions 3.1, 3.2 and 3.3. Each of these subquestions requires some text input but other questions may require a single choice from a list etc.
						
						First a general class for questions can be defined:
						
						public abstract class Question {
						public int getMarks();
						}
						
						next it is useful to differentiate composite questions (i.e. question having subquestions such as question 3 dexribed above) from atomic questions (i.e. question 3.2):
						
						public abstract class AtomicQuestion extends Question
						{
						private int marks;
						public int getMarks()
						{
						return marks;
						}
						}
						
						public class TextQuestion extends AtomicQuestion {...}
						
						public class CompositeQuestion extends Question
						{
						private List subQuestions;
						public int getMarks()
						{
						int marks = 0;
						for(int i=0;i&lt;subQuestions.size();i++)
						marks += subQuestions.get(i).getMarks()
						return marks;
						}
						}
						
						The class CompositeQuestion contains a list of Questions. Through polymorphism these may either be CompositeQuestions (i.e. containing further subquestions) or subclasses of AtomicQuestion.
						
						This is an example of the composite design pattern. CompositeQuestion doesn&apos;t need to know what kind of question each of its subquestions is in order to calculate the marks for that question. Dynamic binding ensures that the correct version of the getMarks() method is called depending on the context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						PROXY
						Since the examination Java applets are likely to be on a different system to the central server it may be useful to have a remote proxy running on each applet machine. If the proxy presents the same interface as the remote server, the applet can make method calls to the proxy as if it was the remote server. The proxy can then forward these calls through the network to the server (or, more likely, to another object running on the remote server who will interpret the message and make the call to the server). The proxy will then receive the answer from the server and return a value to the applet. Alternatively the applet may have client-server communications built in.
						
						SINGLETON
						An exam can be modelled as a CompositeQuestion:
						
						public class Exam extends CompositeQuestion {...}
						
						In this case it is likely that we will only want a single exam object to exist in the software at any one time. We can enforce this with the singleton design pattern:
						
						public class Exam extends CompositeQuestion
						{
						private Exam theExam = new Exam();
						private Exam() {...}
						public getTheExam()
						{
						return theExam;
						}
						}
						
						By making the constructor private we ensure that no instances of Exam can be created outside of the class. Since we only create a single instance of it inside the class we now know that this is the only instance.
						
						VISITOR
						If the exam answers are structured like the exam questions mentioned above (i.e. in a tree) it may be useful to implement the computer marking using the visitor design pattern. This is sensible since the types of answer are essentially fixed (multiple choice, text, drawing) but, depending on the exam subject and the development of the marking software, the marking alrgorithms are likely to be frequently modified. Each question must implement an accept() method which will accept an AnswerVisitor object and call a method on that object passing a reference to itself e.g.:
						
						public void accept(AnswerVisitor av)
						{
						av.visitTextAnswer(this);
						}
						
						The AnswerVisitor class implements a method for each type of question it can visit.
						
						STRATEGY
						Exams in different subject areas will need different marking algorithms. For this reason it would be useful to package the marking algorithm into its own class. An abstract superclass for all algorithms could be created:
						
						public abstract class MarkingAlgorithm {...}
						
						each individual algorithm would extend it:
						
						public class BiologyMarkingAlgorithm extends MarkingAlgorithm{...}
						
						Since each algorithm has the same interface it is a simple matter to exchange them. The correct algorithm can even be selected at run-time depending on the exam subject or question type.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="47" examId="CS310105" timeTaken="6811" isSubmission="true" allImages="true">
		<compositea marksAwarded="29" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The inheritance of Striker and Defender are well define; however the class WayneRooney shouldn&apos;t be a class, it would be an instance of the Striker class.
						Eventhoug Striker and Defender uses inheritance ok (passes the is-a test), it is not well apply in this case since Striker and Defender ARE ROLES played by the players, a player could be sometimes Striker and others Defender. Those roles can change over the time and inheritance it is not appropiated in this case.
						
						public abstract class Footballer{
						String roledPlayed; //(could be Striker or Defender)
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Altough it can work, it would be better if the class TrafficQueue does not inheritance ArrayList; instead it should &quot;delagete&quot; operation of ArrayList, in other words habing ArrayList as a client, in that way if you want to change the ArrayList implementation you do not have to change all the structure, ie you may want to use just an Array, a List, etc.
						
						public class TrafficQueue {
						private ArrayList queue = new ArrayList;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The inheritance of PersonalElectronicEquipment in MobilePhone and DigitalCamera class are fine.
						
						Multiple Inheritance is a difficult thing to implement correctly. A CameraPhone does not pass the &apos;is-a&apos; MobilePhone test. A MobilePhone may have a CameraPhone, so in this case it should use delegation. On the other hand, a CameraPhone passes the &apos;is-a&apos; DigitalCamera test, so there the inheritance is used correctly if there is enough evidence (meaning that you should make a specific class for this kind of camera) that a specifict class should be build. In that case the only classes that should be changed are the following:
						public class MobilePhone extends PersonalElectronicEquipment{
						CameraPhone camera;
						...
						}
						
						public class CameraPhone extends DigitalCamera{...}
						
						However, I think it would be better not to build a specific class for the CameraPhone because the MobilePhone could have a DigitalCamera, and it is prefered to use delegation if it works instead of inheritance. So in that case it would be as follow:
						public abstract class PersonalElectronicEquipment{...}
						public class MobilePhone extends PersonalElectronicEquipment{
						DigitalCamera camera;
						...
						}
						public class DigitalCamera extends PersonalElectronicEquipment{...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Inheritance it is used properly IF what you want is that the book is Copyable, instead of having InformationSource copyble.
						Java does not support multiple inheritance of implementation (just interfaces) and it is not very good practice to make your own implementation if those are already define in the API, that is why I think it would be better to use just the inheritance of InformationSource and use the clone method defined in the API (taking into consideration that the classes defined extends class Object that has that method). So the only class that I would do woud be:
						
						public class Book extends InformationSource{...}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The MCAAnswer, TextAnswer and NoAnswerProvided use propperly inheritance (NoAnserProvided using the Null Pattern could be arguable). However NoAnswereRequired could be a boolean attribute in the class Answer. A MCQAnwere as well as a TextAnwer  could be NoAnswerRequired.So it would be as follow:
						
						public abstract class Answer{
						boolean required;
						...
						}
						
						public class MCQAnswer extends Answer{...}
						public class TextAnswer extends Anser{...}
						public class NoANswerProvided extends Answer {...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design Pattern is a general solution (general design) to a problem in an specific context. Grand stated that it should have the following elements:
						- Name: so it could be used as a common language.
						- Examples: Suggested that it should have 3 examples
						- Froce: why did the designer made it for
						- Context: Motivation, when is it used for and for what specific problem.
						- Description
						- Alternative patterns/techniques:
						- Domain: where can it be applied
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The Composite pattern is used to treat different objects as equal. In this case is very usefull since you could have questions that are formed by other questions. You want the class Question to have a methog getMarks(); there could be different types of questions, each question defining its own getMarks() method according to the requirements; a question may have subquestions that also should have the getMarks method(), that is why Composite patter is very useful.
						
						public class Question{
						public int getMarks(){...}
						...
						}
						
						public class MCQ extends Question{
						public int getMarks(){...} //overrides the super getMarks using the correct implementation
						...
						}
						
						public class CompositeQuestion extends Question{
						public int getMarks(){
						// for every AtomicQuestion a, a.getMarks() and add all the marks of the AtomicQuestions
						}
						
						public class AtomicQuestion extends Question{
						private int marks;
						private int getMarks(){   //is declare as private so if CompositeQuestion have subclasses, those 				//subclasses cannot implement getMarks
						return this.marks();
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Null Patern: In the classes in charge of actually marking the exam, there could be a class abstract class Answer and a subclass NoAnswerProvided of Answer that allows to the system not checking so many times for nulls; instead the appropiated object is selected via dynamic binding instead of IF statement to check the nulls objects. (As in Question 1.5)
						
						Factory Pattern: It could be used not to explicit define which type of question is each question, it can use Question q = ques.getQuestionType(String question), so the proper object is selected via dynamic binding at runtime.
						
						Singleton Pattern: it could be used to control the writting to the database. Using the singleton patter you can assure that you just have one connection to the database that writes. In a mulithread environmen the private contructure should be defined as asynchronoud to avoid the very rare case that while it&apos;s in the consturcur another thread does not know about it an then you have duplicated connections.
						
						Flyweith Pattern
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="4" isMarked="true">
				<compositea marksAwarded="4" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to make the proggraming easier (for the programmer, not for me since i have to define the obligations) since there is no need to cheked the requirements each time. It would decrese errors at runtime. DbC allows an easier way to make systems correctness (do the right thing according to the specification of the system).
							If I would use Eifeel there are specific words that support DbC.
							Using OO program I would have boolean methos that check the obigations, so for example a client cl would have a method that check that the requirements for cl are satisfy. And the client should also have a method that check that its requirement are being satisfy.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							SqRoot can only be calcuated for postive number, meaning greater or equal to 0. So in this case DbC should be:
							
							public class Number{
							public long sqRoot(){
							//calculate sqRoot
							}
							}
							
							This mathod should&apos;t checked if the number is a positve number since according to DbC the class invoking this method (client) should check that because is should be its obligation to check that.
							Number n1 = Number();
							...
							if (n1&gt;=0)
							n1.sqRoot();
							else
							{ SytemOut.Println(&quot;It is not possible to calculate squared root of non positive numbers&quot;);
							}
							The obligatoin of sqRoot method is the presiton define in the long, it has to return a number that multiply by itself is equal to, in this case, n1.
							..............................
							It is the obligation to the clients not to ask for an index not within the limits of the Stack; it is also its obligation not to call to a null stack, but this could be cheked by the compiler. It is an obligation to the Stack to return the element of the specific Type
							public class Stack{
							int element;
							getElementAt(int i){
							// goes to the position in memory of element i and return the element in that position
							return this.element;
							}
							}
							
							//client
							public class Whatever{
							Stack st = int []; // I do not remember how to declare a stack
							int number;
							for(i=0; i&lt;st.size(); i++) // The index is within the allow limits
							{
							number = (int)st.getElementAt(i); //Although it is obligatoin of the Stack and not the client to return				// the required type, in Java a cast is used since the Stack could  				// contain any object.
							}
							}
							
							Another way to do it is by having a global variable that controls when a element is created and it increases its value and when an element is destroy it decreases its value.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						I DIDN&apos;T UNDERSTAND THE DIFFERENCE BETWEEN THIS AND QUESTION 4.1 (it is the same answer as the question 4.1)
						
						SqRoot can only be calcuated for postive number, meaning greater or equal to 0. So in this case DbC should be:
						
						public class Number{
						public long sqRoot(){
						//calculate sqRoot
						}
						}
						
						This mathod should&apos;t checked if the number is a positve number since according to DbC the class invoking this method (client) should check that because is should be its obligation to check that.
						Number n1 = Number();
						...
						if (n1&gt;=0)
						n1.sqRoot();
						else
						{ SytemOut.Println(&quot;It is not possible to calculate squared root of non positive numbers&quot;);
						}
						The obligatoin of sqRoot method is the presiton define in the long, it has to return a number that multiply by itself is equal to, in this case, n1.
						..............................
						It is the obligation to the clients not to ask for an index not within the limits of the Stack; it is also its obligation not to call to a null stack, but this could be cheked by the compiler. It is an obligation to the Stack to return the element of the specific Type
						public class Stack{
						int element;
						getElementAt(int i){
						// goes to the position in memory of element i and return the element in that position
						return this.element;
						}
						}
						
						//client
						public class Whatever{
						Stack st = int []; // I do not remember how to declare a stack
						int number;
						for(i=0; i&lt;st.size(); i++) // The index is within the allow limits
						{
						number = (int)st.getElementAt(i); //Although it is obligatoin of the Stack and not the client to return				// the required type, in Java a cast is used since the Stack could  				// contain any object.
						}
						}
						
						Another way to do it is by having a global variable that controls when a element is created and it increases its value and when an element is destroy it decreases its value.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="48" examId="CS310105" timeTaken="7198" isSubmission="true" allImages="true">
		<compositea marksAwarded="22" isMarked="true">
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This passes the is-a test, however the problem with this use of inheritance is that a footballers can change their job, for example they  could be defenders and strikers.  Also this is missing some other subclasses, such as midfielder, goalie etc.  The best thing to do would be to create a seperate class called footballers and use delegation in this.  So footballers can change what they do if required.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This fails the is-a test, so inheritance should not be used here.  Also this is sort of like an implementation subtyping, so it would probably only use a few select features of the ArrayList class, so really there is no need to have ArrayList as an extention of TrafficQueue.  The appropriate thing to do would be to use delegation.  ArrayList would be created (instantiated) inside the Traffic queue class and calls could be made to the arraylist class in this way.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The use of subtyping in this is almost correct, in that it passes the is-a/is-a-kindof test.  MobilePhone is-a-kindof PersonalElectronic equipment although it is not necessaraly &quot;personal&quot;. There are many problems with this however.  Firstly the cameraphone class uses multiple inheritance which should not be used as this can lead to problems such as attributes in two classes with the same name, also multiple inheritance is not allowable in java.  The cameraphone class is-a-kindof PersonalElectronicEquipment, however, it is not used as an extention to cameraphone.  The best thing to use here would be parametrisation.  There could be one main class called ElectronicEquipment and put all the subclasses listed above in this class instead.  The correct method would be used by looking at the parameters, e.g. the parameter for digitalcamera could be digital.  Therefore the digital camera method would be used.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Firstly multiple inheritance is used which can lead to problems such as attributes in two classes with the same name also, multiple inheritance is not allowable in Java.  It passes the is-a test though for InformationSource, however, Book is-a copyable doesnt pass, it could be renamed to CopyableMaterial.  Instead of using inheritance, delegation should be used.  The Copyable class for example could be instantiated inside th Book class, then calls can be made to the Copyable class.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						MCQAnswer and TextAnswer pass the is-a test.  However, the NoAnswerProvided does not and could benefit from using delegation instead.  Instead of extending anything, Answer could be instantiated in the NoAnswerRequired class and calls to answer could be made from within this class in this way.  Either that, or paramerisation could be used for all the classes.  Eg text could be used as a parameter in order to call the TextAnswer method in a new class called AllAnswers.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a solution to a complex problem that has been implemented by professional programmers in order to be used by new programmers and even long time established programmers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The composite design pattern involves the process whereby the classes can have a value passed to all of the classes even if they are not related.  This is useful because it allows for example the client (student) to take the exam.  When it is submitted, the details of it can be passed to all the classes involved in order for it to be processed.   The same can happen with the exam questions themselves.  They can be created, and distributed across all the classes and be displayed.  This would involve a blackbox process where the user would have the software to view and answer the question, however the cenral server handles all the details of this therby hiding detains from the user.  The composite design pattern involves splitting the large class down into smaller classes which can interact with one another.  The majority of these classes would be on the centeral server (for marking etc) however some classes would be on the users computer for display of the questions, submition of questions etc.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						One design pattern that could be used is the feather lite pattern.  This featherlite pattern is used in order to reduce the number of operations or store in memory.  This is acheived by grouping togehter similarly formatted characters for example and assigning a formatting sequence to this eg the text font face, font size etc  This reduces drastically the number of operations or the amount of memory need in order to sustain the system.  So intead of storing formatting for 20,000 charachers for example, if 15 different styles are used in text, only 15 values would need to be stored.  This can be used in the above system to for text formatting (if needed) or even other things such as grouping of repeated text.
						Another design pattern that can be used is the factory design pattern.  This involves the use of dynamic binding in order to define the type of method that must be exectuted rather than using over complicating if statements.  There would be one class (perhaps a factory class or a subclass of a particular class) this would use dynamic binding in order to find the method that is required to be executed according to that particualr variable.  This could be used in this system to prevent over complication of the code with if statements.
						Another design pattern that could be used is a sorting algorithm (eg in order to sort the top mark students descending to lower mark students into a table).  There are many algorithms that can be used to do this, such as bubblesort, mergesort, quicksort or using binary trees in order to sort etc  A quick explanation of merge sort is that it splits a collection of numbers in half and then takes the left side numbers and splits them again (if possible)  It does this recursively until it is down to 2 numbers.  These numbers are then compared and swapped if needed.then merged together, then the process happens again eg numbers split recursively etc  The whole process repeats recursivly until the numbers are sorted.  This is a good algorithm to use in order to sort numbers eg the exam results, student number etc
						Antoher pattern that could be used that can be implemented into the classes are patterns such as the linked list, array, hashmap etc.  These are professionally made classes which can be used.  For example an array can be used to hold student id data, exam mark data etc.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							The purpose of using design by contract is that this is like a legal agreement between the software developer and the client that want the coftware developed.  The precondition is specified by the client, eg if number is less that 50 carry out the method etc.  And the post condition is the responsibilty of the programmer.  The post condition must be satisfed when the method has completed in order for the contract to be valid.  Once a contract has been agreed upon the programmer can get to work.  There is also a class invariant, this is a condition that must be satisfied throughout the code eg MAX_VALUE &lt;= MIN_VALUE.  The whole point in this is for the programmer to be able to design a system according to the requrements of the client, and without preconditions (condition that must be satisfied for the code to execute) and post conditions (condition that must be satisfed when the method has completed) this would not be possible.  DbC involves extra work, however the benefits are plentiful.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Class SqRoot
							
							PreCondition: number &lt; 0
							number = element of the real numbers
							class invariant: number = element of the real numbers
							
							code executed here .........
							
							Post Condition: sqrootednumber &gt; number
							sqrootednumber = element of the real numbers
							
							The precondition in this is that the number that is passed as an argument to this method must be an element of the real number system that is greater than 0 eg 0.1, 50, 500.3455636 etc
							
							The class invariant makes sure that the number stay as an element of the real numbers throughout the code.
							
							The Post condition that the method must satisfy in order to exit the method is that the answer obtained from this method (sqrootednumber) is less than the number itself.  If the answer is greater than the number, we know that the code is incorrect.
							
							
							
							Class Stack:
							
							Push:
							Precondition: stackpointer &gt; stackmaxslots
							
							Code excuted here .....
							
							Post Condition: newstackpointervalue = stackpointer +1;
							
							Pop:
							
							PreCondition: stackpointer &gt;= 1
							
							Code excuted here .....
							
							Post Condition: newstackpointervalue = stackpointer - 1;
							
							For this class there are two seperate pre and post conditions for the push and the pop operator.  For push, the precondition is that at first the stackpointer must be less than the total number of slots available (otherwise we would try to push an entry onto a stack with no space left.  The post condition is that the stack pointer is incremented by one.  For the pop operator, the precondition is that the stack pointer must be greater than or equal to 1 (eg there must be something on the stack in the first place to pop).  The post condition is that the stackpoiner decrements by 1.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class SqrootAndStack
						{
						
						public StackSqrootMethod(int stackpointerposition, int stacksize)
						{
						Stack answerStack = new Stack();
						int j=0;
						for (int i=stackpointerposition; i&lt;stacksize; i++)
						{
						answerStack[j] = SqRoot(Stack[i]);
						j = j+1;
						}
						}
						}
						
						The benefits of using sqroot and stack together is that we can then find the square root of a stack of numbers rather than just passing one in as the argument.  This is a much better alternative than constantly passing values into the sqroot method.  Also using a stack manages the memory usage because if the stack is full, values must be popped from it in order to add new values to it.  It is also alot more useful having a collection of values that operations can occur on.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="49" examId="CS310105" timeTaken="7192" isSubmission="true" allImages="true">
		<compositea marksAwarded="35" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The use of inheritance is not very applicable is this case. A striker or defender, even though are footballers in themselves, should not constitute different classes - it is the role of a footballer to be a striker, or  a defender. Instead, delegation should be used:
						
						E.g.
						public class Position {
						...
						}
						
						public class Footballer {
						Position pos ;
						public Footballer (Positon iPos) {
						pos = ipos ;
						}
						}
						
						WayneRooney should not be a subclass, but rather an instant of a footballer whose positon is striker.
						
						e.g.
						WayneRooney = new Footballer(striker) ;
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This use of inheritance is not very useful. Indeed, it does give the functionality of an ArrayList to the TrafficQueue class, but the name implies a &apos;queue&apos;. This means that things will be added onto and taken off a List. And even though the TrafficQueue class will have methods relating to ArrayList usage, all the other methods of an ArrayList will be visible to the TrafficQueue class, and so funcionality could be lost.
						
						e.g. TrafficQueue has the method addEnd(Object), which adds an object to the end of a queue, but other methods, such as add(Object, int) would add an object to an arbitrary postion in the queue.
						
						An alternateive would be to use paramaterisation, using a List (or ArrayList) to store the implementation privately.
						
						e.g.
						public class TrafficQueue {
						private List queue;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Here, the is-a-kind-of test partially succeeds - a Mobile Phone and Digital Camera are pieces of electronical equipment, in real life and in this question. The abstract superclass is largely apt because certain aspects of the technology will be common, e.g. size, battery, etc.
						
						The CameraPhone as a sublass of both MobilePhone and DigitalCamera is not very applicable, because a camera phone is not really a sublass of both - it contains features of both. An alternative could be:
						
						public class CameraPhone {
						private PersonalElectronicEquipment extraFunc0;
						private PersonalElectronicEquipment extraFunc1;
						public CameraPhone(PersonalElectronicEquipment digicam, PersonalElectronicEquipment phone) {... }
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Inheritance here is attempting to enable the class Book to have the functionality of being able to be copied by means of subclassing it from Copyable (as well as InformationSource, as it is a pieceof information). The InformationSource superclass is most likely viable, because a book is a source of information. But the Copyable superclass is not very applicable, because a book is not really a Copyable object - it is an object that can be copied.
						
						Instead, if Book objects are to be copied, they should be able to be passed asarguments to a method within Copyable. Copyable would then be repsonsible for the actual copying, which would make sence.
						
						e.g. public class Copyable {
						public static Book copyThisBook (Book iBook) {... }
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Forming an abtract superclass called Answer and sublassing it to form more specific answers, e.g. MCQAnswer, is applicable because there will be methods defined in the superclass, which enables all answers to be treated uniformly. The is-a-kind-of test also largely succeeeds.
						
						The NoAnswerProvided class, a subclass of Answer, is not very applicable. This is because a blank answer should just be an Answer with no solution - there is no real need for a seperate class to denote this eventuality.
						
						NoAnswerRequired, like NoAnswerProvided, could also bee seen as superflous. At face value, there is no real need for denoting answers that do not need to be filled in as a seperate class. Instead, say TextAnswers should be used, and be simply ignored because it does not matter weather they are filled in or not.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communicating classes / objects to form a general solution to a particular design problem.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The composite design pattern can be used in this case, by way of collecting answers together to form a sest of answers of particular questions. These questions in the form of a set can then be used by other classes to display and mark. I.e. All answers of the 2008 CS1011 online paper are collected together. These are sorted via question number and part: question 1, 2, and so on. Addtional information is also stored with each answer, e.g. library card number. Some sort of MarkQuestions class could be used, and these sets of answers can be read into and used via some sort of intermediatory data structure. These answers could be displayed to the marker, possibly many at a time. Information that needs to remain annonymous, e.g. Name, can be hidden and thus not be shown to the marker. Since multiple answers could appear on the screen, and the legibility of handwriting no longer needs to be taken into account, the marker&apos;s consistency, let alone mood, could be improved.
						Answers can also have a mark associated with it, so that when the marker deicdes what value is appropriate, it can either be stored directly with that answer, or stored in some sort of other data structure (i.e. intrinsically - the former, or extrinsically - the latter).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						The Flyweight design pattern could be used because answers are not always veyr open/ended. There could be an eventuality that there are many different immutable kinds of answers that are regularly used. In such a case, this design pattern would be very apt, because otherwise lots of space (i.e. memory) would be wasted creating new small identical objects constantly - especially with Java! This pattern would instead create only a single object that would be used via a factory class, and thus if the same small object is to be used again, the same object reference is used.
						
						Another design pattern that could be used is the observer pattern. This pattern is defined using two types of objects: observables, and observers. Observables are objects that can change their state at a given time, e.g. a button, camera. Observers watch (or observe, as the name implies) observable objects for any changes in state, e.g. securityProgram. This pattern is applicable here, because answers that have been entered need to be constantly &apos;backed-up&apos; so that the user can switch between answers, and that ansers entered are not lost even in extreme cases, e.g. power failure, connection loss. Classes could be made, so that text could be entered into a textfield - this would be an observable - and thus polled at regular intervals by other parts of the program - observers - and then new information is present, it is saved at the server&apos;s side.
						
						Another design pattern in the Null-Object pattern. This pattern changes how systems that could check for null objects, be replaced with dynamic binding. It is very applicable in this case, because there will be a range of different answers that need to be marked. e.g. c programs, and Java programs. A correct, yet most likely wasteful, in terms of performance, marking program would check for the presence of different answers e.g. if(CAnswer!=null)then...else if(JavaAnswer!=null).... Dynamic binding could repace this: e.g. str = anwser.getType(); this.calc(answer, str); ...    . Dynamic binding could cost in terms of performance slightly, as method calls could be made to either sub- or super-class, but it would be negligable compared to the performance increase from not comparing nulls.
						
						A fourth design pattern that could be used is the factory pattern. This is not the same type of factory as mentioned above in the Flyweight pattern, but rather it is more similar tot he Null-Object pattern. As mentioned in that particular pattern, answers could be treated the same way. But the marking classes could be contstructed in a different manner - a differnt class for the differnt marking scheme, e.g. An abstract super class CodingMarkingScheme, with JavaMarkingScheme and CMarkingScheme as subclasses. CodingMarkingScheme objects can be used by classes in the same way, and particular implementations that need to be used can be chosen by dynamic binding. Different marking schemes for different programming languages can be made, and thus it is a &quot;factory&quot; based on the one super-class.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<compositea marksAwarded="7" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts are useful because they can be used to prove the correctnes of the system, and in this case, classes of my library. Proving correctness is very useful because it can guarantee to an extent, how the classes will behave according to the specification. Contracts can take the form of pre-conditions (P) and post-conditions (Q), e.g. P = A ^ (B | ¬C). Given the proper P for a particular method, the class would yield the proper state according to the Q. This would prove my method is correct, by the contract. Correct methods of my classes would always execute given the proper P, and would always give the proper state according to Q, as long as P was fully satisfied. In a server-client relationship, P is useful for the server, but obligated by the client. Q is useful for the client, but obligated by the server.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							//class finds sqrt of number
							public class SqRoot {
							private Stack numbStack = new Stack();
							// stack to store numbers
							private double iNumb;
							private result;
							
							public SqRoot (double input) {
							iNumb =input;
							calcRoot() ;
							...
							}
							
							private void calcRoot() {
							try {
							assert checkNumb();
							//check preconditions
							...
							numStack.push(i);
							...
							i = numbStack.pop();
							}
							catch {...}
							assert checkResult() ;
							}
							
							
							public int getResult() {
							try {
							...
							assert checkResult();
							return result;
							} catch{..}
							}
							
							private boolean checkNumb() {
							return iNumb&gt;0 ;
							}
							
							private boolean checkResult() {
							return result&gt;0 ;
							}
							
							
							}
							
							//class maintains stack of numbers
							public class Stack {
							private LinkedList stack ;
							private int maxPtr;
							private int currPtr;
							
							public Stack () {...}
							
							private void push(int i) {
							try{
							assert checkCap();
							assert checkNeg();
							...
							assert checkCap();
							assert checkNeg();
							}catch{...}
							}
							
							private double pop() {
							try{
							assert checkCap();
							assert checkNeg();
							...
							assert checkCap();
							assert checkNeg();
							}catch{...}
							}
							
							private boolean checkCap() {
							return currPtr&lt;=maxPtr;
							}
							
							private boolean checkNeg() {
							return currPtr&gt;=0 ;
							}
							
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The program I have created only evaluates the square roots for positive (non negatve or zero) numbers. A SqRoot object can be created, using a number as a parameter for its constructor. This number should be the number whose square root is wanted to be found. The contrcutor uses a private method to evaluate the result. A private Stack object is used tp hold numbers. An assert are used to check the correct pre-conditions of the method, with exceptions caught via try and catch blocks. Another assert is used to check the post conditions. Asserts have taken the form of method calls, because it is easy to evaluate something that may be needed to be evaluated many times as a seperate method. This can also help seperate and identify assertions. The use of asserts is very beneficial because it should guarantee that if the pre-conditions are satisfied, a result should be calculated, and yield a state according to the pos-conditons.
						
						The Stack Object uses an private linked list and has push and pop methods. Here, asserts have been used as method calls to check the internal pointers and structure of the internal list. The asserts as pre- and post-condtions are beneficial because the list will not &apos;break&apos; by having pointers that are outside the list&apos;s scope. This ensures correct operation when values are used.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="50" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="24" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a good way of implementing this inheritance, however, a better way would be to use roles. e.g striker is-a footballer works but sriker is-a-role of footballer is a better implementation.
						public class PersonalDetails {}
						public class Role{}
						
						public class Defender{
						PersonalDetails pd;
						Role r;
						}
						This is an example of delegation.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is an example of implemetation inheritance. It is where a name is converted into a value. Inheritance is the best method of representing this method because the ArrayList can be of any positive value and can even be the value 0. If not, we would have to make sure that the ArrayList could take a value of zero or in other words it would not need a value. The super class does not need to be an abstract class because every instant of TrafficQueue will be an instance of ArrayList.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The super class needs to be abstract so that the subclasses can inherit common properties. However, there is an improper use of multiple inheritance. Java does not support multiple inheritance. Therefore CameraPhone cannot inherit MobilePhone and DigitalCamera. Another method which would work would be the use of delegation. A CameraPhone has-a MobilePhone and CameraPhone has-a DigitalCamera.
						
						public class Cameraphone extends PersonalElectronicEquipment{
						MobilePhone mp;
						DigitalCamera dc;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Firstlt the class Book cannot inherit 2 classes InformationSource and Copyable, because Java does not support multiple inheritance. Parametisation can be supported here. Book would still inherit InformationSource but Copyable would be a parameter.
						
						public class Book extends InformationSource{
						Copybook copybook;
						public Book(Copyable c)
						{
						copybook = c;
						}
						}
						
						The class copyable can be an abstract class because it only would copy the instance variable and not the objects.
						public abstract Copyable{
						public Object copy() {}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Online exam system is just like having a Composite questions where there are sub-questions and possibly sub-sub-questions. This inheritance passes the is-a test. e.g MCQAnswer is-a(n) answer. This would not need parameterisation or it does not pass the has-a test so delegation is not needed. The Answer class should be abstarct because it only needs to contain instance variables and not instances. It contains the common properties that each of the subclasses need.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation hides the implementation of modules by an interface. An interface is an abstract data type. It allows information hiding by an interface from clients. An Java specific interface is a construct that is designed to contain methods or operations that are made available to a class. A class can implement a number of interfaces. Abstraction is the modelling of the behaviour or functionality of modules or classes. Encapsulation and abstraction are linked by the fact that a system can be decomposed into highly cohesive but loosely couple modules. Cohesion is the functional relatedness of entities within a module and coupling is the interdependency between modules. This can only occur if encapsulation and abstraction occurs. Encapsulations allows modules to be more loosely coupled. This is all fundamental to OO sortware development because OO supports robustness and correctness of the program.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation has a role because the information to be used is chosen at runtime. This works well in heritance. If there is the same method that is present in two subclasses, it is decided at runtime which of the two will be executed. This improves performance and complexity of the program.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation can help with manual storage management especially in C++ where the heap and stack are managed. Encapsulation keeps the information and use of the stack and heap hidden from the user. The stack however is maintained by the user. Encapsulation prevents the actually showing of the stack even though the user manages it. When variables and methods are put on the heap, the user does not need to be involved and when they are no longer needed and become garbage the user does not know either. This is all done because encapsulation hides the information.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is a prerequisite for Design by Contract. Design by Contract is a formal agreement between classes and its clients. They both have rights and obligations they have to honour. They reponsibilites they have to keep to prevent the contract from being violated and therefore an Exception occurring. There are always preconditions and postconditions that all methods in the class has to obey. The method can only execute if it is in a state where the precondition is satisfied and the method will terminte if the state satisfies the postcondition. The precondtions binds the client and the postcondition binds the supplier or the class. Encapsulation allows certain information to be hidden from the clients. This would need to be part of the contract, so that the client is aware of the classes rights to prevent the client from having access to certain operations. OO provides the need for robustness and correcness of the program.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It is the pattern of communiction of classes and or objects which can be customised to solve a general design problem in a particular context. A design pattern is a reusable design.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Composite design patterns can be used because an exam is like composite questions where they can have sub-questions or even sub-sub-questions. Another example which will help the explanation is that there are sub-pictures within a picture. Composite design patterns are the most common patterns used because they are efficient at run-time and they can use subclasses which is where the main implementation occurs. We need compostite pattern when instances that are all similar behave in a uniform manner and they all understand the same method. Therefore, which ever answer a candidate gives, the software will perform the same way.
						
						It allows values to be passed at run-time. It supports abstraction creation objects.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Singleton pattern: This is where at most one instance can be created. There are times where an instance will not be created and with reference to the exam software this is when an answer has not been submitted. Some questions may be multiple choice, therefore only one instance is needed and it may or may not be correct. On concurrent environments 2 instances can be created.
						
						Can use an algorithm i.e. the strategy and visitor patterns.
						
						Factory Method: This adopts the means of having subclasses which takes care of a lot of the implementation of the software. It has a factory class.
						
						Observable patterns: This is used when there is a reactive system. Reactive systems are much harder to build and implement than sequential ones. Therefore Observable patterns are needed which determine the difference between the Observable object and Observer object. The pattern allows the relationship to be distinguished between the two by having a flexible manner. The Observable object is when a state can change at an unpredicatble time and the observer object is interested in this change. This can be used in this software when the answer changes or when a button on a GUI is pressed. It has its many uses. E.g a multiple choice answer ox is clicked on, therefore the state changes and the observer object watches this change.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="51" examId="CS310105" timeTaken="7166" isSubmission="true" allImages="true">
		<compositea marksAwarded="48" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is an incorrect use of inheritance. It may pass the IS-A test, for instance a Striker is a footballer, and WayneRooney is a striker, however these are just roles played by the classes, and Wayne Rooney plays the role of a Striker. These roles can change. For example, during a game, WayneRooney may end up playing the role of a midfielder, or even a defender, depending on the situation, and outside of a game of football he plays many other roles. Therefore, this hierarchy could be shown as:
						
						public abstract class Footballer {
						
						Footballer [] role; // the set of roles of this particular player
						}
						
						public class WayneRooney extends Footballer {
						
						Footballer [] role = { Striker };
						// other code
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a fairly poor use of inheritance. This now exposes the implementation of a TrafficQueue class to any of its clients (they now know that the TrafficQueue class uses an ArrayList). In particular, if the data structure used by the TrafficQueue class changes, then there is the problem that any previous clients of the TrafficQueue class may stop working correctly. Also there is the problem that the code may have to be changed.
						It may appear to be a sensible use of inheritance however, if we just consider the IS-A test, as a TrafficQueue is an ArrayList.
						A sensible option may be to use the notion of delegation e.g
						
						public class TrafficQueue {
						private ArrayList list;
						// code for dealing with the list and any other things for the TrafficQueue
						}
						
						This has the advantage that the implementation of the class is now hidden from any clients that use it.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This example introduces the idea of multiple inheritance. In Java this would not be a sensible option as multiple inheritance is not allowed, so this code would not compile. However, it could be considered as a fairly sensible approach, because a CameraPhone is a mobile phone, and it is a digital camera, so it passes the basic IS-A test for inheritance.
						We could use the idea of delegation. Typically a CameraPhone, even though it has DigitalCamera capabilities, may be considered as a MobilePhone first, and then as a DigitalCamera e.g.
						
						// other classes stay as above
						
						public class CameraPhone extends MobilePhone {
						
						// an array to store the other capabilities of this phone
						public PersonalElectronicEquipment [] capabilities = {DigitalCamera};
						// other code for CameraPhone
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this example, the idea of multiple inheritance arises again. However this is probably less sensible than the use of MI in the previous part (Question 1.3). We want book to be Copyable, rather than contain a copyable object. It is sensible with respect to it passes the IS-A test (a book is an information source, and a book is copyable). However it may be better if the Copyable class was declared as an interface.
						
						e.g
						
						interface Copyable {
						
						public Object copy ( ) { ... }
						}
						
						public class Book extends InformationSource implements Copyable { ... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is probably a poor use of inheritance. It is sensible with respect to the MCQAnswer being an Answer (there is the IS-A relationship), and the same for TextAnswer. However, it is highly dubious to have the class NoAnswerProvided, as there is unlikely to be any information other than the fact there was no answer provided. Therefore it is possible to use the idea of parameterisation. The fact that there was no answer provided, be stored as a parameter in the MCQAnswer, and the TextAnswer questions. Also for NoAnswerRequired, this could also be a parameter in MCQAnswer, and TextAnswer. Eg:
						
						public class TextAnswer extends Answer {
						private boolean noAnswerProvided;
						private boolean noAnswerRequired;
						// then code to set these variables. E.g. if the question wasn&apos;t used, set noAnswerRequired to true. Or if the text box text was null then set noAnswerProvided to true. When marking the exam check noAnswerRequired first.
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a set of communicating classes and/or objects which can be customised to solve a general problem in a specific context.
						It is an approach to solving non-trivial problems, which has been deemed to be the best approach.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The Composite design pattern can be used anywhere where there is a hierarchy between the objects. The Composite design pattern allows us to combine basic objects in some particular manner to form a new object that is made up of these basic objects. For example, in this software we may have the notion of a CompositeQuestion. This question could be made up of a TextualAnswerQuestion, a MultipleChoiceQuestion or a FillInTheBlanksQuestion.
						For example:
						
						public class CompositeQuestion extends Question { // top level class is assumed to be Question
						{
						private Question [] parts = { //whatever parts };
						int sizeOfArray = // some value
						int getMarksAllocated()
						{
						for (int i = 0; i &lt; sizeOfArray ; i++)
						{
						Question bit = parts[i];
						marks = marks + bit.getMarksAllocated();
						}
						return marks;
						}
						
						}
						
						Therefore when it comes to marking, the totals for each of the specific sections can be totalled up. For example, by using the composite pattern, if the question was made up of a multi choice question, and 2 text answer questions, then we could add up the marks for the multi choice question, and the 2 text answer questions, this would work. We use the notion of dynamic binding to access the appropriate parts.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Proxy Pattern (or Remote Proxy pattern)
						
						This exam software, since it will be created as an Applet, can be used anywhere in the world. This would mean that the applet is running on a server somewhere out in the world. We would like to create the illusion that everything is local. Therefore, we could use the Proxy pattern. Therefore, if the user clicked on Finish Exam, it could invoke the Finish Exam method, which is actually just a stub. This then delegates the behaviour to the real object (probably on the server), and this then returns the appropriate message to the applet. This can therefore create the impression it was all done locally (i.e that the program was running on the particular computer).
						
						
						Singleton Pattern
						
						The singleton pattern could apply to this situation, because we only want the one instance of the Java program to be in use at one time (for the computer). This could be insured by:
						
						public class MarkingSoftware {
						
						private MarkingSoftware instance = null;
						
						private MarkingSoftware () { ... }
						
						public MarkingSoftware getInstance() {
						if (instance == null ) instance = new MarkingSoftware();
						return instance;
						}
						
						This way we only have one instance of the marking software at one time, or none at all if it is not required. Also the singleton approach may be used to ensure that only one instance of a specific user is logged in to the system at one time. So if user 123456 was logged in, and tried to log in to the program from another machine, it would not work, or at least would give exactly the same instance as the first instance.
						
						Observer Pattern
						
						In this exam there may be some multiple choice options, or tabs may be used (i.e if there are 5 questions and the student only has to answer 3, he can choose which question to look at by clicking on the appropriate tab). Therefore by using the Observer pattern it will be possible to have some sort of a listener to check for events, so for example, a user clicked on tab 3, the software could show Question 3. Also, when the user clicks on a Finish exam button, it can be sent to the server, ready to be marked. There may also be an observer, that is monitoring the time remaining, so that when the time runs out, the exam can be sent to the server.
						
						Factory Method Pattern
						
						The same exam software may be used for different modules (obviously with the questions set for the particular module), and when it comes to marking it may be unclear which particular MarkingSoftware class to use (for instance ObjectsComponentsPatternsMarking class, or HistoryOfModernArtMarking class?). Therefore by using the Factory Method pattern, we can use the idea of dynamic binding. Therefore at run time, the appropriate MarkingSoftware program is created, and we don&apos;t have to change the MarkingSoftware class. The idea of dynamic binding also means we don&apos;t need as many if statements (for example if we used a discriminator to indicate the type of exam that was to be marked, we&apos;d need to test this discriminator using if statements).
						
						public abstract class MarkingSoftware {
						
						public abstract getTypeOfExam();
						}
						
						public class ComputerScienceMarkingSoftware extends MarkingSoftware {
						// code for getting the appropriate exam etc
						// and code for starting up the right marking software etc.
						}
						
						This way if a new exam uses the software, we can just add a new subclass.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<compositea marksAwarded="14" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							The purpose of contracts is that it binds the client (the user of the classes in the library), and the class library. The idea of design by contract can assist in software correctness. It would be defined with the idea of preconditions, postconditions, and class invariants. If the client can satisfy the precondition, then the particular class in the library will provide the right solution (i.e something that will satisfy the postcondition). Therefore, we have something along the lines of:
							{ Precondition } Code (can be an entire method or single operation ) {Postcondition}
							
							Only if the precondition is satisfied will the code be executed. If the precondition is satisfied, the code will execute, and the class guarantees that the postcondition will be satisfied.
							
							In Java the preconditions and postconditions could be defined by the assert keyword.
							For example:
							assert (x &gt; 10) // this tests to see if x is greater than 10. If it is, nothing happens, however if x is less than 10, an AssertionException is thrown.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="10" isMarked="true">
						<answerString>
							For the stack class there&apos;d be several attributes for managing the stack, including capacity, and the current number of elements. There&apos;d also be several methods, including push (for adding on to the stack), and pop (for removing from the stack). There may also be a method for checking for empty. So the class may look like:
							
							class Stack
							{
							private int capacity  = // whatever
							private int currentNumberOfElements = // whatever
							// constructor code not given
							
							public push ()
							// this has the precondition that the currentNumberOfElements is less than the capacity
							// it has the postcondition that the currentNumberOfElements is updated, and the stack is updated
							
							public pop ()
							// this has the precondition that the stack is not empty i.e assert (testForEmpty ()== false) i.e stack not empty
							// it has the postcondition that the currentNumberOfElements is updated, and the stack is updated
							
							public boolean testForEmpty ()
							{
							if (currentNumberOfElements == 0)
							{
							return true;
							}
							else return false;
							}
							}
							
							This would have a class invariant that says the currentNumberOfElements is greater than or equal to 0, and less than or equal to the capacity. This would have to be true for all instances of the stack class, and in all observable states. The class invariant could be checked by having a private method testForFull() which returns boolean, and using testForEmpty. These can be called from within the push and pop methods to check that the invariant still holds true.
							
							For the SqRoot class, we may have the precondition that the number is greater than or equal to 0, as the square root of a negative number gives a complex number solution. We would want the postcondition to say that it will return the correct answer (but obviously, only as long as the precondition is satisfied).
							
							class SqRoot
							{
							int numberToRoot;
							float answer;
							
							public int returnRoot()
							{  // calculations to return the root;
							this method has the precondition that numberToRoot is greater than or equal to 0;
							i.e assert (numberToRoot &gt;= 0)
							this method has the postcondition that answer is the square root of numberToRoot, and that this is the                 number returned by the method.
							}
							}
							
							However, if the method for calculating the square root was public, it is possible that there would be some explicit checking (i.e exception handling - generating explicit exceptions), and therefore any preconditions can be weak, or there could be no preconditions at all. If the code was private, then it would be making the assumption that the values passed satisfy the requirements, then the preconditions should be very strong.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The benefits of using SqRoot and Stack is that they have been developed with the idea of Design-by-Contract in mind. As a result, if our program (which is also to be designed using Design-by-Contract), uses these classes, we can be confident that it will return the correct result. This is because the designers of SqRoot and Stack have assured us, that as long as we pass the correct values, so that the preconditions are satisfied, we will get a postcondition which is correct.
						
						This particular program could then build a stack of numbers, and then for each value in the stack, pass this value into the SqRoot class, to get the solution. E.g
						
						class SquareRootFinder {
						Stack myStack;
						// this program then gets a value from the stack.
						// it then passes this value as an argument to the SqRoot class
						// a value is returned from this class, and is given as the answer
						}
						
						We can use assertions to guarantee the number on the stack will be greater than or equal to 0.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="52" examId="CS310105" timeTaken="6809" isSubmission="true" allImages="true">
		<compositea marksAwarded="23" isMarked="true">
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this example there could be more than one instance of a footballer created at one time. For example, a wayneRooney object could be both a striker and a WayneRooney. This is a bad use of inheritance. A better way of doing this would be to have a WayneRooney class that delegates to the Striker class and extends Footballer.
						
						public class WayneRooney extends Footballer{
						
						Striker rooney = new Striker();
						
						rooney.shoot();
						rooney.dribble();
						
						// new type of shot specific to WayneRooney
						public superShot(){
						
						.....
						
						}
						
						.......
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This example is not that sensible because TrafficQueues are not always ArrayLists therefore it fails the is-a test. This is because sometimes cars can leave the middle of the queue and be added to the queue via junctions in the road. Therefore it would be better to inherit from a LinkedList class which would allow the easy removal/addition of objects to the TrafficQueue:
						
						public class LinkedList{....}
						
						public class TrafficQueue extends LinkedList{.....}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this example it is not true that a CameraPhone is both a MobilePhone and a DigitalCamera. Every camera phone is not necessarily a digital camera. It could be said though that a CameraPhone has-a DigitalCamera. In this case i would have CameraPhone inherit from MobilePhone because it does exhibit all the properties of that class, but use delegation to call some of the relevant methods from DigitalCamera. This removes the need for multiple inheritance:
						
						public class CameraPhone extends mobilePhone{
						
						DigitalCamera camPhone = new DigitalCamera();
						
						camPhone.takePhoto();
						
						......
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this case not every book may be copyable and so it fails the is-a test. In order to get around this I would create a new class CopyableBook which extends Book:
						
						public class Book extends InformationSource{ ..... }
						
						public class CopyableBook extends Book { ..... }
						
						I would then use delegation to call the copy method from the public class Copyable. This also removes the need for multiple inheritance.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						In this example there is a clash because an answer that is not required would also not be provided so there could be instantiations of the same answer twice. This is very bad. To counter this I would have the NoAnswerRequired class extend from NoAnswerProvided class. Also it might be more useful if there were 2 seperate classes for NoAnswerProvided, one which extends MCQAnswer and one which extends TextAnswer.
						
						public class NoMCQAnswerProvided extends MCQAnswer{ ..... }
						
						public class NoTextAnswerProvided extends TextAnswer{ ..... }
						
						public class NoMCQAnswerRequired extends NoMCQAnswerProvided{ ..... }
						
						public class NoTextAnswerRequired extends NoTextAnswerProvided{ ..... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation is necessary for abstraction because it hides the implementation of a class from the interface. An example is having an interface for Mark which is concerned with the marks for an exam. A user may wish to get his or her marks for a semester by using the getMarks() method, passing the semester number as a parameter. Each semester may have a different way of calculating the mark but this is hidden from the user and the correct result iis returned via  direct binding.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation can improve runtime performance because it is a way of achieving modularisation. This is where objects have high cohesion but low coupling. Due to the low coupling it is unnecessary to make lots of calls to other classes which helps to improve performance. If there was a class which requires lots of information from other classes which gather information from outside data at runtime, for example a weather monitoring system which needs values for air pressure etc. from lots of different stations in different regions, then this would be slow if the stations were strongly coupled. Each station, for example, needed the values of all the surrounding stations&apos; air pressure to calculate its own.  However if the stations gathered their information just from their own station to get the weather for that region and then combined their results later then it would be much faster.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Encapsulation can improve runtime performance because it is a way of achieving modularisation. This is where objects have high cohesion but low coupling. This means that because of low coupling classes do not rely on each otheras much and so addition and deletion of objects can be done relatively simply without have to worry about whether an object is being referenced by another object. An example of this is having seperate classes for different models of a car in production. When an old car is no longer in production then it can be deleted without having to make any alterations to the other cars. The same could be said for adding new models, none of the other models would be effected.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Because of encapsulation the user does not know how or if the end product provided by the supplier is going to work because he or she isn&apos;t able to see the way the product is designed. This means that it is necessary to provide some form of formal agreement that if the the user provides a specification the supplier will guarantee that that specification is fulfilled by the product. An example of this is if a user wanted some software that provided him with the latest football results. He would write a specification that stated what he wanted from the software, such as updates of goals when they are scored and the supplier would provide the implementation. However in this case the specification is vague as it does not restrict to certain clubs or leagues etc. and so the supplier would probably comment on this asking for a better specification.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern for communicating classes in a general way that can be applied to a specific situation. It is a way of abstracting the thing that varies so that when the thing that varies varies nothing is changed.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Due to the fact that there is a hierarchy of classes where both superclasses and subclasses may need to be instantiated the Composite Pattern could be used. For example an Answer class may be the superclass form which MultipleChoiceAnswer and TextAnswer inherit. But there may be also a class which also inherits from Answer but delegates some functions to TextAnswer. The Composite design pattern would provide a way of controlling the instantiation of objects of the different classes, detrmining which objects would be most appropriate.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The FlyWeight pattern could be used because it is concerned with reducing the number of objects that are created. In this example of the Exams there will be many objects, such as MultipleChoiceAnswers which are the same( i.e. A, B, C, D). Rather than create seperate objects for each answer the FlyWeight pattern creates one object for A, B, C, D and creates lots of refernces to them.
						
						The Visitor patern could be used for questions split into sub-parts e.g. question 1a), 1b) etc. In order to get the marks for the answer to question 1 it would be necessary to visit the answers to 1a), 1b) etc. and add them up. This pattern provides a way of doing this, it goes through all the classes that are relevant to a particular algorithm (in this case the totalling of marks) and puts them all in one class.
						
						The Strategy pattern could be used because different schemes may be needed to mark certain questions, e.g. some questions may be marked by different examiners, some may be marked using the Human-Computer Collaborative manner. The Strategy pattern selects the correct method to use for each particular case using the Factory Method.
						
						The Factory Method pattern could be used because it is concerned with instantiating classes. This could be used in combination with the Strategy pattern to decide which class is needed to be instantiated to provide the correct implementation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="53" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="44" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Having an abstract class Footballer with subclasses for the particular kinds of footballer seems sensible enough, however I suspect (my knowledge of football is limited) that these are roles for a footballer and that a given footballer (a given instance) may be a Striker sometimes and a Defender at other times. Therefore it would be better if this was represented in the state of the Footballer.
						
						public abstract class Footballer
						{
						private static final int DEFENDER = 0;
						private static final int STRIKER = 1;
						private int mode;
						
						public void changeToStriker()
						{
						mode = STRIKER; //avoids having a problem with clients passing incorrect ints and the extra work of typesafe enumerations
						}
						}
						
						The WayneRooney class is confusing classes and instances. I&apos;m fairly sure there&apos;s only one Wayne Rooney and so he should be an instance of Footballer (with default mode = STRIKER).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						It may be true that a TrafficQueue is a list in some sense and that most of the operations of ArrayList apply to TrafficQueue, however, this exposes the whole of the ArrayList interface to the clients of TrafficQueue, which is probably not what was intended. In particular, if the TrafficQueue introduces extra class invariants, for example, that it contains only Vehicles, methods in ArrayList which have not been overridden will break this invariant. A better solution would be to have TrafficQueue contain an instance of an ArrayList and only expose the methods required.
						
						public class TrafficQueue
						{
						private ArrayList list; //should possibly use a List also
						
						public void add(Vehicle v)
						{
						list.add(v); //delegate
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This appears sensible, however, it is not necessarily the case that MobilePhone and DigitalCamera are truly disjoint. For example, they both have a battery and both probably have a screen. Does this mean that a CameraPhone has two batteries? The camera phone may end up with two of everything defined in PersonalElectronicEquipment. It would be better if the superclasses were interfaces, along the lines of:
						
						public abstract class PersonalElectronicEquipment
						{
						private Battery battery;
						//...
						}
						
						public interface MobilePhone
						{
						public void makeCall();
						//...
						}
						
						public interface DigitalCamera
						{
						public Image takePhotograph();
						//...
						}
						
						public class CameraPhone extends PersonalElectronicEquipment implements MobilePhone, DigitalCamera
						{
						public void makeCall()
						{
						//does the expected things
						}
						
						public Image takePhotograph()
						{
						//...
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The class Copyable should be abstract, since it presumably has no instance variables itself. It appears that Copyable is being defined as a class because a default implementation of copy() is required, and methods in java interfaces cannot have implementations, hence the need for abstract classes. It is more usual in java to have these kinds of things as interfaces and not provide a default implementation, or have the default implementation built into Object. For example:
						
						public interface Copyable
						{
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable
						{
						public Object copy()
						{
						//...
						}
						}
						
						Of course, it would have to be done this way in java, because java does not support full multiple inheritance.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The use of an abstract superclass Answer with subclasses MCQAnswer and TextAnswer is sensible. Having NoAnswerProvided and NoAnswerRequired subclasses is not as good a use of inheritance. For example, what if we needed to know whether an instance of NoAnswerProvided came from a question where a TextAnswer would have been the alternative? These two subclasses could be boolean instance variables defined in Answer.
						
						public abstract class Answer
						{
						private boolean noAnswerProvided; //or conversely, answerProvided
						private boolean noAnswerRequired; //or answerRequired
						}
						
						This way we can still tell what kind of answer it was supposed to be, and it would be a simple check to see if no answer was provided.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a common solution to a general problem as observed by experienced programmers. Coupled with a name and an example, it is a way of communicating knowledge to inexperienced programmers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The composite design pattern could be used to define the questions in an exam. Given an abstract class Question
						
						public abstract class Question
						{
						}
						
						subclasses for atomic questions (that is, those without subparts) could be defined
						
						public class MCQ extends Question
						{
						}
						
						public class TextQuestion extends Question
						{
						}
						
						along with a composite question which can have subparts which are questions. The CompositeQuestion extends Question so that questions can be nested arbitrarily.
						
						public class CompositeQuestion extends Question
						{
						private Question subquestions[];
						}
						
						Finally, an exam is a kind of CompositeQuestion, so
						
						public class Exam extends CompositeQuestion
						{
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						The proxy design pattern, specifically the remote proxy pattern, could be used to abstract away the details of communicating with the exam server. The applet would contain a ExamServerProxy which would extend an abstract superclass or interface ExamServer, and the server would be running a RealExamServer. The ExamServerProxy would have exactly the same methods as the RealExamServer, and so the applet does not need to know whether it is calling methods on the local or remote servers. Each method in the proxy would call the corresponding method on the server, via some network protocol, possibly by RMI.
						
						The marking system could use the strategy pattern. Each of the presentation strategies would be defined in a subclass of some abstract PresentationStrategy, and the software could switch between them at runtime. Most of the code would not need to know which strategy was being used, since all presentation strategies have the same interface. For example, PresentationStrategy might define a method showAnswer(), and there might be a RandomPresentation strategy and a LinearPresentation strategy class. LinearPresentation would show the answers in order, but RandonPresentation would show them in a random order.
						
						Much of the client/server interaction could make use of the observer pattern. The server (or the server proxy) would register itself as an observer of the applet (or various parts of it), and when the user does something like move to the next question, the applet (the observable) would notify the observer(s) by calling a suitable method with the details of the event. The method to be called would be defined in an ExamObserver interface or something similar. The server might choose to save the user&apos;s answers at this point.
						
						The factory pattern could be used to generate the objects representing the exam (questions, GUI components, etc) at runtime. A factory method would be defined which takes some information describing what the exam contains (say, an XML string), and would instantiate the correct set of objects given that information. The applet would then call this method to generate the exam or GUI when the information is received from the server, so that the rest of the applet code is the same whatever the exam actually contains.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts are used so that the programmer can say that given the precondition, the postcondition will be true. This may be shown by formally proving the code is correct. It allows unambiguous specification of methods and classes. Contracts are defined by giving pre and postconditions for each method and by giving invariants for classes, if they are required. In java, this would be done with the assert statement, which tests a boolean condition and throws an AssertionError if the condition is not met.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							The square rooting method of the square root class would have the precondition that its parameter was greater than or equal to zero, since square root is undefined for negative numbers (if I recall correctly), and so the method could not calculate the square root in that case. For the benefit of the client, the postcondition would be that the square root value squared should equal the parameter.
							
							public class SqRoot
							{
							public static double sqrt(double x)
							{
							assert x &gt;= 0;
							//calculate s
							assert s*s == x; //ignoring rounding error
							return s;
							}
							}
							
							For the stack, the precondition of the push method would be that the stack is not full, and the postcondition would be that the method has pushed the parameter correctly onto the top of the stack. The precondition of the pop method would be that the stack is not empty and the postcondition would be that it has popped correctly, that is, the top of stack pointer has been decremented.
							
							public class Stack
							{
							private int items[];
							private int stackTop = -1; //full ascending
							
							public void push(int x)
							{
							assert stackTop &lt; items.length-1;
							int oldStackTop = stackTop;
							items[++stackTop] = x;
							assert stackTop == oldStackTop + 1 &amp;&amp; items[stackTop] == x;
							}
							
							public int pop()
							{
							assert stackTop &gt;= 0;
							int oldStackTop = stackTop;
							int result = items[stackTop--];
							assert stackTop == oldStackTop - 1 &amp;&amp; result == items[oldStackTop];
							return result;
							}
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						public class RootStack
						{
						public static void main(String args[])
						{
						Stack stack = new Stack();
						//acquire numbers[] from somewhere
						
						for (int i = 0; i &lt; numbers.length; i++)
						assert numbers[i] &gt;= 0;
						
						for (int i = 0; i &lt; numbers.length; i++)
						stack.push(numbers[i]);
						for (int i = 0; i &lt; numbers.length; i++)
						sqrts[i] = SqRoot.sqrt(stack.pop()); //assuming sqrts is declared
						
						for (int i = 0; i &lt; numbers.length; i++)
						assert sqrts[i]*sqrts[i] == numbers[i]; //not really required
						}
						}
						
						The benefit of using SqRoot and Stack is that you can be sure that if you provide inputs according to the preconditions of the methods you call, then you will definitely get results which conform to the postconditions. Here, the precondition of the program is taken from the precondition of the sqrt method, that is, that only positive numbers are supplied. The postcondition of the program comes from the postcondition of the sqrt method, that is, that it has calculated the correct square roots.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="54" examId="CS310105" timeTaken="6569" isSubmission="true" allImages="true">
		<compositea marksAwarded="47" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Striker and Defender here represent roles played by people rather than immutable &quot;objects&quot;. It is not uncommon for a football manager to change the positions that players play in any given game-although it will not happen at every game it is still a possibility.For this reason ie possible change inheritance is propably not the best solution. The alternative would be to use delegation so that an instance of class Footballer would contain the required information :
						
						public class Footballer {
						
						Position Defender
						String name
						
						}
						
						where name could be WayneRooney
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of implementation inheritance-we want the functionality of ArrayList to be used in our TrafficQueue class. Inheritance here is not wrong per se-we will achieve what we want.However there are a number of disadvantages. We might not want to use all of the methods in ArrayList but there is no way to hide them. The class might contain a lot of other methods making the ArrayList a small part of the overall design. It will be more clear and efficient to use delegation :
						
						public class TrafficQueue {
						
						List ArrayList
						...
						}
						
						This can also be made type-safe.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						MobilePhone and DigitalCamera do pass the is-a test and inheritance is a sensible way to model them. Using multiple inheritance in the third example however can be problematic. We might have conflicting attributes as ,for example, data such as battery life will exist both for MobilePhone and DigitalCamera. Which of the two will be used for CameraPhone?  It would be better if CameraPhone just extended the abstract class like the two above:
						
						public class CameraPhone
						extends PersonalElectronicEquipment {...}
						
						Although we would have to add code describing the functions of both a camera and a phone if the shop/manufacturer  requires it
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Copyable can be thought of more as a property of Book than an instance. Although we can say that &quot;a Book is-a copyable&quot; that&apos;s a pretty shaky test-especially since copyable describes something that the book HAS. Since we require the functionality of it however,we can use interface inheritance. Inheritance might be ok but it&apos;s not as clear-cut as an interface and adds unnecessary complications.So we could write this as
						
						public interface Copyable {
						
						public Object copy{...}
						}
						
						public class Book extends InformationSource implements Copyable{...}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first two examples of inheritance are ok. The third example is not since it does not really describe a category or type of answer-merely a non-attempted or blank one. I believe it could be modelled as a method
						
						public boolean blank(Answer  a){...}
						
						which will be included in the abstract class to test whether the question has been answered or not.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is the pattern of communicating classes and objects in order to solve a general problem presented in a particular context
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Although we will have different types of questions(and answers) all of them must understand the same messages such as getMarks() or markStyle(). We will therefore follow the Composite pattern by having a number of abstract classes (such as Question and Answer) with each one having a number of concrete sub-classes. Question can have sub-classes such as CompositeQuestions and MultipleChoice question with corresponding subclasses for the Answer class. The main idea behind the Composite pattern is to use dynamic binding to obtain the result of sending a message to any of the classes without explicitly checking which of the subclasses that is. A composite answer will contain a collection of Answer instances for example-they can be MultipleChoice ones, Diagram ones etc. By sending the single message  a.getMarks()to each of the instances in this collection we will get the required result-with the method recursively working through the collection that any of the instances might have. The pattern thus provides an efficient way to run the marking.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						a) The Observer pattern can be used. Obviously at some point the user will need to send some kind of message to the server that he has finished the exam. A login and password might also be required to be sent to the server. Using a GUI, this will propably involved pressing buttons. So events will be generated on the user side (by Observables)and listeners (Observers)on the server will detect them and take appropriate actions.
						
						b)The Proxy pattern might be used so that client-server communication is handled.The user program will delegate the functions relating to the communication over the Internet to a proxy object and that in turn will forward the user messages to the actual server.
						
						c)The Strategy pattern can be used in the marking process-since we are told that the computer will need to present the information in a number of ways to the marker. A &quot;presentation function&quot; can be used with its subclasses structuring the data according to a  number of criteria specified as parameters Eg with keywords highlighted
						
						d)The singleton pattern can be used to handle security and transaction processing.For example we can represent a session as a single object and we don&apos;t want more than one session object saving the exam data onto the server disk drive at any given time.So by using singleton we ensure that this is the case.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="11" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts improve the reliability and inter-operability of classes in a given library by reducing the possibility of run-time errors occuring. This is because they define for each class (and the methods in it) a set of constraints that it must satisfy. These are the preconditions and postconditions for methods and the class invariant for the whole class. So for every method Q we have pre-condition P which ensures that q will not execute in a state not satisfying P amd post-condition R which ensures that with P satisified Q will finish in a state satisfying R.
							
							{P} Q {R}
							
							The invariant is a set of constraints that must hold for all methods in a class. These can be defined by using appropriate keywords where possible (&quot;assert&quot; in Java, &quot;require&quot; in Eiffel) or just plain &quot;if&quot; clauses
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							The class SqRoot will have a method called    double findRoot(double number) {..}
							
							The first pre-condition,that it must take a number will be handled by the compiler as it is specified in the method signature.The second precondition is that it must not take a negative number as we are assuming that it cannot return complex numbers. This can be ensured by including a line inside the method stating
							
							if (number&lt;0) return -1;
							
							This will ensure that the method will not execute instead returning a &quot;stub&quot; or error flag(-1) in this case.The post condition is again implied by the signature-the method returns a double.
							
							The class Stack will have methods double pop() throws EmptyStackException
							and
							void boolean add(double number).
							
							The method add will include a check that the stack (assuming it is implemented as an array) is not full. If it is, it will not carry out the addition.The post condition will simply be the addition of the number although it might also included the updating of a stack counter.The method pop will have a pre-condition that the stack is not empty.If it is it will not carry out the operation.The post-condition will include returning the number and updating  a stack counter.The stack counter might be considered an invariant if it is specified to be between a certain range (0-MAX).Add() will return a &quot;false&quot; flag if the pre-condition is false while pop()  will throw an exception
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Load/create the stack with a set of numbers. Declare a Stack instance as Stack st;
						Set a flag indicating &quot;normal execution&quot; Eg boolean ok=true;
						
						Then start a loop:
						
						try{
						while(ok)
						{
						Double number=SqRoot.findRoot(st.pop());
						if(number==-1){ok=false;}
						else
						{System.out.println(number);}
						} catch (EmptyStackException ese)
						{
						ok=false;
						}
						}
						
						We use the exception to signal that the stack is empty and there we stop the execution of the loop.We also print only &quot;legal&quot; square roots.
						
						The benefits of using classes using DbC(SqRoot and Stack) is that we do not have to code any explicit checks in our code-it is all taken care by each class.This obviously makes life easier as the programmer does not have to think about all the possible things that can go wrong when using an arbitrary number of classes.The only checks here concern the behaviour of the MAIN program when the method does not execute-not when something INSIDE the method goes wrong.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="55" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="51" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an example of a role problem.  A Striker or Defender are different roles that a &quot;Footballer&quot; can play. Although a striker IS-A footballer (and so the use of extending Footballer is correct), the fact that a person can play a multitude of roles which may change over time would make changing a person from &quot;Striker&quot; to Defender very difficult as we would have to destroy the object and recreate one.
						Also, WayneRooney IS-A striker, however it is not really a specialisation of a striker - namely, it is a striker with certain characteristics (via setting of properties, eg average_run_speed() ). Therefore, WayneRooney is an instance of a Striker.
						So, we should create a class Position which all positions can extend from (eg Striker, Defender etc).
						
						And create a &quot;PersonalDetails&quot; class so each person can be identified. An ideal is that each object represents one person in the real world:
						
						public abstract class Position {}
						public class PersonalDetails {
						string name;
						}
						
						eg public class Striker extends Position{ }
						
						public class Footballer{
						Position position;
						Personal Details pd;
						}
						
						Thus, we have used delegation as PersonalDetails and Position are clients of Footballer. And inheritance as Striker and Defender all have common characteristics.
						WayneRooney would therefore be an instance of Footballer with pd set to an instance of PersonalDetails (with name set to &quot;Wayne Rooney&quot;) and position being an instance of Striker.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The IS-A test fails technically. Literally speaking, a TrafficQueue is not an arraylist. It therefore should not extend it. In terms of how a TrafficQueue works, it probably uses an ArrayList to maintain a list of traffic, therefore it HAS-A arraylist, and so should use delegation.  It is also bad as all methods of Arraylist are accessible to clients of TrafficQueue which is dangerous. We are thus using ArrayList for Convenience in TrafficQueue. Also, as the functions of a TrafficQueue grow, the Arraylist will later become only a small part of the TrafficQueue class, and so it would be needless to tightly couple the two.
						
						Better:
						
						public class TrafficQueue{
						private List array;
						
						//
						}
						Here, by making it private, we can ensure that the array is never accessed directly by clients (it is only accessible via get/set methods).
						Also, by making it of type List (the interface) instead of ArrayList, we can allow that when the List is instantiated, its type can be decided later, and can be easily changed, instead of being restricted to an ArrayList.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The IS-A test succeeds, a mobile is a personal electronic equipment. However, we have that a Camera phone IS-A Mobile-Phone and IS-A Digital Camera. This is an example of incorrect use of Multiple Inheritance, as we are tightly coupling MobilePhone and DigitalCamera classes into CameraPhone class, and so all of their methods will be available. Many of these methods may not be applicable to the CameraPhone and indeed, many may clash (e.g. battery_type() method of DigitalCamera and MobilePhone may exist).
						This could be likened to the Composite pattern, whereby we define a MobilePhone to be an atomic entity (in terms of Electronic Equipment), and a CameraPhone (which has two uses - a phone and a camera) as a Composite of a Mobile and a Camera.
						Therefore, we use a mixture of inheritance and delegation to achieve a robust solution:
						
						public abstract class PersonalElectronicEquipment { … }
						public abstract class Single_Use_Electronic_Entity extends PersonalElectronicEquipment { … } //likened to &quot;BasicPart&quot;
						
						public abstract class Composite_Use_Entity extends PersonalElectronicEquipment {
						private List composite_parts; //where each entity in this List is of type &quot;PersonalElectronicEquipment&quot;.
						
						}
						Thus any dual purpose item can extend Composite_Use_Entity, whereby its &quot;composite_parts&quot; consist of objects which represent all of its constituents.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The IS-A Test fails, a Book IS-NOT-A copyable. It IS an information source however.  Again, we are tightly coupling the methods of both Copyable and InformationSource. This may not be relevant for all people - ie to a programmer, Copyable may be important to the workings of the system. However, to a Librarian, this is irrelevant.
						As an object can be copyable or not, this is a binary choice. Therefore, it would be better to put this aspect into the InformationSource class (ie use parameterisation of the constructor here as a boolean of whether this information source is copyable).  Thus we can do away with the need for the Copyable class, and also we can create special instances of Books which may not be copyable.
						
						IE
						
						public abstract class InformationSource{
						private bool copyable;
						public InformationSource (bool copyable) {}
						
						public Object copy();
						}
						
						public class Book extends InformationSource{
						
						public Book (bool copyable){
						super(copyable);
						}
						}
						
						Thus we can create Book (which is an extention SIMPLY of InformationSource), where each can be copyable or not. Instead of all books being copyable (which may not always be the case...eg reference books).
						We can also quicky and easily change the Copy method (as it will only need to be changed in one place - in the InformationSource class) if necessary. Or, if certain items have special ways they need to be copied, we can override this with a copy method when they extend InformationSource.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The IS-A test passes for MCQAnswer and TextAnswer. NoAnswerProvided and NoAnswerRequired are really special cases of answers, and one could argue that they indeed are not answers themselves.
						We could instead have NoAnswerProvided and NoAnswerRequired as being static classes as they would not ever need to be instantiated.
						This is incorrect as a NoAnwer Provided would still have a method in an answer calss such as getMa
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern is simply a way of solving a general problem in a particular context. A design pattern is therefore a specialisation of this. IE it is a way of communicating classes or objects which can be customised to solve a general design problem in a specific context. It is a &quot;tried and tested&quot; way of doing something which allows reuse of patterns which were previously too generic to code directly.  It allows patterns to be used in a variety of contexts.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The Composite design pattern is one which is used when atomic entities exist (e.g. a single question) and also a composite entity exists which formed from many atomic entities (e.g. a question with 4 sub-questions).
						It is used as it allows all objects/entities to be treated in a uniform manner as ultimately, both atomic and Composite objects inherit from the same superclass.  This makes for better code which is easier to extend, re-use and maintain (especially if new forms of question are invented). Thus dynamic binding is used as the methods of subclasses (which may not be known at compile time) are called at runtime when the actual type of question is determined.
						
						public abstract class Question {
						public abstract get_marks();
						}
						
						public abtract class BasicQuestion extends Question {
						private int marks;
						
						public int get_marks() { return marks; }
						}
						
						public abstract class CompositeQuestion extends Question {
						private List subquestions;
						
						public int get_marks() {
						foreach (Question q in subquestions)
						return (Question)q.get_marks();
						}
						}
						
						Thus we can see that inheritance is used as all types of questions have some commonality (ie they all have a get_marks method). Delegation is used by the Composite as it maintains a private list of all its subquestions.
						Dynamic binding is employed as when we retireve the marks for a composite question, each sub-question may be a composite question itself, OR a basic question. This is not known at compile time, so the actual get_marks method is bound at runtime.
						
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Proxy patterns, which are patterns which allow objects to recieve messages on behalf of some other object (and so share the target objects interface - so uses inheritance) can be used as we wish remote access to the system be possible (as students will be all over the world). Therefore, we can use a Proxy Remote pattern to access the remote objects (which may be held on some central server). This has numerous advantages - the client can deal with the Proxy object as if it were the real thing (as if it were talking to the server object directly). This is possible as the Proxy object abstracts away all the details of network communication etc with the target object. It performs its actions by delegation to the target object.  The (local) proxy object can also hold copies of the information held in the server object. It could also be used as an Access proxy - only allowing legitmate students access.
						
						We could use Observer pattern to detect issues that may arise with the students exam system. For example, we could have a client side &quot;working object&quot; which is an Observable (ie it has a state which can change at an unpredicatable time). This could be used to signify that the students system is working correctly. We can then have an observer object (residing on the server) which registers its interest in the observable &quot;working_object&quot;. So when some issue arises, such that the students exam system suddenly stops working, the server observer can be informed of the change of state of working_object.
						
						As questions may have various methods of marking (e.g some may use an algorithm to detect nodes in a UML diagram, and others may simply do a keyword search in a text passage), different algorithms may be used to mark different questions. This would only be applicable in questions which can be automatically marked by teh computer.  As these algorithms are fairly self contained and do not interact too heavily on other modules, we could encapsulate these into classes using the Strategy Pattern.  This allows us to switch between alternative methods which can mark a question.
						We define a general abstract algorithm which defines the interface of the algorithm. We do not make this an interface as it may require default values to work correctly.
						
						public abstract MarkingAlgorithm {
						public abstract int EvaluateQuestionAndReturnMarks(Question q);
						}
						
						Then we define a concrete class which is the actual method:
						
						public class UMLMarkingAlgorithm extends MarkingAlgorithm{
						public int EvaluateQuestionAndReturnMarks(Question q){
						//code
						
						}
						}
						
						So here, the actual algorithm is treated like an object, with its inner workings hidden from clients.
						
						As there are many different types of exam taking place, e.g a question may require a C Program to be marked syntactically, and then later a Java one to be marked. Therefore, a marking algorithm would not know which type of Program was being marked, unless we told it explicitly (e.g. using a discriminator string in its constructor).
						A better way of getting around this would be to have a MarkingProgram class:
						
						public abstract class MarkingProgram{
						public Program prog = getProgram();
						
						public abtsract Program getProgram();
						public int mark(
						prog.get_syntax_rules();
						);
						}
						
						Thus we can use the factory pattern to create specific versions of the marking program which can mark C,Java programs:
						
						public class JavaMarker extends MarkingProgram{
						
						public Program getProgram()
						{
						return new JavaProgram();
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							For all OO programs, their primary features are that they are promote reusability, extendability and compatiblity.  However, this should not be at the expense of robustness (handling events outside the specification of the software) or correctness (handling what is in the specification).
							Thus, conctracts form a formal agreement between classes and  clients and defines eachs roles and responsibilities. It allows us therefore to reason about the correctness of the software. This can be achieved using pre and post conditions and invarients. Pre-conditions are logical predicates which ensure that a system will never execute in a state NOT satisfied by the pre-condition. A post condition is used to ensure that the system, will terminate execution in a state satisfying the postcondition. An invarient is used to formally specify those properties or characteristics which always hold (by all instances of a class).
							We can use pre/post conditions to bind a client and a class, ie it obligates the client to ensure that the pre-condition is held, and it benifits the class as the class can assume that everything is correct (wrt the pre-cond).
							The postcondition can be used to obligate the client that the post-cond will be held upon termination, and benifits the client as it can assume that this will always be the case.  It can be formally specified using Eiffel for example (where &quot;require&quot; represents the pre-cond, and ensure represents the post-cond).
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							The pre/post conditions must hold at the start and end of a method respectively. The invarient must hold at all stable states of the system - those are states where the system can be observed (eg before and after a method call) and object creation).
							
							public class SqRoot{
							invarient int number &gt;=0;  //states that ALWAYS this value is positive
							int number;
							PRE: NUMBER &gt;=0 otherwise an instance cannot be created
							public SqRoot (int number)
							{
							
							}
							POST: an instance is created with a valid number
							
							
							public double sq_root();
							POST: return a number which is &gt;=0 and that return * return = number;
							
							
							}
							
							Thus, the pre-cond benifits the sq_root method as it knows (and can assume) that the number it calculates from is positive.  The client is benifitied by the post-cond as it knows a value is returned which is the square root
							
							public class Stack{
							int capacity = 10;
							invarient number_items_in_it &lt;= capacity and capacity &gt;0;
							
							push (value){
							PRE: push called only on a non-full stack
							//code
							
							POST: stack is updated with the top value being the new one and its volume increments by one
							}
							
							pop (value)
							{
							PRE: not called on an empty stack
							
							POST : value returned, with stack volume decremented by 1
							
							}
							
							}
							
							Thus we can see that the invarient maintains that the stack is never full beyond its capacity. The precondition ensures of the push method ensures that it is not called /exectuted on a full stack (ie u cannot add any more). This pre-cond thus ensures that if it is held (of benifit to the stack class), and the push is executed, then the stack is updated with the top value being the new one and its volume increments by one (obligates the stack to ensure this is the case).
							WRT the pop method, the precond ensures (and benifits the stack) that it is not called on an empty stack. Assuming this is not the case, and a call is allowed, the post-cond ensures (obligates the stack) to return a value with its volume decrementing by one.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Benifits of using SqRoot and Stack is that:
						
						a) we can cycle through the stack, taking each value off it, ensuring that the code will handle the cases where the stack is empty (ie the sqroot method is not subsequently called as no value has been supplied).
						b) we can automatically perform a check that the value is positive (ie when we supply the value popped of the stack as a argument when making an instance of Sqroot), as we wont be able to create an instance of a sqRoot object for a negative number.
						
						while ((value = stack.pop()!=null))
						
						if (value!=null)
						SqRoot sq = new SqRoot(value);  //ie a valid value has been returned from the stack (ie it is not empty)
						
						if (sq!=null)  //ie a valid sq root number has been returned - ie it is +ve
						print sq.Sq_Root();
						}{
						value = stack.pop();
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="56" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="29" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a quite a sensible use of inheritance on the face of it. The names the terms &quot;striker&quot; and &quot;defender&quot; areg enerally terms used for football players of different kinds. However it could be argued that players can play out of position and therefore a player it can be said that striker and defender are roles played by footballers. Having Wayne Rooney as a seperate class is unlikey to be a sensible use of subtyping.An alternative solution for this is:
						
						public class Footballer
						{
						Position [] positionsplayed;
						...
						}
						
						Wayne Rooney would then extend footballer as all players. and be able to play in different roles (as in real life).
						
						public class Wayne Rooney extends Footballer
						{
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It is not good practice to specify an ArrayList in this manner. The implementation of the calss may nedd to change as the system grows and therefore it would be better to have the class extend java.util.List as shown below.
						
						public class TrafficQueue extendes java.util.List
						{
						...
						}
						
						This implementation (the one of the Question), allows the class to have access to all methods in the ArrayList class so it would therefore be best in most cases to use delegation. This is because this scenario does not pass the &quot;is a test&quot; and the implementation may need to change at runtime:
						
						public class TrafficQueue
						{
						car [] traffic;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a case of implementation inheritance ( amongst other things the is-a test is unclear). CameraPhone would inherit all functionality of DigitalCamera. This may be acceptable in some scenarios however many Digital Camera&apos;s have more camera functionality than even the best camera phone. Subtypes should add to the Supertypes functionality but switching the classes around in terms of sub and super types does not hold ligically. This means that parameterisation is not a good use of inheritance in this case. An alternative is:
						
						puclic class CameraPhone extends MobilePhone //should have all the basic functionality
						{
						DigitalCamera  camerafuunctionality.
						....
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This could be a reasonable use of inheritance.  If this is a replacement for the clone mechanism that copies objects in java then it is again dependant upon what functionality is required in terms of the book. the copy() method int he Copyable class will copy instance variables but not he objects to which they refer. If all books have identical instance variable(?) then this is fine. However the by their intrinsic meaning it is unlikey that we want the same real life object represented twice in our program model. This is essentially what happens if the a references to an object is not known. It could therefore be better to change copy() to include a reference to the object copied from. I t could also be advisable to to have copyable as an interface and then have a copy method in book with all the relevant functionality. A Map could be used to link the reference and the book object
						
						public class Book extends InformationSource implements Copyable
						{
						HashMap map;
						
						public void Book
						{
						map= new Hashmap;
						}
						
						
						public Object [] Copy()
						{
						....
						}
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a good use of inheritance. The fact that an abstract class is extended allows the use of dynamic binding. Paramterisation does not make sense in this case (sub and super switchin is illogical).The is-a test is passed as all of the stated sub-classes are logically answers to questions.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							I would define contracts as an agreement between a client and server. The contact states the obligation of the client and the server. In essence, these obligations are the pre-conditions and post-conditions for the interaction between the client and server.
							The purpose of introducing contacts is so that software which uses the classes is to have an increasewd level of reliabilty and robustness in software that uses the classes within the library. Pre-condition sate the conditions in which a procedure can be invoked. Post-Conditions state the constraints of a procedures output   Clearly defined contracts mean that the behaviour of the classes is highly predictable and and should allow errors to be easily corrected when debugging parts of software that uses client and server operations from classes in the library.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							SqRoot
							The SqRoot class is likely to be only using the real numbers set (this is an ASSUMPTION) and therefore needs to have a precondition in the program that states  that the number to be sqare rooted is non-negative.
							Post-conditions is are that the method returns a non-negative real number. That 1 and 0 return themselves as suare roots. This would be used if the check time was shorter than the computation time of the method.
							
							
							
							Stack
							I would define stacks preconditions as:
							The stack is not overloaded when in a viwable state.
							The type of data to be stored on the stack is of the allowable type(s).
							
							I would define the postconditions for stack as:
							The object is stored at the top of the stack;
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The main benefit of using SqRoot and Stack is the reliablity in the intero-operation of the two classes. We are sure of how the SqRoot will execute and the constraints under which it will return a result. As a consequence the result will be correct in terms of the code inside the method used to find the square root. With correct error handling each class would give sensible output tot the user
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						A component is not just any block of software as there are 5 concepts that characterise a components. If these are not met, then the block of software cannot be described as a component. These concepts are:
						
						Encapsulation - This means that the inner workings of a component must be hidden from the outside world.
						
						Use of an interface - This means that an component must make use of a relevant interface, and implement all its methods so that the outside world knows what services the component provides.
						
						Reusable - This means that the component must be reusable by some 3rd party in a different application context.
						
						Replaceable - This means that the component can be replaced by a current component and the system in which it is being used shoul still maintain full functionality.
						
						Inter-Operable - This means that a component can be useds across different software platforms.
						
						When a block of software has all these concepts true of it, then it can be said to be a component.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Two of the main java beans that will be used are: Service Java Beans and Session Java beans. Interfaces must also be used in order to specify what services each bean is providing. The
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Java beans would not be suitable for this application first of all because they would requuire a java runtime environment to be intalled on all PC&apos;s that want to use the system. Also the sytem would be slow in comparision to say COM (using C++) if there were many users online simultaniously. The existing libarary software may not be in Java ands so java beans would not be able to interact with these components. This is because java beans are language dependant.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="57" examId="CS310105" timeTaken="7190" isSubmission="true" allImages="true">
		<compositea marksAwarded="36" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a classic roles inheritance problem. Ths is-a test holds for Striker and Defender and this part of the implementation is plausible. The problem in this situation is that roles might change e.g. WayneRooney may play in Midfield for a particular game. In any case WayneRooney should clearly be an instance of Striker rather than a seperate class.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is poor because the clients of TrafficQueue will have access to the methods of ArrayList and could e.g. remove an item from the TrafficQueue without going through the proper TrafficQueue interface. The relation ship is has-a rather than is-a, and so delegation should be used. It is good practice to program to the interface of a data structure, rather than the implementation i.e. List rather than ArrayList. e.g.
						
						Public class TrafficQueue()
						{
						private List TrafficQueue;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is an implementation inheritance problem. The Multiple Inheritance used for the CameraPhone class survives the is-a test. However, this is not good use of inheritance because it combines the attributes of both Digital Camera &amp; MobilePhone when not all the attributes are relavant. In the real world a CameraPhone is actually a mobile phone with some attrributes of a DigitalCamera, i.e. it is not an instance of both. An alternative implementation might be...
						
						public class Phone extends PersonalElectronicEquipment() {..}
						public class DigitalCamera extends PersonalElectronicEquipment() {..}
						
						public class MobilePhone extends Phone()
						{
						private Phone mobile;
						}
						
						public class CameraPhone extends Phone()
						{
						private Phone mobileFeatures;
						private DigitalCamera cameraFeatures;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The properties of InformationSource are more important than the properties of Copyable. However the properties of both superclasses are useful. An alternative and perhaps better implementation might be:
						
						Public class Book extends InformationSource()
						{
						private Copyable copyable;
						}
						
						This gives access to the copy method from within this class i.e. for use in any relavant methods.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The class NoAnswerProvided to represent a blank answer is uneccessary and could probably be replaced with null, i would check for this using an if-statement to see if an answer was provided.
						The NoAnswerRequired class is not an instance of Answer ( because there is no answer provided ) and so it fails the is-a test. Inheritance should not be used to represent this. It is better as an attribute in the Question class. NoAnswerRequired is a property of question rather than a subclass of Answer. The is-a test fails here.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communication classes and/or objects which can be customised to solve a general design problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The Composite design pattern is useful when dealing with systems that implement a hierarchy of objects uniformly. It is an example of good Software design, based on the knowledge of experience software developers. The Composite design pattern could clearly be used in this example. The system will involve structured questions e.g. Composite questions (questions containing questions). An example of this might be :
						
						public class Question() {..}
						
						public class CompositeQuestion extends Question()
						{
						private List questions;
						}
						
						The List will contain Question objects. This is a classic example of how to get the best out of a combination of inheritance and delegation. When used together, solutions can be neat and robust.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						The Proxy design pattern may be of use here, as systems will be communicating with each other over the internet. It will help with the design of the communicating systems, enabling them to talk over the network efficiently.
						
						We may want only 1 invigilator mode for each exam, who controls the start and finish of each exam. The Singleton Pattern may have application here to make sure that this invigilator mode can only be access by one person at a time. I.e. None of the exam takers will be able to gain access to this mode while the invigilator is logged on. This may be done by the use of a private constructor.
						
						With several people doing the same exam at the same time there may be several instances of a particular question. Instead of creating a new instance of question for each exam the flyweight pattern can be used so that the instances of question are reused for each of the candidates. This will improve performance because there are much less objects in the system this way.
						
						With some exams we may want the use of certain algorithms to help with the marking of exams. E.g. scan answer for particular key words etc. We can encapsulate these algorithms into objects for simple efficient use. This is a characteristic of using the Strategy design pattern.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts give a clear precise definition of the clients of a class and the neccessary states required and expected during execution. Users can then see what is expected before implementing methods from the library. They allow the designers of libraries to clearly specify the correct environment for using the library classes for combining in thier classes. I would define the contracts using the mechanisms provided in the language, and also documentation which comes with the packages.
							
							For example Eiffel has many mechanisms which support design by Contract. Java doc could be used in java as well as asset statement in the actual code.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							public class SqRoot{
							
							public double findRoot(double Sqr)
							
							PRE CONDITION: Sqr &gt;= 0
							
							....blah blah java blah
							return root;
							
							POST CONDITION: (root) * (root) = Sqr
							}
							}//SqrRoot class
							
							public class Stack{
							
							
							INVARIANT: No of Elements in stack &gt;=0 &amp;&amp; &lt;= Stack.Length
							//(JAVA uses Assert for invariants)
							Assert No of Elements in stack &gt;=0 &amp;&amp; &lt;= Stack.Length;
							
							public void push(Object obj){
							
							PRE CON: There is space on stack for obj i.e. No of Elements &lt; Stack.Length
							POST CON: Stack is updated
							}// end push
							
							public void pop(){
							
							PRE CON: Stack is not empty e.g. No of Elements &gt; 0
							POST CON: Stack is updated
							}//end pop
							}//stack class
							
							Pre Conditions are the required state before method execution.
							Post Conditions are the expected state after method execution.
							Invariant (Assert) is a requirement before execution and after execution.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						class findRoots()
						{
						private Stack;
						private SqRoot;
						private numbers [9, 16, 25];
						
						public findRoots()
						{
						stack = new Stack( numbers )
						
						public findThem()
						{
						//pseudo code as i am running out of time in this exam....
						loop
						pop number off stack and pass it to Sqr
						do this till there are no more numbers in stack
						}
						
						There are benefits with using these classes. They both clearly state pre and post conditions for use. It makes it easier for trying to debug because you can clearly see what the objectives and requirements are. The classes are also more robust and reliable.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="58" examId="CS310105" timeTaken="6654" isSubmission="true" allImages="true">
		<compositea marksAwarded="27" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a reasonably sensible use as an inheritance structure as all common features to a footballer will be inherited and there individual abilities due to the position implemented in there individual subclass. This is a good use of inheritance as long as you will only be concerned with the players in regards to a game of football otherwise it falls into the trap of being a is-a-role-played-by and so would not be a sensible.
						
						An alternative would be to use a common class like Footballer and then delgate tasks from instances of striker and such
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is not a sensible use of inheritance as it is unnecassary it inherit from the ArrayList as TrafficQueue does not have an is-a relationship but a has-a.
						
						An alternative to this would be to implement the representation of the TrafficQueue internally as an array list and then delgate tasks to it
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This implementation makes use of multiple inhertitance which can be unwanted in a situation like this as you would be inheriting two copies of the components of the class PersonalElectronicEquipment.
						
						An alternative would be for the class camera phone to inherit from the class PersonalElectronicEquipment and delagate tasks to the relevant classes of MobilePhone and DigitalCamera
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a reasonable use of inheritance and a good implementation as storage is not wasted by needlessly copying the book object. The only problem it could have is the use of multiple inheritance but this is not significant in this situation
						
						A possible alternative would be for the Book class to directly implement the copy method so removing the problem of Multiple inheritance and giving the opportunity for optimisation of the code.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a good implementation of inheritance but maybe a bit of overkill haveing two classes to represent answers which where not relevant
						
						An alternative could be
						
						public abstract class Answer {...}
						
						public class MCQAnswer extends Answer {...}
						
						public class TextAnswer extends Answer {...}
						
						// An answer which was either not given or not required
						public class NoAnswer extends Answer {...}
						
						this would cut out wasted code and would more easily allow us to deal with answers which are irrelevant
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation allows you to hide information from users, this means that you can produce clearly defined code that carries out set operations without the worry of user interference. So abtract code is encapsulated so that you can inherit the functionality of that code with the knowledge that it is secure and correct and the internal implementation is hiden from the user
						
						Class Libaries are code that are abstracted and encapsulated
					</answerString>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Because of the way that encapsulation is implemented, we know that when you have finished using a given method from the encapsulated set you can remove all objects relating to that encapsulated set. This assists in manual storage mangement as it makes it esaier to identify the objects that should be deleted from memory
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Because encapsulation allows you to hide your code it is the perfect way for the design by contract development to organise the finished code so that it adheres to the contract specifications and is resistant to user error. This is because the user cant change the code and must give inputs as is stated in the methods. So by this you know as long as the code you have created is correct it will stay correct
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a pattern for communicating between objects/classes to solve a general problem in a specific contex
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						You could use the composite design pattern to create a hierarchy of the answers types. And then for approapriate groupings of the answers you could deal with them uniformly allowing the computer to resolve there actual type at runtime by use of dynamic binding. This would allow you to group common types of answers so as to present the information to the examiner in a way where the same anwer types would be represented together giving consistency and efficiency
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						Flyweight - You could use the flyweight pattern to store the answers to the exam questions saving you a lot of data space as there internal information would be stored extrinsicly. There would be a rise in complexity but as we arent doing anything is significantly computationaly expensive this shouldn&apos;t be that big of a problem
						
						Factory - As we would be creating many thousands of duplicates of the same questions and other objects. We could use the factory method so as to significantly cut down on this by just implementing its objects pool of all the objects that we will be creating. Hence there will only be the need for 1 set rather than a copy for each exam.
						
						Observer - As we need to create a system that interacts with the user we could use the Obeserver pattern so as to keep track of the time when they can start, when they must finish by, and other actions such as selection between questions.
						
						Visitor - This could be used to help with the problem of any of the algorithms being used in the system being spread over many classes. It will group parts of the algoritms into a common class so as to help with this problem. This would result in a bit of extra complexity and slight loss of encapsulation
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="59" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="52" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test passes for Striker and Defender. However, if the only difference between the two is a few properties it might be more appropriate to use paramterisation.
						With regards to WayneRooney - the is-a test passes but this is an exmaple of a roles problem. This player&apos;s role may change with time. Using inheritance it will be difficult to change this relationship. Also we are proabably more interested in his details as a footballer rather than just a striker. A better model for this might be:
						
						public abstract class Position {}
						public class Striker extends Position {}
						public class Defender extends Position {}
						public class FootballerDetails {}
						
						public class FootBaller {
						Position playerPosition;
						FootballerDetails details;
						}
						
						Thus a footballer can be any position type and his/her position can change throught the career.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						There is some ambiguity with the is-a test. A traffic queue is not necesserily an array list. Also this approach exposes the entire ArrayList interface to clients of TrafficQueue - they might remove elements from the middle of the queue. It would be better to use delegation:
						
						public class TrafficQueue {
						List queue;
						public TraifficQueue() { queue = new ArrayList[] };
						}
						
						This approach hides the implementation and this does not expose it to the client. We can also change the collection used with affecting much of the other code. We have programmed to the interface of the collection, rather than an implementation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test passes in middle two classes. However, this is not the best use of multiple inheritance (MI). MI has some runtime cost associated with it. The layout of object also becomes more complex with MI. We will also have to provide a mechanism for name clashes. For exmaple if both Digital Camera and Mobile phone might have a variable batteryLife - there will be a name clash in the class CameraPhone.
						
						We should not model real world hierarchies/taxonomies directly to OO hierarchies.
						Also arguably the CameraPhone has-a DigitalCamera rather than is a digital-camera. The camera is unlikely to be a fully featured digital camera.
						
						public class Camera {...}
						public class DigitalCamera extends Camera {...}
						public class PhoneCamera extends Camera {...}
						
						public class MobilePhone extends ... {
						PhoneCamera hasCamera;   // can be set to null if phone doesn&apos;t have a camera
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test does not pass for Book and Copyable. A book can be copied and its not stricly a copyable. Also the issues associated with MI as discuessed earlier apply. It would probably be better to implement Copyable as an interface - it is unlikly to have propterties which neccessitate it being a class.
						
						interface Copyable {}
						
						public class Book extends InformationSource implmements Copyable {...}
						
						This allows the operations of copyable to apply to book.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Although the is-a test passes in most of the above, it is not appropriate to represent NoAnswerProvided and NoAnswerRequired as separate classes. They are more properties of an answer and thus sould be represtned as varibales in the Answer class:
						
						public abstract class Answer {
						boolean answerProvided;
						boolean answerRequired;
						}
						
						Using this approch the varibalbes will be automatically inherited by all the differnt types of question. It would therefore be possible to have a multiple-choice-question for which a studnet provided no answer. Previosuly this would have had to be done using multiple interitance.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a collection of communication classes and/or objects which solve a general design problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						An exam will typically consist of different types of questions. We will want to be able to handle the differnent types of questions in a uniform manner. For example, we might have an atomic and compositie question. We will want to be able to display the question text on the java applet using the same method:
						
						public abstract class Question {
						private String quesText;
						protected abtract String displayQues() {applet.display(quesText);}
						}
						
						public abstract class AtomicQuestion extends Question {
						private String quesText
						public abstract String displayQuesion() { applet.display(quesText); }
						}
						
						public abstract class CompositeQuestion extends Qeustion {
						ArrayList questions;
						public abstract String displayQuestion() {
						String totalText;
						for (int i = 0; i&lt;question; i++)
						totalText.append(questions[i].displayQuestion()));
						
						applet.display(totalText);
						}
						
						Using the strategy pattern we can make the call to displayQuestion() regardless of the object type and have dynamic binding select the appropriate method implementation. This avoids having to use explict selection using if or switch stements. These are difficult to maintain and can lead to errors. Therefore when we create new types of questions (which are subtypes Question) we will not have to update the code for composite question.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						The exam will be taken on different computers on a distributed network. Therefore we could make use of a remote proxy handle the communication. A local object/server will hold the details of a non-local object/sever. The applet can then use the local object/sever without having to worry about the detials of the network. The proxy will share (at least part of) the same interface as the actual receiving object so can treat it as if it was the real thing. An access proxy can also be used for security reasons.
						
						The singleton pattern allows objects to be created indirectly. It can be used to ensure that only a single instance of a class is created. This will be usefull in ensuring that only one instance of the exam software/class is created on a particular machine. We would not want to have multiple instaces of the exam created on one machine. The singleton achieves this through declaring the contructor private and only allowing a new instance to be created if one has not been created previously.
						
						The Observer pattern allows a flexible connection between observalbe and observer objects and allows this relationship to be changed at runtime. As the applets will be dealing with events (start of exam, end of exam, saving procedures etc) this pattern might be useful. For example, an applet on a remote machine will be an observeable object. The central server will then be an observer object. The server will register an interest in the applet to ensure that it is aware of applet events (eg, when an exam has started). The applet will then let the server know of any events that occur. Through the oberver pattern we have defined a flexible connection which can be changed as nesscessary (the server can oberve different exams).
						
						The strategy pattern might be used. The software makes use of different strategies to present the information efficiently to the marker. The strategy pattern will allow us to easily switch between the numerous stratgies. With the strategy pattern we have an astract superclass which represent the inferface of the different strategies. Then each actual strategy is represented in a concrete subclass. This allows us to switch between them easily as required.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="18" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts details the rights and obligations of both the supplier and client. Through the definition of contracts we can ensure the correctness of software. Contracts are defined through pre and postconditions on methods. The precondition defines the properties of a state under which the method will function properly. The postcondition deifnes the properties of a state resulting from the correct execution of the method. The precondition binds the client to ensure that the method is only called with the precondition met and it is of benefit to the supplier. The postcondition binds the supplier to ensure that after method execution that certain properties hold. It is of benefit to the client. We also have the notion of a class invarient. The class invarient expresses global properties that apply to all instances of the class. They must be preservered at all stable times (upon class creation, before and after method calls).
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							public class Stack {
							
							int stackLength;
							int counter;
							
							public void push() { ... }
							public int pop() { ... }
							private boolean check() { ... }
							}
							
							The method push will have the precondition that the stack is not full. Therefore it is the responibility of the client to ensure that the method is not called when the stack is full. The method will have the postcondition that the stack is updated. It the the responsibility of the supplier to ensure that the stack has been updated providing the method was called with the precondition met.
							The method pop will have the condition that the stack is not empty. It is the responsibility of the client to ensure that the method is not called on a empty stack. The postcondition will be that the stack is updated. Its is the responsibility of the supplier to ensure that an updated stack is returned.
							The class will have the following invarient:
							counter &gt;= 0 and counter &lt;= stackLength
							The invarient expresses global properties of the class. This assertion must hold at all stable times. This might be represetned using a private method which ensures that the invarient holds. The method will be called prior to return from any public methods.
							
							public class SqRoot {
							
							public double findRoot(double num);
							
							}
							
							The method findRoot will have the precondition that the &apos;num&apos; is a positive number. It is the responsibility of the client to ensure that num is only called with positive number. The postcondition will be that the method return the correct square root for that number. It is the responsbility of the supplier to ensure this property hold after the method execution.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						class SpecialProgram extends Stack {
						
						priavte SqRoot root;
						
						public void findOne(double[] stackOfNum) { System.out.println(...); }
						
						public void findAll(double[] stackofNum) {
						while(counter != 0) { root.findRoot( pop() ); }
						System.out.println(...);
						}
						
						The assertions that apply to stack also apply to this program. They are logically &apos;and&apos;ed to any assetions that apply here. So DbC also works with inheritance. Aslo as the precondition for findRoot states that it might not be called on negative number. Therefore the stack cannot contain any negative numbers. Also with findOne() we do not have to explicity check that the stack is not empty as its the responsibility of client to ensure pop is not called on a non-empty stack.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="60" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="38" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The above is wrong. First of all the class Striker and Defender dont pass the &quot;is-a-kind-of&quot; test because a defender could be any defender in the sence that it could be a left back or a right back or a central defender. A striker as well could be a right, left striker or even a &quot;forward&quot; which is still considered some kine of a striker. Thus they don&apos;t qualify to use inheritance.The class WayneRooney is appropriate to extend a class Striker because Wayne Rooney is genuinly a striker thus it passes the &quot;is-a&quot; test because he is actualy a striker.
						What i believe would be more appropriate is to have the class Footballer to be an interface so that classes Striker and Defender can implement it. Then the class WayneRooney remains the same extending Striker.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It is not wrong but I believe it shouldn&apos;t be done as shown above for the following reasons:
						1. We might want to change the colletion to be used in the class and truely we could without effecting any client code which leaves it a minor problem. But if we would like to change the collection being used at runtime then by using inheritance it is aukward which makes it a non-attractive approach.
						2. The class TrafficQueue might become larger and larger including more &quot;stuff&quot; which will leave the ArrayList as a minor aspect of the class. This is a moderate problem.
						3. The basic methods of ArrayList get() add() remove() e.t.c are still in the class TrafficQueue and cannot be hided from the client.Major problem.
						
						It is better to use delegation and thus have an object of ArrayList in class TrafficQueue and perform operations via that object. Even better if programmed on the interface of the collection e.g List.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The first three classes are correct but the last one ( CameraPhone) isn&apos;t correct. Thisis because The two classes being extended aren&apos;t disjoint and problems arise because of duplicate data. The problems that we wil have here are:
						1. Name clashes, could be resolved by machanism for name renaming(as in eiffel) where both variables can co-exist.
						2. Differences in inherent attributes.
						3. The class might need to know little about one of the classes and even less about the other.
						4. The resulting entity isn&apos;t coherent.
						5. The two classes are then tightly coupled and resulting class is sensitive to changes in both.
						
						An approach to this problem will be ofcourse to use delegation because a CameraPhone &quot;has-a&quot; MobilePhone and also &quot;has-a&quot; DigitalCamera. Thus in CameraPhone class create objects of MobilePhone and DigitalCamera and apply operations on them.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Defenately out of the question approach. A book &quot;is-a&quot; information source thus it is ok to extend InformationSource but it doesn&apos;t pass the &quot;is-a&quot; test for Copyable. It is copyable but it is not &quot;a&quot; copyable. The property of a book to be coppied can be implemented by delegation by including a Copyable object in the class Book.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first three classes are fine but the remaining are not because above all none of them pass the &quot;is-a&quot; test because none of them is actually a specific answer. The NoAnswerProvided class and the NoAnswerRequired class cannot extend the class Answer because they could be any kind of answers(they could be in text or in a choice format) so they could be no text answer provided or no multiple choice answer provided.
						Thus more classes should be introduced in a way not to violate the taxonomia rule(don&apos;t add classes only for classification&apos;s sake. The new subclass must do somthing its parent didn&apos;t, contain a new functionality or an ovrriden method). Thus by splitting the  NoAnswerProvided class to NoMCAnswerProvided and NoTextAnswerProvided. Also do the same for NoAnswerRequired by splitting it to NoMCAnswerRequired and NoTextAnswerRequired. Now NoMCAnswerProvided and NoMCAnswerRequired must extend MCQAnswer. Also NoTextAnswerProvided and NoTextAnswerRequired should extend TextAnswer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Encapsulation is when the contractual interface and implementation of a class are separate. The contractual intrface is the behafior/functionalities of the modelled class. The purpose of encapsulation is to reduce coupling between modules. By coupling it is ment the interdependancy relationship between two modules. Encapsulation is also known as information hidding as it will hide the implementation and information of operations of a class from the clients of the class. In object oriented software developement we have three kinds of encapsulation.
						1. Object-based encapsulation which hides information of objects from other objects even in the same class.
						2. Class-based encapsulation which hides information of the classes depending on the relationship of the classes.
						3. Package-based encapsulation which is at a larger granularity that classes.
						
						For example every class that could be instantiated is considered as encapsulation because an instance of the class can be created that will have a class invariant, an assertion that is preserved by all calling methods. Thus many information is hided by the client of the class inside an object by encapsulation.
						
						public class Person
						{
						public person(String name, int age, int height, int weight)
						{
						//initiate the values from the parameters
						}
						}
						
						public class BusDriver
						{
						Person busDriverPerson = new Person(&quot;Mark&quot;, 39, 1.72, 65);
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Performance can be increased by not having large numbers of very small objects. For example an array in C would just be a contigues blocks of memory but in Java it would be references to different objects where each object will have extra information like what class it belongs to e.t.c. Thus in Jave it would use more storage (approximately twice) to have an array ruther than in C. Thus instead of having an array of objects have an array of the actual type variables directly.
						For example if we have objects that have int X and int Y as variables then we will use an array to store these objects. Thus we create a large amount of very small objects. It could be solved though by having 2 arrays of ints X and ints Y thus removing all those small objects. This leads to grympy code but it can be improved by using encapsulation by encapsulating the 2 arrays in a Class.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Encapsulation can manually manage storage by grouping objects of the same kind together in an outer object. Then the outer object&apos;s lifetime is monitored by lifetime tracking and the inner objects by reference counting. If the outer object is deleted then the inner objects are also deleted. If any of the inner pointers leak from the encapsulation the all bets are off, this would of course be catastrophic.
						For example a stack can be implemented with a linked list that will be encapsulated in an outer object. The lifetime of the linked list monitored by refference counting and that of the outer object by lifetime tracking.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Design by contract views the relationship between classes and/or objects as a formal agreement/contract that states each party&apos;s rights and obligations. In order to do view this relationship as such then we need encapsulation to prevent the clients and the suppliers to view how something is implemented and &quot;provided&quot;. Therefor with Design by Contract we have pre-conditions P and post-conditions Q of an operation A in a relationship where if the execution of A is applied to a state satisfying the pre-condition it will yield a state that has preoperties satisfying the pos-condition {P} A {Q}. In order for testing of pre and post conditions encapsulation should be used.
						
						By encapsulation achieved when creating a class, a class invariant is also established. A class invariant is an assertion that is always sattisfied by all methods, and its always true at all stable times, which is the time an obect is in its observable state(at instance creation, before and after method calls). Thus when creating an instance of a class, an invariant is imposed on all the methods applied on that instance, which is an encapsulation. Design by contract is exactly the conditions under which a program will perform correctly.
						
						For example when initialising an object that has as arguments a string name and int age e.g the constructor Person(string name, int age), then design by contruct states that the first parameter is a string and the second is an integer. Anything else applied to the constructor will lead to a violation of contract thus generating run-time errors.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern is a solution to a general problem explained in a specific context. A design pattern is a pattern of communicating classes and/or objects that can be customised to solve the general design problems in a particular context. Designt pattern has a name, synopsis, context, force, solution, consequences, implementation, examples, related patterns.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The composite design pattern is used when we have a hierachy of classes, and we want to deal with basic objects and composite objects. The composite pattern has inheritance as well as delegation both important. The exam will have a hierarchical structure just like this online-exam where some of the questions will be stand alone atomic questions and other questions will be composite questions made up of many atomic questions.
						
						public abstract class Question
						{
						public abstract int getMarks();
						}//Question
						
						public class AtomicQuestion extends Question
						{
						public int getMarks()
						{
						//calculate marks
						}
						}//AtomicQuestion
						
						public class CompositeQuestion extends Question
						{
						Private ArrayList composite;
						
						public int getMarks()
						{
						for(int i = 0; i &lt; composite.size(); i++)
						{
						((Question) composite.get(i)).getMarks();
						}
						}
						}//Question
						
						The above shows that the composite pattern will delegate the process of marking the composite questions to its superclass.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						1. Factory pattern could be used in the sence that it will defer the decision of what object to be created, to its subclass and thus use dynamic binding. Of cource here no object will be &quot;manufuctured&quot; but what method of marking can be decided upon the subclasses by means of dynamic binding. Thus the type, the actual type of the object is determined at run-time and then the operations to be carried are used accordingly. I believe that the Abstract Factory design pattern would also be plausible.
						
						2. The proxy pattern could be used in the sence that the exam is online. A proxy is an object that handles method calls on behalf of another proxy thus shares part of or all of th objects interface. A remote proxy can be used to communicate with a non-local object as in our case where the students computer and the central server are the communicating parties. An access proxy could also be used for security reasons.
						
						3. The observer pattern can also be implemented in the particular case because the exam will definately have a graphical user interface which means that buttons will cause certain reactions. The observer consists of an observable and an observer where the observable will trigger an action (e.g a button) and the observer monitors the observable that will change at an unexpected time by registering its interest to it.
						
						4. Strategy could be used to encapsulate different algorithms and interchange them appropriately. Thus the strategy pattern will assist the above problem by choosing what marking algorithm to be applied on the specific question, depending on the type of the question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="61" examId="CS310105" timeTaken="5485" isSubmission="true" allImages="true">
		<compositea marksAwarded="30" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The is-a rule is questionable, e.g Striker could be a striker in different sports,
						so maybe the name should be more specialised such as FootballStriker.
						
						I think this is justified though as sub-type polymorphism may need to be used
						if you are refering to all footballers.
						
						e.g if you want to find combined age of team
						
						for(int i = 0; i &lt; team.length; i++)
						{
						age += (Footballer)team[i].age() ;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This doen&apos;t really justify implementation inheritance, as other factors may be added to the situation, and ArrayList could be come just a small factor.
						
						Therefore create a class TrafficQueue that contains and instance of ArrayList
						
						e.g
						
						public class TrafficQueue
						{
						
						public ArrayList[] aList = new ArrayList[] ;
						...
						}//class TrafficQueue
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The MobilePhone and DigitalCamera classes use inheritance well as it passes the is-a test.
						But the CameraPhone class uses multiple inheritance, where maybe not necessary. Maybe would be better to create class CameraPhone that extends MobilePhone and has Digital Camera as an extra atribute. For example could have other properties such as DigitalVideoRecorder like many camera phones have.
						
						Therefore: have array of extra properties
						
						public class CameraPhone extends MobilePhone
						{
						
						public PersonalElectronicEquiptment extra[] = new PersonalElectronicEquiptment[];
						
						//add extra properties to this array
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						I think that multiple inheritance in the case of the book class is justified as
						a book is-an Information Source and is-a Copyable entity. The only possible
						way of changing this would be to give Book or Information source a parameter
						called copyable that could be enabled/disabled. Then include the Copyable code
						in the class.
						
						e.g
						public class Book extends InformationSource
						{
						...
						private Boolean Copyable = true ;
						
						//Then have conditions in code
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This example applies to the Change Rule. Where the type of answer may change juring the
						exam, for example a student may fail to prove and answer, therefore a NoAnswerProved
						instance will be made, but if the student returns to this and changes it, the type will need to
						be changed to either a TextAnswer of MCQAnswer. Therefore I would use delegation on class
						Answer and not declare it abstract.
						
						Have:
						
						public class Answer{...}
						
						public class DetermineAnswer
						{
						
						public Answer answer = new Answer() ;
						
						//then delegate operations to this instance
						...
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Abstraction hides information from classes that wish to create instances, and makes it only available to classes that wish to inherit from it. Encapsulation provides the abstracted method with the means to not allow instances to be made. e.g
						
						//The abstract Class
						public abstract class Animal
						{
						...
						public Animal(){...}
						...
						}
						
						//This is not allowed thanks to encapsulation
						public class Zoo
						{
						...
						public Animal lion = new Animal():
						...
						}
						
						//Where as this is
						public class Lion extends Animal
						{
						...
						public Lion()
						{
						super();
						}
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation can improve run-time performance by making information private to external classes. Therefore classes will have to communicate using interfaces between them. This will improve performance by making the code and structure of programs more efficient and less messy. Information is accessed via accesser methods (get() and set()).
						
						e.g
						
						public class Numbers
						{
						private int one = 1; private int two = 2;
						public void setNumbers(int one1, int two2)
						{...}
						
						public int[] getNumbers()
						{...}
						}
						
						It could also prevent classes that are not meant to be accessing the encapsulated class from using it, therefore saving space and time.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation can help with manual storage managment, so that if a variable is declared private in a class, and is the removed from the store for cleanup. The system wont crash because it knows that no functions in other class/applications could be trying to access that variable because it is only availible in the current class. Therefore encapsulation makes manual storage management more efficient. e.g
						
						//class One has public variable that is removed
						class One
						{
						...
						public int ein = 1;
						
						//Code for manual storage managment//
						...
						}
						
						//If something in Two trys to access the integer ein from class one after it has been removed from store
						//the system will crash
						public class Two{...}
						
						but if (int ein) is declared private then this is not possible and the system wont crash, maybe bring up an error message
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It is a pre-requisite for DbC because it prevents the user from touching and editing the source code. Which would then make the contract void as code could be changed. The contract is made by the software developer, who is the only one who should change the code or the contract depending on what the user tells them. If the user was allowed to edit code, the programmer might not know about it and therefore may not be able to fix it. Therefore the program may not work even though user is sticking to the contract(conditions)
						
						example:
						
						Program A is a perfectly working program with set pre and post conditions and invarients.
						
						A user X purchases the application but tampers with the source code. This will cause problems.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a communicating collection of classes in a specific context that can be customised
						and used to solve a common problem
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						A composite design pattern is one that uses a structured class hierarchy so that different subclasses can be refered to by there supertype at the same time and the correct type is determined by dynamic binding.
						
						Therefore to use a composite design pattern with this software, one would need to implement a linear class structure of questions. Where all different questions are either a subtype or supertype of all other questions. Then for example when the marks are being calculated, the type can be determined via dymnamic binding.
						
						e.g
						
						public abstract class Question{...}
						
						public class Type1 extends Question{...}
						
						public class Type2 extends type1{...}
						
						public class CalculateMarks
						{
						public int marks()
						{
						...
						int total = 0 ;
						
						for(int i = 0; i &lt; recievedMarks.length; i++)
						{
						total += (Question)recievedMarks[i];
						}
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						1. Strategy Design Pattern could be used to select the different strategies for presenting the information efficiently to the marker. Having a class of useful algortithms for presenting the information. Then depending on the question and answer, the best strategy/algorithm for those available is chosen and used.
						
						2. Observer Design Pattern will be used with the user interface, involving most interactions between the user and the system. This will come into play when the user initiates anything. It involves having an Observable object(s) and an Observer. The object will be somthing like a button. The Observer will be something like an Event Listener. When the button is pressed the listener is told the source and reacts accordingly depending what the source was.
						
						3. The Flyweight pattern could be used, for example if and array of questions need to be stored, you can store them using a factory, but properties may need to be changed. Maybe to account for different languages around the world or have a difficulty rating for each set of questions. Therefore create another class that contains an array of questions and have some parameters that can be changed for the different situations. e.g
						
						public class QuestionArray
						{
						
						public Question qArray[] = new qArray[] ;
						
						public String language ;
						public int difficultyRating ;
						
						...
						}
						
						4. The Factory pattern could also be used, for example where you would create a common super class for all the different types of questions. Therefore instead of using conditions such as if statements to determine which type of question a particular question is, this is determined at run time via dynamic binding.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="62" examId="CS310105" timeTaken="6828" isSubmission="true" allImages="true">
		<compositea marksAwarded="37" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The is-a test holds well for all these classes which appears to show good use of inheritance. E.g. A Striker is-a footballer
						A Defender is-a footballer
						Wayne Rooney is-a striker
						However in this system it is possible to create 2 instances of Wayne Rooney, 1 as a Striker object, and one as a WayneRooney object, this is highly discouranged in OO programming as we would get consistency issues. e.g. if we were to change a property of Wayne in the WayneRooney object (e.g. Shoe Size) then we would need to remember to also do this in the corresponding Striker object.
						As a better alternative I would suggest the following:-
						- Remove the WayneRooney class altogether as he has no &quot;special&quot; features that can&apos;t be modelled in the original Striker class, and model him as a Striker.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test doesn&apos;t hold in this case as every instance of a TrafficQueue isn&apos;t an ArrayList.
						This is and innapropriate use of inheritance.
						A better alternative in this case would to use paramaterisation and contain a list of objects (cars, busses etc..) within the TrafficQueue class.
						
						public class TrafficQueue{
						ArrrayList queue = new ArrayList();
						.....
						queue.insert(car1);
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The first thing to point out is that Java does not support multiple inheritance so the class CameraPhone cannot extend both MobilePhone and DigitalCamera.
						The is-a test holds for all three subclasses.
						A better alternative in this case would be to creat a separate PhoneCamera Interface which defines all the required information for a phone camera and then have the class CameraPhone extend Mobile phone and implement CameraPhone.
						interface CameraPhone {...}
						public class CameraPhone extends MobilePhone implements CameraPhone {....}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Here we are using multiple inheritance by extending both InformationSource and Copyable for the Book class, this is not allowed in Java.
						The is-a test holds. A book is-a information source and is-a copyable object.
						To resolve the multiple inheritance issue I would suggect to use a Copyable interface and have Book extend that, providing its own copy method that has further desired featured useful to a book, such as copying whole chapters at a time.
						
						public class Book extends InformationSource implements Copyable {
						....
						public Object copy(){
						...
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This example isn&apos;t a good use of inheritance as both the NoAnswerProvided class and the NoAnswerRequired class are inheriting all the properties of an Answer and they will never use these. This is wasting time and space.
						A better use of inheritance would be to paramaterise the fact that a answer is required or unanswered within the Answer superclass, then for the subclasses we can make sure we set instances of a particular answer where no Answer was provided to have answered = false, and answers where nothing was required to set isRequired to false.
						e.g.
						public abstract class Answer{
						boolean isRequired = true;
						boolean answered = true;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a pattern that communicates objects and classes that can be customised to solve a problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The composite design patterns allows us to treat any hierarchy of objects in a uniform manner. For the case of implementing online examination software this will be useful as the questions will most likely be modelled using a hierarchy of question types stemming from the abstract type Question. We would have subtypes, MCQuestion, AtomicQuestion, CompositeQuestion etc....
						By using the Composite design pattern we are able to take a mixed bag of these questions and treat them uniformly as Question objects, even though some of them will be instances of MCQuestion, AtomicQuestion etc..
						This pattern will allow us to present information to the marker in a consistent manner. e.g. If question 2 was a compostie question with a structure like 2.1.a, 2.1.b, 2.2, 2.3.a,2.3.b...  which consisted of a mixture of Atomic and composite questions, we could pass the whole compostie &apos;question 2&apos; to the marker who can then individually mark each sub question or call the mark() method on the whole composite question if it was a question that could be automatically marked.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						- We could use a Proxy Desgin pattern to create an &quot;in-between&quot; object which is an intermediatry interface that shares at least some of the properties of the original interface, but can provide added functionality, this would be useful in for example retrieving the desired question for the marker and automatically indentifying keywords by cross referencing any text answers with pre-defined key words for that question.
						- We could use the Factory Method design pattern to help determine what type of question we are deailing with, this would help the marker of the exam as it would automatically select the correct marking scheme/interface depending on what type of question we are dealing with. E.g for a multiple choice we would simply want to mark the question as correct or not, whereas for a text question we would want to compare it with a model answer and give an appropriate mark.
						- The Strategy pattern could be used in this case to determine which marking method (algorithm) we wish to apply to a particular question. For example our system we may have an algorithm that marks MCQuestions automatically by checking the chosen answer against the actual answers and then returning a result. The strategy pattern would encapsulate all the marking algorithms into a class and then choose the correct algorithm which corresponds to the particualar question type.
						- We could use the Object Cache pattern to allow us to prevent having to look up answers for particular questions if one has already been accessed recently. e.g. If a human was to mark a textual answer he would originally have to connect to the central server and obtain the model answer (assuming that is a feature of our system). If the examiner had to do this for every exam he had to mark it would generate unessesary network traffic. An Object Cache pattern would mean that before a call to obtain a model answer was executed it checked in the Object Cache first to see if there was already one present.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design by contract views the relationship between a class and its clients as a formal agreement/contract. This allows us to state the responsibilities and obligations of both parties involved. This creates an element of trust between the client and the developer. A contract can be defined by using invarients, pre-conditions and post conditions. The class invarient is an assertion in the class and states the global properties within instances of the class that all methods must hold to. A pre-condition expresses the correct propeties underwhich a method will function properly, it binds the client. A post-condition binds the supplier. It expresses the properties of the state of a method after execution, this allows us to guarentee that the method will yield a correct result in the state after execution provided that the pre-condition was met. Among other things DbC allows us to create a formal specification for our program/classes, it makes it easier to document, and it produces more bug free code.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							If we are programming a SqRoot class in java we would need to specify  some preconditions
							- the number passed to the method is not negative
							- the number passed to the method is not zero
							
							/******************
							* Java Code
							*****************/
							public class SqRoot() {
							
							public int SqRoot(double number)
							//pre-condition, the number passed is greater than 0 so it satisfies both above preconditions
							if(number &gt;= 0){
							//calculate square root
							return answer;
							}//if
							else{
							//input broke pre-condition, raise an exception
							}//else
							}//class
							
							
							------------
							For a method that maintains a stack of numbers we need to make sure the following conditions are met:-
							1. ensure that when pushing a number on to the stack, if we then pop it we still have the original number
							2. ensure that we can only pop of a non-empty stack
							3. ensure that we are poping of the top of the stack
							-
							/******************
							* Java Code
							*****************/
							public class numberStack(){
							
							//create an empty stack
							
							push(int number){
							//point 1.
							if(this.pop(push(number)) == number){
							//push onto stack
							...
							}//push
							
							pop() {
							//point 2.
							if(!numbers.isEmpty()){
							//point 3.
							return (int)numbers.get(elementAt(numbers.size() -1));
							}//if
							}//pop
							}//class
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						We need to ensure that both the stack and the SqRoot class contain the same representation of a number, e.g they are consistant with int. We could also need to ensure that the stack only contained numbers greater than 1. We need to ensure that we return all the square roots of the values of the stack as long as the pre-conditions were met.
						
						public class SqRoot(){
						
						int number = null;
						Stack numberStack = new Stack();
						....
						//fill stack with numbers (ints)
						....
						//array to hold calculated results(make sure the array is of the correct size)
						int[] roots = new int[numberStack.stack.size()];
						
						//this loop ensures that we only get the roots if the stack has a size greater that 0 i.e. NotEmpty
						for (i=1, i&lt;=numberStack.stack.size()){
						
						//pop the number off the stack
						number = numberStack.pop();
						//calculate square root and add to roots array
						roots[i] = sqRoot(number);
						}//for
						
						}
						
						The benefits of using these 2 classes together is that we can delegate some of the work to the different classes and save time by not having to re-write for the individual classes.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="63" examId="CS310105" timeTaken="7185" isSubmission="true" allImages="true">
		<compositea marksAwarded="29" isMarked="true">
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Instead of using inheritence as we have used here we could have used parameterisation by capturing the role played by the footballer. Footballers can play in more than one position and this implementation does not allow for this! Therefore it may be better for us to implement it using a parameterisation technique like so...
						
						public class Footballer {
						Object pos [];
						String name;
						...
						}
						
						public class Striker {.. }
						public class Defender{...}
						
						The array of positions are used to store objects such as Striker, defender, midfielder etc.. this allows for those particular properties of the player to be captured.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is a fairly sensible way of implementing a TrafficQueue if we wish to select some arbitrary place in the queue in our simulation. An alternate representation could be to do :
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is not a sensible implementation because a cameraphone may be both a mobile phone and a digital camera in some respects, but a mobilephone does not offer all of the features that a digital camera might do. Such as for example zoom functions. We would therefore have to override a large number of the methods in the cameraphone class in order to achieve our correct implementation. Instead it would be better for us to split the implementation into a &quot;has-a&quot; relationship rather than an &quot;is-a-kind-of&quot; relationship. For example...
						
						public abstract class PersonalElectronicEquipment { … }
						
						public class Phone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class CameraPhone extends Phone {
						DigitalCamera camera = new DigitalCamera();
						...
						}
						
						We can see instead that the mobilephone instead gets properties from the digitalcamera manually through delegation rather than through inheritence which may not be appropriate in this case.
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This is a not a good use of inheritence because Books may well be an InformationSource but they are not always copyable due to various infringements on copyrights. It is much better if this is taken into account by doing the following....
						
						public class Copyable {
						Boolean copyrighted;
						
						public Object copy () {
						if(copyrighted == false) { ... }
						else { // do nothing }
						}
						
						public class Book extends InformationSource, Copyable { ... }
						
						In the above implementation the Book is only a Copyable object (i.e. it only inherits from copyable) if it is not copyrighted. If it is then the Book will not inherit any of the properties from Copyable ( and therefore will not be copyable).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a bad use of inheritence because a large number of small objects are likely to be created when there is no need for it. it may instead be better (for performance purposes) to use paramerisation. We do this by using dynamic binding and ensuring that the answer is only one of the MCQAnswer TextAnswer and NoAnswerRequired. It does not make sense however to model the NoAnswerProvided class like this since the answer can be both a text answer and a NoAnswerProvided. An alternate representation could be of the form...
						
						public abstract class Answer {
						QType questionType = QType();
						Boolean ansProvided;
						}
						
						public class QType extends Answer {
						
						QType(String type) {
						// depending on what type the QType it is it will return the approriate object
						}
						}
						
						public class MCQAnswer extends QType { … }
						
						public class TextAnswer extends QType { … }
						
						public class NoAnswerProvided extends QType { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern which communications how objects/classes interact with each other in a general problem which is related to a particular context. It gives programmers a standard way of discussing better techniques and ways of tackling a variety of different problems and allows this knowledge to be passed onto future programmers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A Composite pattern can be used when we want to define the in a tree structure of a certain type of implementation. In this case we would have a class to represent the Exam with a subclass of question which has a subclass of subQuestions and possibly even more layers. Each question also inherits an answer because the the answer is related to the question being asked. Thereby giving us a tree like structure which we can use. Example
						
						public abstract class Exam { ... }
						
						public class Question extends Exam { .. }
						
						public class Answer extends Exam {.. }
						
						public class SubQuestion extends Question { .. }
						
						public class SubAnswer extends Question { .. }
						
						public class SubSubQuestion extends SubQuestion { .. } // etc to as many levels as we require
						
						public class SubSubAnswer extends SubQuestion { .. } // and so on ....
						
						An answer will have the same marks that the question will have since it inherits the marks from the question level. It will also have the same question.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						1. We could use a Strategy design pattern if we wanted to use a variety of different ways to present the information. This would involve an abstract main class used to represent the Exam (as before) followed by several classes which each represent the various different marking strategies that the Human-Collaborative software may want to employ. Each strategy would be unique in the way that it present the information to the user
						
						2. We could use an Proxy design pattern(in the form of an adaptor if need be) to ensure that the interface between the central server and the Java Applet is consistent and also that the information passed between each system is consistent with one another. The proxy could be used to regularly back-up the students data to the central server during the duration of the exam. A proxy design pattern would be used at each end i.e. the central server and the Java Applet ends. Both of which would communicate with one another, thereby standardising the communication between them.
						
						3. Observer design pattern could be used inside the java applets that the students themselves are using to listen in for the user&apos;s interactions with the exam. For example objects could be registered to listen for the various GUI features on the Java Applet such as the start exam and end exam buttons. This is done by registering variuos objects(Observables) with these objects(observers). These(observers) would in turn interact with the proxy design patterns when sending the data to the main central server for marking.
						
						4. Due to the fact that many exams are being taken at once we may want to monitor the progress of particular Java Applets and find out if any problems have been encountered. For example if some of the java applets were to crash then we would want to know whether or not this has occurred. Therefore we could use the Visitor design pattern to monitor each different java applet.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="7" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							Contracts are important in writing programs because they help to ensure that particular classes perform certain &quot;obligations&quot; with respect to each other. In design by contract(DbC) we can express the relationship between a supplier class and it&apos;s client as: {P} Q {R} where if the predicate P is &quot;ensured&quot; by the client when a call to the supplier is made then the supplier ensures that it supplies the client with a result that satisfies the post-condition, R. DbC is important since it defines the specification that the supplier class is supposed to meet with respect to the Client. If this contract is invalidated then some type of exception will be thrown as a result and we know that something is wrong. When using design by contract we must ensure that the specification is complete otherwise our DbC for the library will be incomplete. When implementing DbC in libraries it helps us to give the library a standard interface that other external classes can use as a means of interaction, where certain states, R, are guaranteed if P is fulfilled
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							// class calculates the sqRoot value of the number
							public class SqRoot {
							// method that calculates the square root of a number
							public float calcSqRoot(float number) { ...
							
							return sqRoot;
							}
							}
							
							public class Stack {
							// Constructor - initialises stack - we could do this using a linkedlist since we want to remove things in order public Stack()
							...
							// pushes a new sqRootNo onto the above stack implementation and calculates the sqRoot
							public push(float sqRootNo) {
							ensure sqRootNo &gt; 0
							...
							}
							
							// pops the first sqRootNo off the stack
							public float pop() { .. }
							
							}
							
							public class SqRootTest {
							// create a new stack object
							...
							// push and pop numbers off the stack for testing the methods
							...
							}
							
							In the above implementation i have three classes, a test class where I create a new stack object then use the push and pop operations to create and remove floats from the stack. A SqRoot class which ensures by Design by Contract(DbC) that if I pass a number to the sqRoot function then it ensures that the correct float value is passed  back to the method that called it. The third class is the Stack class that is used to implement a stack and push and pop values on and off this stack.
							
							The test class first of all creates a new Stack object. When we push float values onto the stack we use the value that we want to square root as our parameter i.e. the assertion being that this value is greater than 0 (since it is not possible for us to square root the negative numbers. The Push operator ensures that this value is pushed onto the top of the stack implementation.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						import java.lang.Math.* ;
						
						// class calculates the sqRoot value of the number
						public class SqRoot {
						// method that calculates the square root of a number
						public float calcSqRoot(float number) {
						// ensure sqRootNo &gt; 0
						if( number &gt; 0 ) {
						float sqRoot = math.sq(number)
						}
						return sqRoot;
						}
						}
						
						public class Stack {
						// Constructor - initialises stack - we could do this using a linkedlist since we want to remove things in order public Stack() {
						Linked List stack = new LinkedList();
						}
						
						// pushes a new sqRootNo onto the above stack implementation and calculates the sqRoot
						public push(float sqRootNo) {
						stack.add(sqRoot);
						}
						}
						
						// pops the first sqRootNo off the stack
						public float pop() {
						Float popValue = stack.getFirst();
						return popValue;
						}
						}
						
						public class SqRootTest {
						// create a new stack object
						public static void main(String [] args)
						{
						Stack stack = new Stack();
						SqRoot sqRoot = new SqRoot(sqRootNo);
						stack.push(sqRoot);
						// push and pop numbers off the stack for testing the methods
						...
						}
						}
						
						The beneifts of using SqRoot and Stack are that each 1 abstracts away the information that the other is required to know. SqRoot only calculates the sqRoot and Stack only manages a Stack. This means that the code can be reused in the future!
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="64" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="36" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The is-a test works in all cases, ie.  a striker is a footballer, Wayne Rooney is a Striker etc.
						
						However, is-a role-played-by is a more appropriate term, because roles can change for people over time etc.
						
						Therefore it might be more sensible to replace Rooney&apos;s class with;
						
						
						
						public class WayneRooney{
						
						Striker striker;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a traffic queue could well be classed as being an array list (ie the is-a test passes)
						
						because the operations which can be performed on an array list are similar to those which might occur in a traffic queue, ie cars leaving, joining entering etc.
						
						an alternative however might be;
						
						public class Traffic queue{
						
						ArrayList list;
						........
						}
						
						---whereby if the two interfaces weren&apos;t exactly the same then, the array list could be specifically adapted with tailored methods within the traffic queue class. This would depend on our definition of a queue in contrast to that of an arrayList.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						mobilePhone   &apos;is-a&apos; (type of) personal electronic equipment
						digitalCamera &apos;is-a&apos; (type of) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
						Camera Phone &apos;is-a&apos; mobilePhone and a digital camera.
						
						Therefore this does represent a suitable use of inheritance as the cameraPhone would inherit all features from each, which presumably it would in reality.
						
						Although alternately, a cameraPhone could be classed as having(or consisting of) a MobilePhone and having a DigitalCamera, in which case delegation could be used;
						(this might be more applicable if eg it inherited contrasting features)
						
						public class CameraPhone{
						
						MobilePhone   mp;
						DigitalCamera dc;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						book &apos;is-a(n)&apos; information source - so it seems sensible to inherit from such
						
						and book would &apos;implent&apos; the copyable interface - ie - it &apos;is-a(n)&apos; object which could be copied.
						
						
						Therefore this does appear a sensible use of inheritance
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						sensible overall, because each type of subanswer is still an answer (the common traits of which would be held/ represented by the superclass) - ie the &apos;is-a&apos; test succeeds.
						
						Although care would have to be taken to ensure for eg the empty answer that those traits would be applicable - without any text.
						
						Whilst the Answer class could be subdivided for instance into answers and  answers-without-entries, this would perhaps be overkill in such a simple situation.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a design pattern is a pattern for communicating classes and/or objects which can be customized to solve a general design problem in a specific context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The composite design pattern essentially enables all objects within a tree type data structure to be communicated with uniformly.
						
						Ie the aforementioned exams involve different types of answers, at different levels, ie in a tree like hierarchy/ structure.
						
						The composite pattern would thus be employed so that for instance one could send a &apos;get mark&apos; query to the &apos;tree&apos;, and each element(question type) at each level would be able to understand the message and respond appropriately. This would produce more easily manageable code
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						the proxy design pattern could be used to control the communication across the network(www) between the central server and the end user. The proxy (network type) would act as a hidden intermediate construct, which would handle all necessary communication (hiding the complexities).
						
						
						The strategy pattern could be used if for instance different marking operations were needed for different question types. This would involve an abstract superclass and concrete subclasses, each representing different marking algorithms. The correct/ appropriate algorithm could then be selected dynamically at run-time.
						
						The observer pattern could be empoyed in relation to the Applets. This would involve declaring buttons, as observable entities, and registering them with methods/classes which would serve as observer entities - ie observing if/ when a button is pressed (or answer submitted) and responding accordingly.
						
						There could be an overall administrator for the system (eg able to access all areas)- it could be required that only one administartor could exist, and therefore the singleton pattern could be employed to ensure that only one instance of the administrator class could exist - thus ensuring security and integrity of the system.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="8" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Contracts can ensure the state of a software system. By using class invariants and pre/post conditions on methods, the software developer can help to ensure that certain conditions - pertinant to the application can be upheld at all times.     eg. if it was critical that a certain value within a software ststem remained at a predetermined level, a contract could be employed for the relevant classes which ensures(contracted)  that that will be the case.
							
							Eg, a pre condition for a method could be that x&gt;0 and a post condition could be that (x&gt;0 &amp;&amp; x&lt;10). This describes a contract, in that the pre condition guatantees to perform the subsequent method, only if the precondition is satisfied. Alternately, the post-condition guarantees the method will produce a result which satisfies the postcondition, if the precondition has been satisfied - this represents the contract.
							
							The exact definition of such conditions would of course depend on the programming language. Whilst Eiffel has specific pre and post condition flags, Java makes use of assert statements as described in the next section.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							public class SqRoot{
							
							public sqRoot(){}
							
							public calculateSqRoot( double number ){
							
							If( number &lt;0 )  throw &quot;&quot;&quot;Specifically defined exception;                     // pre condition
							
							.......perform calculations.....
							.................................
							
							assert (number&gt;=0) : &quot;Number incorrect -- = &quot; + number ;             // post condition
							..
							
							}
							
							
							public class Stack{
							
							public stack(){}
							
							public push( double number ){
							
							if( stack = full ) throw &quot;&quot;&quot;&quot;specific&quot;&quot;exception......    /// pre-condition
							
							performPush.....
							
							assert &quot;stack updated&quot;;		////    post condition
							..
							}
							
							public pop(){
							
							if (stack= empty ) throw specificException&quot;&quot;&quot;            // pre condition
							
							performPop....
							................
							
							assert   &quot;stack updated&quot;;
							..
							
							}
							
							
							
							
							---------------------------------------------------------------------
							
							As can be seen (hopefully) above - the ASSERT statement is used to define pre and post conditions for methods.
							The exception is however for public methods (as detailed above) , where explicit checks should be performed instead (using if statements and specifically tailored exceptions - describing the situation.)
							
							There are two forms to the assert statement, both illustrated above.
							
							Ie    assert (booleanAssertion);
							&amp;    assert (booleanAssertion) : something ;
							
							The first, if evaluated to false, simply throws an assertionError exception, and the second passes the &apos;something expression to the assertionError constructor, thus displaying information relative to the case.
							
							
							Another option is for class invariants ( although such a simple example as above perhaps excludes a worthwhile demonstration, whilst the pre and post conditions similarly cover what a class invariant might be expected to ). In such a case, eg a method could be defined which must hold true before and after all method calls, throughout all classes. This method could then simply be asserted prior to the return statement for each and every method.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						...
						
						for (i=0; i&lt; stack.length(); i++){
						
						stack2.push( sqRoot( i ) );
						
						........
						
						Whilst we are presumably now using the aforemention sqRoot and Stack classes/ methods, with pre and postconditions defined, we can be safe in the knowledge that our program will not produce any erroneous results, as we have hopefully ensured with our pre and post conditions that the correct results will always be produced.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="65" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="47" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						At first glance, this seems a reasonable use of inheritance. A Striker &quot;is-a&quot; Footballer, a Defender &quot;is-a&quot; Footballer and WayneRooney &quot;is-a&quot; Striker. However, it is possible for a footballer to play in many positions, for example WayneRooney may be a Striker in one game and a Midfielder in another. Therefore, perhaps if we used &quot;is-a-role-played-by&quot; relationship instead of the &quot;is-a&quot; inheritance relationship for WayneRooney, and changed the Footballer, Striker and Defender classes to represent these roles instead. The code would then look something like this:
						
						public abstract class FootballPosition { .. }
						
						public class StrikerPosition extends FootballPosition { .. }
						
						public class DefenderPosition extends FootballPosition { .. }
						
						public class WayneRooney {
						
						private FootballPosition[] canPlayIn;
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Saying TrafficQueue &quot;is-a-kind-of&quot; ArrayList is not quite correct, although it can be argued to be. From a programming point of view, it would be better to use ArrayList as an instance variable in the class. There are several reasons for this. One is that we may wish to change the implementation of ArrayList to something like a LinkedList, although this wouldn&apos;t cause too much difficulty, it would better to change the class so that it uses the java.util.Collection interface instead. Also, by inheriting ArrayList, all ArrayList&apos;s methods are visible to anyone using the TrafficQueue class, meaning people could directly manipulate the ArrayList without using the methods implemented in the TrafficQueue class, for example, they could add any kind of object. By encapsulating the collection, we hide these methods and people are forced to use the ones provided by TrafficQueue, hence enforcing what objects can and can&apos;t be added to the queue. The code could look something like this:
						
						public class TrafficQueue {
						
						private java.util.Collection instanceQueue = null;
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Once again, this example seems to work when tested with the &quot;is-a&quot; rule: a MobilePhone &quot;is-a&quot; piece of PersonalElectronicEquipment, a DigitalCamera &quot;is-a&quot; piece of PersonalElectronicEquipment, and a CameraPhone &quot;is-a&quot; MobilePhone and a DigitalCamera. However, using multiple inheritance can cause many problems. The biggest problem in this case is that MobilePhone and DigitalCamera are both subclasses of PersonalElectronicEquipment. This will probably mean they have both implemented their own versions of abstract methods declared in PersonalElectronicEquipment. This will cause name clashes when they are combined in CameraPhone. It is also slightly more expensive to use multiple inheritance when it comes dynamic binding.Perhaps an alternative way to produce this relationship could be:
						
						public class CameraPhone extends MobilePhone {
						
						private DigitalCamera phoneCamera = null;
						
						This can work because a CameraPhone has the uses of MobilePhone primarily, and a DigitalCamera is just an extra item they have attached to it.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The aim of Object-Oriented Programming is to be able to reuse code tosave time and effort. Java provides many of the basic classes and features a programmer needs to implement complex programmes. Therefore, re-writing the clone() method of Java is a bit of a waste of time. Especially since the way has been rewritten, using a shallow copy, is exactly the same as the original java implementation. If you need to perform a deep copy of a class, you can easily override the java default copy by declaring your own in the class needed for deep copying. eg.
						
						public class Book extends InformationSource {
						
						public Object clone(Object obj) {
						//code for deep copy
						}
						
						}
						
						If it lots of classes required a deep copy method, then perhaps the Copyable superclass could be written to implement a deep copy instead of a shallow copy, or instead have Copyable override the clone() mechanism in java with a deep copy.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This use of inheritance seems reasonable although the class NoAnswerProvided seems a bit redundant because the if no answer was provided, we can either have a null object and test for that, which is generally bad practice, or have the value of the answer be empty or null. When the exam comes to be marked, the examiner, whether human or a computer, will see that the answer does not match that in the system and there is wrong. Also, perhaps there should be two types of answers, one which is the known correct answer, eg. for multiple choice questions, and one for the students answer.
						
						public abstract class Answer { .. }
						
						public abstract class KnownAnswer extends Answer { .. }
						
						public abstract class GivenAnswer extends Answer { .. }
						
						public abstract KnownMCQAnswer extends KnownAnswer { .. }
						
						public abstract GivenMCQAnswer extends GivenAnswer { .. }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Encapsulation is a good way fo hiding details from other classes that don&apos;t necessarily need to know them. This way of abstracting is unrequired details is very good, as it allows programmers to use a class and not have to worry about how the class is performing the operation. Abstraction is a very important feature of OO software development and encapsulation provides the only way to do it. The example below shows how we can implement classes representing Humans, either male or female (ignoring people who have undergone sex changes). Since every Human has gender, we don&apos;t want to be able to create a direct instance of Human, but we want every subclass of human to have common attributes. Encapsulation provides a tidy way of doing this.
						
						public abstract class Human {
						
						/* various attributes eg. height, eye colour */
						
						}
						
						public class Male extends Human {
						
						/* male bits */
						
						}
						
						public class Female extends Human {
						
						/* female bits */
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						This statement is not necessarily true. Encapsulation does affect performance, but it depends on how it is used. If it is used as a way to avoid multiple inheritance, then it can improve runtime performance as less dynamic binding will need to be done.Howe
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						In C++ it can be very difficult to manage pointers to various objects on the heap. If memory leaks occur, they can have disasterous consequences, for example the London Ambulance Service, where a memory leak potentially put lives at risk. A good way to manage pointers is to encapsulate them in a separate class which manages these pointers. The class can then keep a record of how many pointers are pointing to an object and when that value falls to zero, it knows it can delete the object safely. A good way of using encapsulation in this way is to have some sort of data structure inside the class to hold the objects, for example linked list. The linked list then provides a much easier way for the class to add or remove items from it, and hence from memory. One problem is that if a pointer outside the class points directly to the object in the list, and not via the encapsulating class, then the encapsulating class won&apos;t know about the pointer and may delete the object causing the pointer to point to nothing.
						
						public class MemManagement {
						
						private LinkedList memStore = null;
						
						public MemManagement() {
						}
						
						public pointer addObj(Object obj) {
						/* obj Added to list and a count created of the number of pointers to it */
						}
						
						public void removePointer(Object obj) {
						/* removes this pointer &amp; decreases count. If count == 0, then object can be deleted from heap */
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Encapsulation IS a prerequistite for Design by Contract, because the aim of Design by Contract is to hide away all the details of how a method or class works. A DbC method will have only a precondition and a postcondition telling any users of the method, &quot;this is what you need to satisfy in order for me to do the method correctly and I will satisfy the post conditions when i&apos;ve finished, you don&apos;t need to worry about what I&apos;m doing inside the method, that is my business&quot;.
						
						public class Supplier {
						
						/**
						* pre - val &gt; 4
						* post - double &gt; 10
						public static double function(int val, boolean bool) {
						/* don&apos;t need to know implementation, just as long as we get what we want back */
						}
						}
						
						public class client {
						
						public static void main() {
						int i = 10;
						System.out.println(Supplier.function(i, true));
						}
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The contracts are way of telling a programmer using that classes how to use them in order to get the required results. The contract is normally specified using pre-conditions, post-conditions and class invariants. The contract basically means that &quot;if you use this method satisfying all the requirements as layed out in the pre-conditions, I will make sure the method returns a state satisfying all the requirements in the post-conditions&quot;.
							The pre-conditions and post-conditions would be stated explicitly in the documentation for the method, for example in JavaDoc, and the class invariants, which must be maintained across a method call, should be defined in the JavaDoc for the class. for example
							
							/**
							* Class Invariants : Pi = 3.14
							*/
							public class Circle {
							
							private final static pi = 3.14;
							
							/**
							* preconditions : radius &gt;= 0
							* postconditons : area &gt;= 0
							*/
							public double calculateArea(double radius) {
							/* code for calculating area */
							return area;
							}
							
							}
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							public class SqRoot {
							
							/**
							* calculates the square root
							* preconditions : 0 &lt;= val &lt; int.MAX_VALUE
							* postconditions : 0  &lt;= result
							public static double getRoot(int val) {
							if (val &lt; 0 || val &gt; int.MAX_VALUE) throw new IllegalArgumentException(&quot;violation of contract: invalid preconditions&quot;)
							else {
							/* calculate root */
							}
							assert 0&lt;= result;
							return result
							}
							
							}
							
							This code for SqRoot, has only one method for calculating the root. The preconditions and postconditions are stated in the JavaDoc which can be viewed by anyone and so they should know how to use the method. The method firstly checks that the preconditions have been satisfied, or else the program will crash because it won&apos;t be able to perform the square root of a negative number. If the preconditions are not satisfied, the method throws an IllegalArgumentException, with a message explaining the problem. If the preconditions are met, then the program carries on and calculates the result. Before the result is returned, an &quot;assert&quot; statement is used to check that the result satisfies the preconditions. There are no class invariants because the class does not contain any instance values, and the only method is a static method.
							
							/**
							* class invariant: 0 &lt;= stackSize
							*/
							public class Stack {
							
							private int[] stackInstance;
							private int stackSize;
							
							/**
							* preconditions:
							* postconditions: stackSize = 0
							*/
							public Stack() {
							stackSize = 0;
							}
							
							/**
							* preconditions: Integer.MIN_VALUE &lt;= val &lt;= Integer.MAX_VALUE
							* postconditions:
							*/
							public void push(int val) {
							stackInstance[stackSize++] = val;
							assert 0 &lt;= stackSize;
							}
							
							public int getStackSize() {
							return StackSize;
							}
							
							/**
							* preconditions: stackSize &gt; 0
							* postconditions: Integer.MIN_VALUE &lt;= val &lt;= Integer.MAX_VALUE
							*/
							public int pop() {
							int returnVal = stackInstance[--stackSize];
							assert 0 &lt;= stackSize;
							return returnVal;
							}
							
							}
							
							This class has one class invariant, that is StackSize must be greater than or equal to zero when the class is in a stable state, ie. in between method calls and on creation. The constructor has no preconditions, except for those inherent to Java ie. the method must be called correctly. The postcondition is that a stack is created and the size of it is 0. There are no checks on the instance variable stackInstance because it doesn&apos;t matter what this variable holds, the methods use the variable stackSize to push and pop values in the right positions. The methods all use &quot;assert&quot; to check the class invariant is maintained. The only preconditions and postconditions to the Push and Pop methods are that the &quot;int&quot; value is within it&apos;s range. This is enforced by Java and as such does not need to be checked.
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class SqRootOfStack {
						
						public static void main {
						/* A stack to be worked on is populated here, inputStack */
						
						Stack resultStack = new Stack();
						
						while (inputStack.getStackSize() &gt; 0) {
						int val = inputStack.pop();
						if (val &gt; 0 ) resultStack.add(SqRoot.getRoot(val));
						}
						}
						}
						
						Because I know all of the contracts return int&apos;s i don&apos;t need to perform any type conversion. the only thing I need to do is check that the value to be square rooted is greater than zero before I square root it. As long as I have satisified that precondition, the program should work as expected. Design-by-Contract has many benefits, it allows the supplier to work with less worry about catching exceptions, and it allows the client to worry less about what state the result is to be returned in.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="66" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="38" isMarked="true">
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is the role issue. A footballer may play the roll of being a striker, but may be required to switch to be a defender.
						
						A footballer may also play a bit of golf, so this model does not fit.
						
						The has-a test works here, as a footballer &quot;has-the&quot; role of striker. They also &quot;have&quot; personal details. (you wouldnt model a whole class on a specific person - WayneRooney class).
						
						An alternative would be:
						
						public abstract class SportsPlayer {}
						
						public class Footballer extends SportsPlayer
						{
						private Roll currentRole; // what the footballer currently is (eg defender)
						private List ableToBe; // list of abilities in football
						private PersonalDetails personal; // personal details eg name etc
						
						public Footballer(PersonalDetails personal, Roll currentRole, List ableToBe)
						{
						this.personal = personal;
						this.currentRole = currentRole;
						this.ableToBe = ableToBe;
						}
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						A traffic queue &quot;has-a&quot; list of stuff (cars) in it, it isnt a list itself.
						
						This implementation also makes the interface of ArrayList visible, so it would be possible for the client to add cars in the list at any point, slightly unfair for those drivers who have been stuck in the traffic jam.
						
						To hide this detail the Queue should contain a reference to a list, not extend it.
						
						public class TrafficQueue
						{
						private List queue; // here we use List, the interface, so we dont restrict ourselves to a specific list type
						
						public TrafficQueue
						{
						queue = new ArrayList(10);
						...
						}
						
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Digital cameras are different from camera phones - they usually have many more features.
						
						By using M.I. we will probably end up having method/naming clashes. For example, we may wish to turn off the camera feature of the phone, but not turn off the phone itself.
						
						A better way to model this would be to say that a moble phone &quot;has-a&quot; camera feature.
						
						public class Camera { ... }
						
						public class CameraPhone extends MobilePhone
						{
						private Camera cam;
						
						public CameraPhone(Camera cam)
						{
						this.cam = cam;
						...
						}
						...
						}
						
						We could then make DigitalCamera extend Camera - as some basic functionality will be provided in the Camera class that we do not want to duplicate in the DigitalCamera class.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This now relies on full M.I. to copy instances. Java however does not support full M.I. so this just seems silly!
						
						A book &quot;has-a&quot; copyable - this doesnt work, so delegation wont be of use.
						A book &quot;is-a&quot; copyable - now that doesnt sound perfect either.
						
						You would expect an InformationSource to be Copyable so the definition of a Book seems strange.
						
						The clonable interface is the obvious alternative to this. It allows us to reference all clonable things with a Clonable reference. Implementation of the method will most likely always be dependant on the class its in.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The first 3 classes work well. Each type of answer &quot;is-an&quot; answer. Some general features of answers can be grouped into the Answer class and each type of answer can provide the type specific code.
						
						However, the last two don&apos;t pass the &quot;is-a&quot; test nor the &quot;has-a&quot; test, plus a TextAnswer may not have been answered, leading to it being modeled as a NoAnswerProvided object - but we still may want to know it was a TextAnswer.
						
						An alternative way to model the answer provided/required information is with two booleans in the Answer class:
						
						public abstract class Answer
						{
						private boolean answered, required;
						
						// public get methods required. set method for required will be needed, but the answered boolean could be set when we set the answer, eg in TextAnswer...
						
						public void setAnswer(String answer)
						{
						this.answer = answer;
						answered = !answer.equals(&quot;&quot;);
						...
						}
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In OO software abstraction is useful as it allows us to present our classes to the outside world with a given interface. We do not need to tell anyone how the class is implemented internally - we hide this detail behind the inferface.
						
						OO lets us swap objects with each other. For example, if we want a list of objects we may choose to use an ArrayList, but we should program to the interface, List, as we may decide at a later point to swap it to using a Vector.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						By putting all the functionality into one class/package we reduce the number of other classes that are involved - so performance may be improved. It could also reduce the space required to store the objects.
						
						If a specific implementation is found to be decreasing performance it could be swapped during runtime to another (strategy d.p.)
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						By hiding the instance variables from the outside world we can ensure that no one will be able to directly reference them. If they could, and we freed the memory, this could cause all sorts of problems - null pointer, etc.
						
						As the implementation is hiden storage management will have to be done internally - which means the caller does not need to know any detail of whats going on - they can just call the free() or close() method on the encapsulated object.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Design by contract is a way of ensuring that given a valid input we will always provide a valid output. We may not check that the input is valid, but we can specify what we require in the interface.
						
						By not showing the client the detail of the implementation they can not work out what inputs will be safe - which is a good thing - as the implementation may be changed but keep the interface constant.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A way of describing a general problem and solutions to them. Design patterns are created by experienced software engineers - and passed on to others so they can understand a simple, but not always obvious, solution.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						We will want to model Questions as an abstract class, and implement the various types of questions as subclasses.
						
						public abstract class Question { ... }
						
						Now we can then create various types of question:
						
						public class MCQuestion extends Question { ... }
						public class TextQuestion extends Question { ... }
						etc.
						
						As each type of question is a subclass of Question we can refer to any question by using a Question instance variable, eg:
						
						Question q = new AnyQuestionType();
						
						Questions may be comprised of multiple sub-questions, so we can subclass Question:
						
						public class CompositeQuestion extends Question
						{
						private List sub; // a list of sub questions
						
						...
						}
						
						The composite question is a way of grouping questions together, but are not individual questions themselves. They will delegate the work to the questions they reference in the list. eg:
						
						Question has the abstract method:
						public abstract int marksAllocated();
						
						Composite Question will need to provide an implementation of this method:
						public int marksAllocated()
						{
						int marks = 0;
						for(int i=0; i &lt; sub.size(); i++)
						{
						marks += sub.getMarksAllocated();
						}
						return marks;
						}
						
						This relies on the fact that the sub questions will eventually lead to an actual question that returns the value. Composite questions could of course have other composite questions associated with them, but the above still holds. Much like a tree having many nodes and sub nodes, eventually they will lead to leafs.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						The singleton d.p to ensure that only one exam object is created on the server when the student has submitted their exam. This would allow us to ensure only one exam is stored on the server and this single exam instance contains all of the answers given by the student.
						
						
						The observer d.p. could be used to observe the exam, running on the client, on the server. The server would register an interest in the client applet, so for example, when the student has finished the exam the server will be notified and will be able to access the answers for storage, etc.
						
						
						The proxy d.p would be used to help communication between the client and server computers. In this pattern we use the same interface for a class representing the client side and server side implementation. In this software the applet will communicate with the server using the proxy. The client side implementation will involve sending data to the server over a network. This detail is hidden from the user of the proxy and they may assume they are interacting with the server directly.
						
						
						The strategy d.p could be used to &quot;employ various strategies to present the information...&quot; This pattern allows us to plug-and-play with different methods of doing things. There may be many different ways of displaying the question/answers and various classes could be created to do this. They will share a common interface to allow us to swap implementations, which we could change interactively change at run-time.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="67" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="17" isMarked="true">
			<compositea marksAwarded="7" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Footballer as an abstract class in it self disregards a lot of the hierarchy beneath it that is classes such as Person, human etc.
						The other problem is the classic role problem as by this method there is no possible way you could get a striker to be a defender in any game other than changing his class.Well to solve this you could seprate the current stucture into two that is define a class for player details and one for his role so that a player can be set to many roles.
						Giving each player a class of his wn would not be appropriate and would just lead to clutter the role approach would suit this as well each player can have his details seprately.
						
						Alternative
						public class PlayerDetails
						
						public class PlayerRoles
						
						instead of one class
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is the heirarchy abstraction problem - idealy we would want that the traficqueue should extend a collection rather than an implementation of it i.e TrafficQueue should extend List and not ArrayList this has not point and restricts future changes which you might want to make.
						
						public class TrafficQueue extends List{ }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The digital cammera might be a sub class of the class cammera so we are discluding information which we might have to use.
						The CameraPhone is a multiple inheritence problem the attributes would over ride as both the classes it extends are from the same parent
						
						public class camera phone{
						
						MobilePhone mobphone;
						
						DigitalCammera digCamera;
						
						call instances
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Copyable is a very small attribute a book can have so it is not a wise idea to inherit it this way we can inherit readable etc.
						Implemntation inheritence problem too as object methods vunerable in Copyable();
						
						public class Book extends InformationSource{
						Copable copy;
						....
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						NoAnswerRequired,NoAnswerProvided fails &quot;is-a&quot; logic and can not be a sub class of Answer.They can be perametrized into the main class answer.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="4" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is the process of hidding or restricting information.Abstraction can only be gained if the client of a class does not know how it is implemented thus hidding detail leads to flexability. This is one using interfaces an interface is the model of a class that is all the methods it contains without the implementation details.A class showing all details of implementation would hinder inheritence and people would tend to resuse that code in their own personal classes.The encapsulation makes sure that code is resued by clients.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Encapsulation improves run time performance as it hides most of what is not necessary from the  client so unnescessary code is not executed.Only used methods are accessed by client are proccessed i.e only that part of code used to implement the used methods is processed.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Encapsulation removes redundency of data so improves storage mangment.A single fuctionality is only called to by cliends and not written all over again.Only methods used are implemented in all detail the rest is left un touched.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation is a prerequisite for design by contract
						This is because this makes sure that assertions can be placed on methods in a clean manner and that inheritance can be cleanly shown so as to allow design by contract to cleanly build on previous assertions and invariants without have to list the whole code all over again.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Contracts are a measure to ensure that the specification we design to implement the solution of the library is followed precisely.Each class would be defined with invariants that is conditions that the class must hold and all its insstances must hold. Then every method in the class would hold pre requisite and post requisite assertions.This is to ensure that the symantics of the specifications are followed through properly.
							In a language like Eiffel this can be easily followed as follows
							example design individual class
							Class Percentage
							
							ATTRIBUTES
							integer:marksObtained
							integer: totalMarks
							integer: percentage
							
							ASSERTION
							require totalMarks&gt;0 and marksObtained =&gt;0 (This is the pre condition for the method CalcPercentage which
							says that totalMarks&gt;0 and marksObtained=&gt;0)
							METHOD
							calcPercentage()
							{
							percentage=markObtained/totalMarks * 100
							}
							
							ASSERTION
							ensure percentage &gt; 0  (This is the post condition makes sure that the result is always positive number)
							
							INVARIANT
							
							Invariant ( percentage is int) (makes sure that percentage is alwayz an integer)
							End Class
							
							Now if this class was inherited into another class all its assertions wold remain intact along with the invariants however if a new method is to over ride the present methods in the sub class than the pre requisites assertions can only be of the same or weaker degree and the post requisites assertions can only be of the same or higher degree.The invariants of the parent class would be added to any sub class invariants.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							Class SqRoot extend util
							{
							private long sqNumber=0; //the declerations in themselves are preconditions as the number can not be null
							or of any other typw than long.
							private long answer=0;
							
							//method to calc sq root
							public long getSquareRoot()
							{
							If (sqNumber=&gt; 0)    	//This is the precondition assertion makes sure the number rooted is greater than  		or equal to zero done using if statements
							answer== math.sqroot(sqNumber)
							return answer;
							}
							
							public void setSqNumber(long sqNumb)
							{
							sqNumber=sqNumb
							}
							
							
							private Boolean checkAnswer() //method used to make case for assert expresion it only accepts boolean
							{
							if (answer=&gt;0 )
							return true;
							}
							Assert checkAnswer();//  if assertions are allowed this gets executed everytime the class is constructed or a 			method is called
							}
							
							
							Class Stack
							{
							List stack(); //precondition assertion
							
							stack=new ArrayList()
							public void push(int num){
							i==stack.size();
							stack.new(i)=num;
							
							public void pop(int atI){
							if (atI = stack.size() and atI&lt;0) //precondition assertions
							stack.(atI)=0
							}
							
							private void boolean checkStack
							if stack.size()=&gt;0
							return true;
							
							Assert checkStack() //postcondition assertion and invariant
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="68" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="37" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A footballer often switches positions, for example if a goalkeeper is sent off a defender may have to take his place. Also, a defender will always have striking attributes as well as a striker having defending attributes. This suggests the use of inheritance is inappropriate as a Stiker or Defender is-a-role-played-by a footballer, as opposed to a concrete entity. This means a restructuring would be requried where a class Footballer could become a client of FootballerSkills which depicts how good a certain player is in all aspects. This is known as delegation, where Footballer becomes a client of FootballerSkills.
						
						For WayneRooney extends Striker, this is a bad use of inheritance as it is a mapping from the real world to Object Orientated programming that doesn&apos;t exist. A WayneRooney could not be a cohesive class as a WayneRooney would have to depict all sorts that is not a Striker, Striker may only play a small role in a WayneRooney.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a case of implementation inheritance. Although the is-a test is true as every TrafficQueue can be seen as a car with a car in front and a car behind (like an ArrayList), this use of inheritance has problems. The user has been exposed to all other public methods in ArrayList, which are not at all appropriate to a TrafficQue.
						
						For example, elements (cars) could be manipulated in ways that a TrafficQueue class should not allow. Cars could be removed from the wrong parts of the list and so on.
						
						A better method to use here would be to make TrafficQueue a client of ArrayList via delegation. An even better way would be to use just List as to make the actual list changable even at runtime. For example:
						
						public class TrafficQueue {
						List trafficQueue;
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class CameraPhone extends MobilePhone, DigitalCamera - here a CamaraPhone is said to be a digital camera. This is dubious as it could be seen as having a digital camera, without the functionality of a standalone digital camera. A CameraPhone is-a mobile phone completely so a better way to represent this class could be:
						
						public class MobilePhone extends PersonalElectronicEquipment {
						DigitalCamera camera;
						
						This is the process of delegation, where MobilePhone becomes a client of DigitalCamera. Without a camera, the MobilePhone here would still be valid
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This use of multiple inheritance is warrented as the clone mechanism is a fundamental one in java. A book is an information source and copyable (as an object), therefore this should be valid.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						public class NoAnswerProvided extends Answer - here it suggests that a NoAnswerProvided is-a Answer when this is simply the case of a blank TextAnswer. This is a case of overclassification as there is no need for it, therefore, this could be simplified, via parameterisation, to :
						
						public class TextAnswer extends Answer {
						(Where the string is inputted as &quot;&quot; i.e an empty string.)
						
						NoAnswerRequired is a bad classification as it is not an answer. This could be paramertised as a special case in the above as a particular string,
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is the process of hiding the implementation of a particular object. It is often the case that a class exists for some aspect of a program that you are writing, and this would be useful you to incorporate in your own program. Encapsulation helps this process along by giving the user interfaces which model a classes behaviour, without having to know how the class has been implemented. This means that users can use other classes without having to get stuck into how the particular class has been implemented, they can simply use the interface and use the methods they want.
						
						Without encapsulation, re-using other peoples code would be much harder as it would be the case where you have to look at the code and make sense of it. Encapsulated objects provide interfaces with an easy to follow set of operations that a class implements. This means a lot of time is saved when writing a program.
						
						Abstraction is neccessary as it can help model situations more realisticly, and therefore give programmers a better sense of classification.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is true because interfaces such as the Map or List interfaces have been developed by professionals over time, using the most appropriate design patterns to maximise performance. By the use of encapsulation, this functionality can be brought to the average user by sharing the expertise that has gone into implementing the interface.
						
						Many fundamental interfaces (like Maps, Lists, MAths) have already been implemented professionaly, so for the average user it is the case of finding the correct interface for their programs needs and using it accordingly. If a user was not to use an implemented interface, it would be very hard to end up with a program that is efficient as what professionals have achieved over years of improvement, especially when interfaces such as Lists are a small part of an overall program (yet fundamental)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is true because storage management is a very difficult process. With the process of encapsulation, underlying details of the system are avoided so implementing storage management is easier and cleaner. Also, it will help the compiler know when objects are finished with so the management can clean up areas that are will no longer be used.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A contractual interface can be seen as a specification of sorts for a particular object. Design by contract needs a precise specification in order to guarentee any validation, so this would be used in defining the contract. The interface of an object helps define/model what it is supposed to do, and design by contract constricts this. Without knowing what a class is supposed to do, there is no way the class can be constricted and contracts would then become pointless.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of introducing contracts is to maintain the correctness of a program in relation to its specification. Contracts can help to validate a class. With contracts, the various methods in the class library would guarentee that they function correctly if their pre-conditions are met, i.e their post-conditions will be satisfied if their pre-conditions are met.
							
							To define the contracts, the specification has to be reviewed as to pick out the pre and post conditions of methods and class invariants. To define them within the code, it depends what language the classes are written in. Java, for example, provides the key word assert which defines a boolean that must hold, otherwise an AssertError is thrown. For example, assert x&gt;y;  This would throw an error if x&lt;=y. Asserts can be used for both pre and post conditions.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							SqRoot class would have perhaps a constructor that takes a real positive number and the methods getSqRoot and setNumber. A constructor for every type of number would have to be introduced if it is the case that the class has to deal with any type of number.
							
							Assuming that we are not dealing with the square root of negative numbers (complex numbers), the constructor would have the pre-condition that the incoming number is &gt; 0. This number should be able to be of any type.
							
							The getSqRoot method would have the pre-condition that the current number is &gt; 0 and the post condition that the displayed result is correct to at least the degree specified in the specification. Its post condition would be that the result is correct to a pre determined threshold.
							
							Assuming only integers are allowed as parameters (for simplification) :
							
							public class SqRoot {
							
							public real getSqRoot(int number)
							{
							/* pre : number &gt; 0 and an integer */
							/* post : computed precision &gt; threshold */
							return (computed square root)
							}
							
							To actually code the assertions, the keyword assert would be used which evaluates a boolean expression. If this evaluates to false, the contract has been broken and an AssertionError will be thrown.
							
							Stack class would have the methods : void push(Element element), Element pop() associated with a stack. The stack could have a generic List to implement the data structure, which could be a specific type of list (changable at runtime).
							
							The pre conditions of push would be that the size of the stack &lt; size of the max stack, and the post condition would be that the stack has been updated with a new element.
							
							The pre condition to pop would be that the stack has at least one element and the post condition would be that the stack has been updated with one less element.
							
							public class Stack {
							
							List stack;
							
							public Stack(){
							stack = new LinkedList()
							}
							
							public void push(Element element) {
							/* pre : stackSize &lt; maxSize */
							stack.add(element)
							/* post : stack has 1 more element */
							}
							
							public Element pop() { // psuedo code
							/* pre : stackSize &gt; 0 */
							Element last = stack.get(lastElement);
							stack.delete(lastElement)
							return last;
							/* post : stack has 1 less element */
							
							The class could have a class invariant that ensures the stack size is always &lt; its max size, and that it&apos;s size is always &gt;= 0.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						You can inherit from SqRoot and Stack, where the assertions are also inherited. This means both will function correctly as long as they are correctly called. The assertions can be changed via inheritance overriding, where the pre condition has to guarentee less than or equal to previous amount of cases, and the post condition has to guarentee at least as many cases (or more).
						
						The program would have methods to pop an element (number) which would then be passed to sqroot. Without inheritance, this program would be like :
						
						public class SqRootStack {
						
						Stack stack;
						
						public SqRootStack() {
						stack = new Stack()
						}
						
						/* pre : stack has at least 1 element of an integer*/
						public real getSquareRoot() {
						return new SqRoot(stack.pop());
						}
						/* post : stack is updated */
						Class Invariant : Stack always has &gt;= 0 elements.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="69" examId="CS310105" timeTaken="5620" isSubmission="true" allImages="true">
		<compositea marksAwarded="30" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						An abstract class is appropriate for defining the supertype only when all possible instances encapsulated in that class can be instantiated usings its subtypes. In this case, that may be appropriate - the code states that all footballers are either strikers or defenders.
						
						The use of a singleton class here may be slightly odd, but it&apos;s not possible to tell without details of the implementation differences between a generic Striker and [a] WayneRooney. I am, of course, assuming that it is a singleton class; the implementation gives no suggestion.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It may be the case that at a later point in the development of this piece of software an ArrayList is no longer suited to modelling a queue of traffic. If this occurred, and it became necessary to change the supertype of TrafficQueue, then the majority of the class would have to be rewritten to cater for the new supertype. It might be better, in this instance, to use delegation: create an instance of an ArrayList inside the TrafficQueue class, and pass calls to and from at as appropriate.
						
						public class ArrayList { ... }
						
						public class TrafficQueue {
						private ArrayList aList;
						public TrafficQueue ( ... ) {
						this.aList = new ArrayList ( ... )
						...
						}
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						As MobilePhone and DigitalCamera both extend PersonalElectronicEquipment, they are likely to have functions that are identically specified, but implemented differently (as overwritten from the superclass). If this is the case, then subclassing CameraPhone from both DigitalCamera and MobilePhone becomes less useful as functionality is lost (the functions cannot be merged, and therefore must be rewritten).
						
						A better way to do this might be to copy the MobilePhone and DigitalCamera interfaces into the CameraPhone class, then use delegation to pass calls to instances of the MobilePhone and DigitalCamera classes contained within the CameraPhone class:
						
						public interface MobilePhoneInterface { ... }
						public class MobilePhone
						extends PersonalElectronicEquipment
						implements MobilePhoneInterface { ... }
						
						public interface DigitalCameraInterface { ... }
						public class DigitalCamera
						extends PersonalElectronicEquipment
						implements DigitalCameraInterface { ... }
						
						public class CameraPhone
						extends PersonalElectronicEquipment
						implements MobilePhoneInterface, DigitalCameraInterface {
						
						dCamera = DigitalCamera ( ... );
						mPhone = MobilePhone ( ... );
						...
						public CameraPhone ( ... ) {
						this.dCamera = DigitalCamera ( ... );
						this.mPhone = MobilePhone ( ... );
						...
						}
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This seems reasonable enough, but there doesn&apos;t seem any point in instantiating a Copyable as it stands, so it should be abstract at the least. Moreover, there cannot be any meaningful default code specified in the class (as it copies instance variables, but has none in and of itself, and doesn&apos;t know what instance variables subtypes may have). This implies that it should simply be an interface:
						
						public interface Copyable {
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable {
						...
						public Object copy() { ... }
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Assuming the design of the system mandated that this information should be stored as a hierarchy of classes, this implementation seems reasonable. However, it might be better to add another layer, so that &apos;meta-answers&apos; are easily distinguished from real ones (classes shown where differing from question):
						
						public class MetaAnswer extends Answer { ... }
						//If Answer defines a getValue() or equivalent method, this might implement it to return null
						// or a logically equivalent value
						
						public class NoAnswerProvided extends MetaAnswer { ... }
						
						public class NoAnswerRequired extends MetaAnswer { ... }
						
						It may also be necessary to provide a higher degree of distinction between the NoAnswerProvided and the NoAnswerRequired classes; the names imply that you (should) get both or neither. Perhaps the most obvious way to fix this would be simply to change the semantics (renaming NoAnswerProvided to RequiredAnswerNotProvided). If the system at large was expecting instances of both simultaneously, this seems slightly odd, as NoAnswerRequired would be describing the question instead of the answer, and logically should not be subclassed from Answer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a generic solution to a recurring problem within the field of software engineering. It indicates the standardised way that these problems are solved, and provides sample implementation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The Composite design pattern could be used to develop the system such that it could provide a consistent interface to the varying types of questions. This would be done by creating a class that could represent any given question, interfaced in such a way that regardless of the actual type of the question, the methods used to manipulate the data remain consistent. The application logic for differentiating between different questions would be internal to this class, and transparent so that it would not be apparent to its clients. Questions would be implemented using a variety of classes.
						
						The alternative would be to attempt to write the question classes in such a way that regardless of the question type, the interface remains the same. The problem with this is that because they contain fundamental differences with regard to the type of information they can hold at becomes necessary to specify - albeit via the interface - what is being created. Using a composite class gets around most of these problems.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						A ClassFactory pattern would be useful in actually creating the question classes, as it would allow the client to specify the type of question (and thus what class encapsulates the question) at creation.
						
						Client and Server patterns would simplify the design and implementation of both the invigilating server and the client applets by helping to determine the structure that they should take.
						
						A List pattern would be useful in storing both the questions and the answers to them, although it would probably be necessary to make it serialiseable in order for the data to be transmitted appropriately.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Introducing contracts makes it easier to ensure that the classes are working correctly, and that they are being used correctly, as well.
							
							For each method, it would be necessary to create a set of pre- and post-conditions. These are conditions that must hold true before and after (respectively) the method is called. The easiest way to implement these in Java is to wrap them (as assert statements, which raise errors if found to be false) around the methods.
							
							It would also be necessary to create the class invariants. These are rules that must always hold true whilst the class is in use (for instance, class.arrayIndex &gt;= 0). These might be implemented by creating wrapping functions around private data members (get() and set() methods) that use assert statements to validate the invariants, as before.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							public class SqRoot {
							public real getSqrt(real square) {
							//preconditions:
							//cannot be imaginary
							assert(square &gt;= 0);
							//any other necessary preconditions
							...
							result = math( ... );
							//postconditions:
							assert(resultIsReal) //no obvious postconditions without implementation
							//et cetera
							return result;
							}
							}
							
							public class Stack {
							private StackUtilObj stack;
							public Stack() {
							this.stack = StackUtilObj ( ... );
							}
							private getStackItem() {
							oldStackSize = this.stack.stackSize()
							assert(oldStackSize &gt; 0); //precondition checking
							result = this.stack.pop()
							assert(this.stack.stackSize() &gt;= 0); //invariant checking
							assert(oldStackSize - this.stack.stackSize() = 1) //postcondition checking
							return result
							}
							private setStackItem(real newItem) {
							oldStackSize = this.stack.stackSize()
							this.stack.push(newItem)
							assert(this.stack.stackSize() &gt;= 0); //invariant checking
							assert(this.stack.stackSize() - oldStackSize = 1) //postcondition checking
							}
							public void push(real newNum) {
							//no obv. preconditions
							this.setStackItem(newNum)
							assert(this.stack.stackSize() &gt; 0) //postcondition checking
							}
							public void pop() {
							assert(this.stack.stackSize() &gt; 0)
							return this.getStackItem()
							//no postconditions not invariant or differential (already checked)
							}
							}
							
							
							-----
							The additional layer of complexity in the Stack implementation is caused by the wrapping of Stack.stack with invariant checking.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The program would instantiate a Stack and a SqRoot. It would fill the Stack object with as many numbers as it wished to check, then would call sqRootInstance.getSqrt(stackInstance.pop()) for as many times as numbers it put in.
						
						Utilising the Stack and SqRoot classes would provide a less error-prone system, as most potential problems in the implementations would come to light when they broke pre/postconditions, or invariants. The fact that each method of each class checks both (where appropriate) means that it would become extremely simple to determine where in the code there was an implementation error.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="70" examId="CS310105" timeTaken="4947" isSubmission="true" allImages="true">
		<compositea marksAwarded="20" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The inheritence here falls over as in football it is possible for players to play in different positions (most notably Chris Sutton for both Blackburn and Celtic - a striker by trade but he also regularly played as a centre half, a defensive position), so perhaps the position of the player could be parameterised as part of the Footballer class.  Also, it makes no sense that Wayne Rooney would be better an extension of a class rather than an instance of the of a class.  The Footballer class or the Striker class should be parameterised to allow Rooney-esque qualities when constructing an instance e.g
						
						Striker (name &quot;Wayne Rooney&quot;, value shotPower 95, value pace 60, value intelligence 3)  etc ...
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Although a Traffic Queue may be implemented as an Array List, it should not be a subclass of ArrayList (it fails the is-a test)  It should instead delegate e.g
						
						public class TrafficQueue
						{
						private Arraylist Queue;
						public getQueue { return (Queue) };
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Classes MobilePhone and DigitalCamera both are correctly sublasses of PersonalElectronicEquipment, but CameraPhone should not directly inherit from the DigitalCamera class.  It instead should delegate both the necessary qualities from the MobilePhone and DigitalCamera classes e.g
						
						public class CameraPhone extends PersonalElectronicEquipment
						{
						private MobilPhone mobile;
						private CameraPhone camera;
						public GetMobilePhone { return mobile};
						public GetCameraPhone { return camera };
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Here, the class Book uses multiple inheritence, inheriting from both InformationSource and Copyable.  However, Java only allows for MI for classes that are interfaces, yet the class Copyable clearly includes a public object.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Here it is unnecessary to have a class for NoAnswerRequired.  It would be better to parameterise NoAnswerProvided so that we can check whether an answer was actually required or not e.g
						
						public class NoAnswerProvided extends Answer
						{
						private boolean isRequired;
						public getRequirement { return (isRequired) };
						}
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Encapsulation is at the very core of OO development.  As abstraction is what provides a module with it&apos;s interface, it requires that the data and methods within are encapsulated and hidden away from other modules - the innerworkings are not needed to be known, and shouldn&apos;t be accessible to other parts of a larger program.  If all dealings between modules is via the interfaces then it allows for loosely coupled modules (which means they are not strongly interdependant and therefore changes to one module should not adversely affect others) and also means that a given module will be highly cohesive.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Implementing a conservative garbage collector (e.g to help along Java&apos;s inbuilt GC) can help improve runtime (as the GC has a hit on performance of up to around 15%), though this is not generally recommended.
						
						Also, such is compilation, that static, encapsulated data will be located in optimised areas on a disk such that disk read times would be minimised.  Without encapsulation the data could be spread out across the program and would therefore take a performance hit.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Implementing a conservative data allocator and garbage collector can enable data to be both allocated and deallocated manually rather than left up to a garbage collector.  Encapsulation helps as no module will ever be able to deallocate data needed by another module.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design by Contract is the principle in which different modules or packages have a specific demands on what they expect of each other.  By having strict preconditions and postconditions from a contract, it is possible to develop modules independantly and allow each to operate in ways unknown by the other.
						
						If data and methods are not encapsulated, then modules could tinker with each other in ways beyond their interfaces, and the results could result in unforseen unchecked errors and also would make adapting and maintaining individual modules much more difficult.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<freeTextAnswer marksAwarded="0" isMarked="true" notSelectedForMarking="true">
					<answerString>
						A design pattern is a reusable design structure that can be applied to solving different problems.  Much like how a module of code is designed to be reusable, a Design pattern is also considered to be reusable in that similar patterns are handy for implementing different things.
					</answerString>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<compositea marksAwarded="5" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts are required so that any interdependancies between modules are strictly governed by an understood set of rules i.e pre and post-requirements for any given operation.  So, for example, an operation A might have a contract   {P} A {Q} ... where P is the pre-condition and Q is the post-condition.
							
							In Java, this is implemented by using assertions.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="3" isMarked="true">
						<answerString>
							public class SqRoot
							{
							private Stack stack (10);
							public getStack { return (stack) };
							public getSquareRoot ( int n );
							}
							... the getSquareRoot method would have the preconditions that n is greater than 0.
							... and the post-condition that the return value was the square root of n.
							
							public class Stack
							{
							Stack {size n};
							}
							... the constructor of the class would contain the pre-conditions that n is neither null, or less than stack.length.
							It would be implemented by assertions.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The benefits of using DbC for SqRoot and Stack means that there will be no erroneous data being sent to the appropriate methods, severely decreasing the likelihood that there will be any unchecked errors during testing.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="0" isMarked="true" notSelectedForMarking="true">
					<answerString>
						Javabeans is operated with a GUI, in that JB components are dragged and dropped together.  However, JB could not cater for the complexitites of the interfaces.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="71" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="38" isMarked="true">
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						While the above merely passes the &apos;is-a&apos; test (a Striker is-a Footballer, and the same goes for a Defender - and apparently WayneRooney is-a Striker in THIS case, but it would be more correct to say that WayneRooney plays-the-role-of a Striker - after all he could change position in some other game), the sensibility of this approach actualy depends on the amount of differences between the methods these classes implement. There is no point in having seperate classes for different kinds of footballers if their methods differences are subtle and we could combine these differences into one class (and then WayneRooney -and every other footballer- would extend that class). We could deal with this using other approaches, such as for example passing an extra argument indicating the kind of footballer we are talking about.
						So, in this case, when we wanted to create a new instance of a Footballer we would have a constructor that would get (possibly among others) an argument (could be a String or an Integer) indicating the kind of footballer we want to create.
						
						On the other hand, if the actual differences between different kinds of footballers are a lot, following this approach would lead to a lot of possible complications and the resulting code would be quite unclear, so the approach followed in the question would be more appropriate.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						While the above is not absolutely wrong (it would work, of course!), it&apos;s not a good example of OO programming. In this case the class TrafficQueue extends ArrayList, which might be fine under the first implementation, but if -at a later time- we wished to change the actual implementation and use another kind of list (again from the Java library class) that would be more tricky. There are lots of reasons why we might want to make such a change (e.g. for performance reasons) and the best approach in this case would be to use the List Interface, which is defined in the standard Java library. This is generic enough and all the library implementations of List (such as ArrayList) implement this interface, so we wouldn&apos;t have to change much of our code to use another implementation of the List interface (even our own implementations that implemented this Interface).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Again, as in Question 1.1, the above pass the &apos;is-a&apos; test (all of them are-a PersonalElectronic Equipment), but in this case:
						
						1) It is doubtful wether a MobilePhone, a DigitalCamera and a CameraPhone have all that much in common that would reason the use of a superclass for all of them.
						
						2) Most importantly, the CameraPhone Class extends two Classes that both extend the same abstract superclass - PersonalElectronicEquipment. This causes some important problems (common in Multiple Inheritance cases), such as what will happen if there are multiple implementations of the same methods in different Classes (e.g. a different implementation of the &quot;turnOn&quot; function in Classes DigitalCamera and CameraPhone).
						
						A better approach would be to have two abstract superclasses
						
						public abstract class Phone {...}    (with methods such as callNumber, hangUp etc)
						and
						public abstract class Camera {...}   (with methods such as takePicture etc)
						
						and then
						public class MobilePhone extends Phone {...}
						and
						public class DigitalCamera extends Camera {...}
						and finally
						public class CameraPhone extends Phone, Camera {...}  (so it would have all the methods it needed, like callNumber, hangUp, takePicture etc)
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In this case, Copyable is actualy an attribute of the Book. It is not exactly right to say that Book extends Copyable (since a book is-a copyable isn&apos;t very sound but could stand in some cases, depending on the context) and we wouldn&apos;t be able able to use a book in a collection of copyables in some cases (we might want to make a distinction between different kinds of copyables - e.g. books, musical CDs, DVDs, Photographs....). In the end it largely depends on the case/context and while in some cases it might be correct, in some it won&apos;t. It&apos;s seems  controversial and instead we could just provide a copy method - which would also solve the problem of having to override the default implementation, in case we don&apos;t want shallow copies of the book to be made (there is usualy no point in having shallow copies books of a book in a library!)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The above is a completely wrong approach to the problem. An answer of course is-a Answer in any case, whether it was required or not and whether it was used or not. On a theoretical base, its very nature doesn&apos;t depend on if the student answered it or not, or if it was actualy picked from the set of question in the question bank or not. So the above is not a correct representation of the &quot;actual world&quot; entity.
						In addition, under a technical/programming view, the above would not work since a question&apos;s state could (and most probably will) change during the runtime. We can&apos;t say in advance (during the programming phase) if a question will be selected from the question bank or not (would it be an instance of NoAnswerRequired or not?) or if it will remain unanswered (so it would have to be an instance of NoAnswerProvided).
						So, the best approach would be to have a:
						
						public abstract class Answer {...}  (a better name would rather be Question)
						that sever different KINDS of questions would extend, such as:
						
						//for multiple-choice questions
						public class MCQAnswer extends Answer {
						private boolean Required;
						private boolean Answered;
						
						public boolean isRequired {return Required;}
						public boolean isAnswered {returne Answered;}
						.......
						}
						
						//for questions requiring text answers
						public class TextAnswer extends Answer {
						private boolean Required;
						private boolean Answered;
						
						public boolean isRequired {return Required;}
						public boolean isAnswered {returne Answered;}
						.......
						}
						and so on....
						The provision of the isRequired and isAnswered methods gives a uniform way to treat all questions and solve the &quot;problem&quot; we have of indicating if the question was used or not and if it was answered or not.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A Design pattern is a collection of general classes and/or Objects that can be adapted for use as a solution under a general problem domain. They are general enough to be used as a solution to a set of different kinds of problems, yet sufficiently structured in a way that enables us to use them as patterns of programming.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In the case of any Exam, there is set of different kinds of questions. There can exist simple text questions, multiple-choice questions, questions that require the fill-in of blanks etc. It would be a really hard and complicated job to have to apply different methods to the questions of an exam based on their type, to get their marks, the given answers etc.
						The Composite design enables us to have the same basic set of methods that can be applied to any kind of question, regardless of its particular type. We don&apos;t have to know the exact type of the question to be &quot;processed&quot; during the programming phase (and actualy there is no way to know this in advance, of course!), but the right type is determined during the runtime and the correct method is selected automaticaly based on this very type. The respective method knows how to handle the specific kind of question we are interested in at the time and we get the answer we want without having to worry about the actual implementation of the method. Taking advantage of this, we can for example get and add all the marks of the several kinds of questions in an Exam with a simple &apos;for&apos; loop that would apply/call the same method on every different question in the Exam.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						One design that would be very helpful in this case would be the proxy dessing pattern. Since JavaApplets are used and the exam can be taken from anywhere in the world, we have to ensure a secure way for the clients to communicate with the server. The clients could operate under a lot of different setups/environments (web browsers, operating systems etc) and so could the server (and although we know about the server, we have no way of knowing about the client in advance). So the use of a proxy (in conjuction with an &quot;adaptor&quot; for the &quot;translation&quot;/adaption of the messages exchanged between the client and the server) could ensure a secure and flawless communication between the server and the different clients.
						Towards this goal, the Singleton design pattern would be quite useful, in case there is a system/communications problem. Since the users would connect remotely over unreliable network connections, we have to ensure that at any time only one instance of the respective exam object is created and used (in case for example the client would try to reconnect after a network failure). Using the Singleton design pattern can ensure that in if there is no exam object one will be created but if there already exists one it is this object that will be returned and used.
						Another useful design pattern could be the Observer design pattern: as in this very exam, there is the need to save the answers based on certain actions of the user (in addition to probable timed intervals). If for example the user finishes answering one question and clicks on a tab to select the next question, his current answer must be immediately saved and forwarded to the server. We could have several observers attached to the tabs, selection lists etc that would trigger the respective procedure required after a user action would occur.
						Last, but not least, the Visitor design pattern would also be useful in this case, since as desribed in the previous subquestion, we need to mark/present/use a bunch of different kinds of questions in a uniform way. These are obviously saved using a particular data structure (e.g. a tree structure) and can be &quot;visited&quot; by a visitor for example to gather all the marks and sum them up to get the final exam mark.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							Since this would be a class library for an object-oriented programming language, it would obviously be used several times by several different programmers in several and probably extremely different cases/contexts. It is therefore very important that certain prerequisites are followed, both by the client (e.g. provide values in a certain range) and the very class (e.g. that the answer is never &quot;null&quot;). If the preconditions are met (which is beneficial for the programmer of the library), the class must be guaranteed to provide a result that adheres to the postconditions and this of course is beneficial for the client. Of course, in all cases it is very important that the client knows what he/she has to provide to the class (e.g. two String Objects) and what he/she should expect from it (e.g. a String Object representing the concatenation of the two String objects provided)
							The definition would have to follow certain rules of the Design by Contract approach. The prerequisites could be described in a seperate file, which is not a very good practice, because it decouples them from their use, or we could define them inline with the code using a special notation and have special tools produce seperate documents as required (e.g. Javadoc).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="6" isMarked="true">
						<answerString>
							Using Design-by-contract we could have a definition like the following rough outline:
							
							Class SqRoot:
							Double SqRoot (Integer X):
							requires: Integer X &gt;= 0
							returns: Double Y &gt;= 0, Y*Y=X
							
							The above say that the SqRoot method gets an integer which MUST be greater than or equal to zero and returns a Double which is greater than or equal to zero, which when multiplied by itself gives X (=is the (positive, of course) square root of X)
							
							Class Stack:
							Boolean addElement (Integer element) throws stackFull exception:
							requires: stack not full
							returns: true if succeeded, false if failed
							Integer removeTopElement () throws stackEmpty exception:
							requires: stack not empty
							returns: the element at the top of the stack or null if failed
							Integer getSize ()
							requires: --
							returns: the size of the stack
							
							The above say that the class stack has three  methods, namely:
							1) addElement which requires an Integer and returns true if the operation was sucessful or false if for some weird reason it wasn&apos;t able to perform the operation (e.g. memory problem) and throws a stackFull exception if the stack is full (just in case the Precondition is not met).
							2) removeTopElement, which returns the element at the top of the stack, provided the stack is not empty, or null if the operation failed (e.g. because of a memory problem). In case the precondition of the stack not being empty is not met, it throws a stackEmpty exception.
							3) getSize, which returns the size of the stack as an integers and has no preconditions
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public static void Squares(Stack st) {
						int sum;
						
						for (int i =0; i &lt; st.getSize; i++){
						sum+=st.removeTopElement(i);
						}
						
						return SqRoot(sum);
						}
						(sorry, no more time to better write the code... :-(  )
						
						The benefits of using SqRoot and stack are that we can treat all objects of the stack in the same way by only having a for loop and getting all the elements of the stack until it is empty and then return the result by having a single call of SqRoot and that we are certain and assured by the precondi
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="72" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="25" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						i) The use of inheritance in the first two examples can be valid since the subclasses pass the &apos;is-a&apos; test, But alternativelly it can be  thought of in the following manner
						
						because footballer can be a role played by striker and defender, we can decide to have both these classes as clients of Footballer:
						i.e: public class striker{
						public Footballer = .....;
						}
						and
						public class Defender{
						public Footballer =...
						}
						ii)The use of inheritance here is not justified. Even though WayneRooney passes the is-a test for implementation inheritance, Striker is also &apos;is-a-role-played-by&apos; Wayne Rooney which means that delegation of the class Striker would be more appropriate.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The use of inheritance in this context could restrict code to any future extensibilities.
						The &apos;is-a&apos; test for TrafficQueue and ArrayList is very ambiguous.
						Instead of implemnting this application with inheritance it would be more appropriate to use delegation of a List(not an ArrayList) to allow for flexibility, extensibility and dynamic binding as follows:
						
						public class TrafficQueue{
						List trafficList;
						public TrafficQueue(){
						trafficList =  new ArrayList(..);
						}
						}
						
						This way when we want to change the collection we are using it would be a matter of mdifying the constructor. Beacuse we&apos;ve implemented the interface not the calss.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of inheritane for MobilPhone and DigitalCamera is justified. They both pass the &apos;is-a&apos; test for a personalElectronicEquipment;
						For the CameraPhone: it could be mildly acceptable to have it the way it is, but because MobilePhone and DigitalCamera are characteristics, which means we might want to add onto them in the future it would be more appropriate to implemnt this using delegation.
						i.e:
						public class CameraPhone{
						
						MobilePhone theMobilePhoneInMe = ..;
						DigitalCamera theDigiCamInMe = ..;
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of inheritance in this context is justifiable.
						Alternative:
						
						//the interface that defines the behavior of a book
						public interface copyable{
						
						public abstract Object copy();
						....
						}//
						
						//The Book class has to define the method copy
						
						public class Book extends InformationSource implements copyable{
						
						...
						public Object copy(){//the definition of copy()...}
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						NoAnswerProvided could be implemented as a varible inside both TextAnswer and MCQAnswer it could the n be set to a certain value to assertain whether the answer had been given or not.
						eg:
						public class TextAnswer extends Answer{
						
						//the constructor with the variable that determines whether an answer has been given.
						public TextAnswer(int noAsGiven){
						.........
						}
						}
						
						Since NoAnswerRequired is not actually an answer we could also represent it as variable in both the MCQAnswer and the TextAnswer as above.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						-Encapsulation is a way of defining software components in such a way that the users of the component(client) do not have the information about &apos;how&apos; the object has been implemnented, just the documentation of how to use it. This is also refered to as information hiding.
						-Abstraction defines the way modules within an encapsulated system interoperate and relate one to the other.
						-Encapsulatiion is therefore fundamental to object oriented programming beacause the essence of OOP is the separation of objects according to certain criteria. Encapsulation can also be used to enforce certain behavior in a software system and can be used for visibility control.
						e.g: Encapsualtion of a group of classes by an interface enforces the client classes to (at least) define the methods given in the interface.
						e.g2: visibility control: making instances private( only visible within class) or public(visible everywhere) etc.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation can help Manual storage management by :
						if a component with pointers to a locatin in memory the sub components of this object which point to another location in memory should be deleted when the encapsulating object&apos;s reference to memory is delerted( ie destroyed)
						an example of this could be a struct in C. The varaible pointers in the struct should be destroyed when an instance of the struct itself is destroyed.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						For Design by Contract encapsulation can be a prerequisit by:
						- the assumption that calling a method m() from class x assumes that the method is encapsulated inside class x, as
						a pre-condition to the call.
						- The invariants of a class could be implemented through encapsulation. eg: having a method that sums up all the invariants of a class and returns a boolean. We can then call the method to test the class invariat. i.e
						
						.............
						//the method that sets the class invariant
						private boolean meth(){ return x==y;}
						.......
						//the call to check that the invaraint has been satistfied.
						invaraint meth();
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="8" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							-Contracts are binding agreements between a client object and a server(supplier) to perform certain tasks:
							the client client has to satsfy the pre-condition{P} before sending a request to the supplier, given the precondition, the supplier will be bound to provide a stste that satisfies the post condition{Q} after an operation A.ie: {P}A{Q}
							-The purpose of introducing contracts is to make sure that bussiness rules are enforced and unchecked errors(at least some) are avoided.
							This allows for a smooth running of a given process.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							SqRoot:
							To find the squre root of a number x, we need to make sure that(the pre-conditions {P}:
							1. the number is not negative
							
							After the operation we should get(post-conditions):
							1. the positive and the negative square root of the number x;
							
							In java this could be implemnted as follows:
							
							class SqRoot{
							.....
							double[] sqrt(double x){
							double[] ans=..;
							//the declaration of the invariant (pre-condition)
							invariant x &gt;=0;
							//the calculations for square root - operation
							.....
							return ans[];//the post condition-in an array of doubles.
							}
							}
							
							Stack:
							preconditions and invariants:
							1.stack_pointer&lt;=MAX_STACK_CAPACITY
							2.stack_pointer&gt;=0
							post-conditions:
							if push
							1.stack_pointer++
							if pop
							2.stack_pointer--
							
							In java
							class Stack{
							.......
							//method to set the invariant
							boolean setInv(){
							stack_pointer&lt;=MAX_STACK_CAPACITY;
							stack_pointer&gt;=0;
							}
							void push(){
							//the declaration of the invariant (pre-condition)
							invariant setInv();
							//perform operation
							....
							}
						</answerString>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						SqrtStack:
						to build a program like this one, I would delegate into it both the Stack and the SqRoot classes to make sure that the invariants of the two classes are inforced in this one.
						method:
						I would call SqRoot.sqrt(double) on every entry in the stack to calculate its square root.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="73" examId="CS310105" timeTaken="7163" isSubmission="true" allImages="true">
		<compositea marksAwarded="47" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It is sensible for Striker and Defender to have Foobballer as their super class as this is a form of subtyping, Striker is-a subtype of Footballer and Defender is-a subtype of Footballer too.
						It is not sensible for WayneRooney to be a subclass of Striker.  Although it seems to pass is-a test, WayneRooney is-a Striker.  WayneRooney might in the future be a Defender when he is required to be or when he ia able to take up this position.  So this violate the change rule.  It is better to use delegation, something like this:
						
						public class WayneRooney
						{
						private Footballer myPosition;
						public WayneRooney(Footballer postion)
						{
						this.myPosition = positon;
						}
						........
						}
						
						or we may want to have more that one postion for any footballer then we can keep a Collection of the positons he plays.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						It&apos;s not sensible.  This is clearly an implementation inheritance example.  So it is better to delegate the operations to ArrayList instead of extends it.  We don&apos;t want to expose all the methods in ArrayList to TrafficQueue.  And also TrafficQueue may have lots of operations belongs to itself and the ArrayList part is just a data structure.  It will be better if we do this:
						
						public class TrafficQueue
						{
						private ArrayList queue;
						public TrafficQueue(.....)
						{
						queue = new ArrayList();
						}
						........
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						MobilePhone and DigitalCamera both pass is-a test as they are both PersonalElectronicEquipment.  Subtype inheritance is used here.  I don&apos;t think it is sensible for CameraPhone to extend from MobilePhone and DigitalCamera.  The reason is that MobilePhone and DigitalCamera are just the functions that CameraPhone provides and in the future there could be more functionalities going to be added.  This will violate the change rule.  When we are not sure it&apos;s better to use delegation.  Something like this:
						
						public class CameraPhone
						{
						private MobilePhone basicFuntion;
						private DigitalCamera advancedFuntion;
						............
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Stricltly speaking,  the design is not very sensible.  This is because that class Copyable is used to model a behaviour which is copying.  It doesn&apos;t have general attributes belong to itself.  I would use interface inheriance here, to implement Copyable as an interface.
						
						public interface Copyable
						{
						public Object  copy() {..........}
						}
						
						//Book is-a InfromationSource so we can allow subtype inheritance here.
						//so the Book class should be declared as
						public class Book extends InformationSource implements Copyable {....}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It is sensible for MCQAnswer and TextAnswer to extend from Answer because they both pass is-a test.  They are both subtypes of Answer.  But for NoAnserProvided and NoAnswerRequired is not sensible to extend from Answer as they are not subtype of Answer, they are more of behaviours.  We can have NoAnswerProvieded as an boolean attribute in Answer class and have a defauslt value as true.  We can do the same for NoAnswerRquired for the Question ( if there is one ) class but the default value could be set to false.
						public abstract class Answer
						{
						protected boolean NoAnswerProvided;
						............
						}
						public abstract class Question
						{
						protected boolean NoAnswerRquired;
						............
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design Patterns are communicating classes and/or objects which can be customised to solve a general design problem in a specific context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Composite pattern will need to be used here as there are lots of entities ( potentially objects ) share common attrubutes ( instance variables ) and behaviours ( operations/methods ).  This involves sensible top down design.
						For example:
						public abstract class Question
						{
						.........
						public abstract void toXML();
						.......
						}
						
						Here all the questions will be stored in XML format.  AtomicQuestion is a subtype of Question.
						
						public class AtomicQuestion extends Question
						{
						public int calculatAllocationMarks()
						{........}
						}
						
						MultipleChoiceQuestion is a subtype of Question
						public class MutipleChoiceQuestion extends Question {..........}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						Proxy pattern could be used here as the exams will be taken by the students from all over the world.  Some security checking magnism needs to be implement and Remote Proxy could be could be used too as there is remote data transfer.
						
						Strategy patterns could be used here as the software employs various strategies to present the information efficiently to the marker.  We could have an abstract strategy here as the top level to capture the commonn behaviour.  Various concrete strategies should be subclasses of the abstract strategy to implement specific strategies which can be selected to present the information as requierd.
						
						Observer pattern should be used here as we need to frequently backup the changes the students made on the online exam paper.  When there is updates been made the observable ( client ) shold inform the observer ( the central server ) to act accordingly -- backup the change.
						
						Generalised Singleton pattern could be used here so we could restrict the number of students who can be taking the same exam at a time.  We can allow ensure the load to central server by limiting a fixed number of connection at a time.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Introducing DbC is to express a formal agreement/contract which binds the client( the users) and the supplier(the program).  It enbles us to state the rights and obligations of each parties.
							Pre-condition of a methods defines the states which allow the method to excute properly.  It should be satisfied by the callers from inside/ouside of the class.
							Post-condition expresses the properties that should be held after the excution of the method providing the pre-condition was satisfied when the method was called.
							Invariant defines the global properties that should be held by the class all the time.
							By defining pre-condition, post-condition and class invariant we can ensure the correctness and reliablity of the software.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							Assume that we only interested in finding out the square root of all the positive numbers ( don&apos;t want to going into coomplex numbers ;-) )  Then the pre-condition will be x &gt;= 0 as we don&apos;t allow negative numbers.  The post-conditon will be give the correct answer.  The invariant will be the square the answer should always equal to the input number x.
							
							To implement a stack we use instance variable count to track the number of elements on the stack.
							For push operation:
							pre-condion: the stack is not full -- count &lt; capacity;  post-condition: the stack is updated and add 1 to the count. For pop operation:
							pre-condtion: the stack is not empty -- count &gt;= 1; post-condtion: the stack is updated and count minus one.
							The class invariant will be the number of elements that stored on the stack should be greater or equal to 0 -- count &gt;= 0.  This is established by the constractor.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						We are to pop a number off the Stack and input it to SqRoot.  The numbers stored on the Stack could be any number, possiblly negative numbers.  So the new program should be able to take all the numbers as input -- this has done and &apos;OR&apos; operation on the preconditions of the Stack and SqRoot.  We still need to implement a data validation method to ensure that we only calculation the square roots for positive number although we accept all numbers.  Post-condition will be give correct answers for positve numbers which has been poped off the Stack.  So we are only dealling the numbers strored on the Stack instead of all the positive numbers.  The invariant of the new program will be effectively &apos;AND&apos; the invariants of Stack and SqRoot, which are only perform square root operations on positve numbers from the Stack and the number of elements on the Stack is always greater or equals to 0.  By defining the &apos;contract&apos;s for Stack and SqRoot we can easily derive the &apos;contract&apos; for the new program and we also can ensure its correctness.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="74" examId="CS310105" timeTaken="7199" isSubmission="true" allImages="true">
		<compositea marksAwarded="48" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is not a sensible use of inheritance.  While the class footballer should exist the sub classes Striker and Defender should not.  These two are roles played by footballers, even though they pass the is-a test they are better described as a role-played-by.  WayneRooney is not very sensible as that is an attribute of a footballer not a type of footballer.
						
						public class Fooballer{
						string name;
						string role;
						public footballer(string name, string role)
						{..Set these attributes here..}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is not a good use of inheritance.  A Traffic Queue is not an ArrayList, rather it uses an ArrayList to store the data in the queue.  Whilst we may need some functionality of an ArrayList, such as adding and removing, we do not need the rest of it to model the traffic queue. This is an example of implementation inheritance.
						
						public class TrafficQueue{
						ArrayList traffic;
						//Code to add and remove objects from the traffic ArrayList.
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This could be a sensible implementation depending on the context.  If this is in a store and products are categorised this way then the super class PersonalElectronicEquipment could contain abstract methods for getting price, barcode etc.  However this could be implemteated using parameterisation, rather than having a subtype for each sort of equipment, an instance variable could hold what type it is.  CameraPhone should not be implentated in this way,  multiple inheritance is not the best solution for this.  In a real world definition a camera phone is a phone which contains a digital camera.  An alternative for this could be
						
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						
						public class CameraPhone extends MobilePhone{
						DigitalCamera theCamera;
						public CameraPhone{
						theCamera = new DigitalCamera(....);
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This use of inheritance is not sensible, while the copy() method can be called by every object which inherits from it the implementation may need to be different for different objects.  Also the fact that class Book extends InformationSource, which in itself extends Object, which contains clone(), by default then Book can use either of these methods which can lead to programmers arbitrarily using either rather than being consistent.  An alternative should be that evey class that extends from Copyable should implement its own version of Clone().
						public class Copyable
						public abstract Object clone() { …}
						public class Book extends InformationSource, Copyable {
						public Object clone(){...}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This use of inheritance is sensible for the MCQAnswer and TextAnswer classes as these are both types of answer.  The NoAnswerProvided is not a sensible use, this should be an instance variable inside the Answer class which must be set by all sub classes (constraints would be needed to ensure that the correct value is used).
						Similarly NoAnswerRequired should be a flag inside the Answer class as it is an attribute describing a particular answer.
						public abstract class Answer {
						public boolean noAnswerProvided;
						public boolean noAnswerRequired;
						}
						public class TextAnswer extends Answer {
						public TextAnswer(bool provided, bool required)
						{..Code to set these two values..}
						}
						public class MCQAnswer extends Answer {
						public MCQAnswer(bool provided, bool required)
						{..Code to set tehse values..}
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="20" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						In object orientated software development a developer uses classes provided by other developers or from class libraries such as java.util.  However as a developer I do want to know how that module of code works internally, I may consider Data Structure performance though, but generally I do not want to see the code inside.  Abstraction is how the module presents itself to the outside, its interface.  Because the modules are encapsulated they must provide an abstraction of itself, it was not encapsulated then a developer could get inside it and use it in ways it was not designed for.  With encapsulation the abstracted interface is the only way the developer has of using the code and they are contractually obliged to perform certain functions.
						An example of this is a Data Access Layer I have created.  This piece of code involves several modules which interact with a datastore and build datastructures and then returns them to the user.  These modules are encapsulated together with an interface which is a method call depending on what data the developer wants returned, these calls are the only way of using these modules.  The developer has no control over how the store is accessed or data constructed.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						In code libraries that have been provided with the language, say java.util, then the code will have been written by sofware developers who are experts in that language and have high performance in mind.  Even code that has not been supplied with the language (should have) been optimised so that it runs as fast as possible in a particular environment.  All of this code is encapsulated and we have an interface which allows us to use these pieces of code efficeintly, such as Add and Remove methods in a data structure.  The more encapsulated code is then the looser the coupling can be between them, therefore if we need to switch at runtime then it would be very easy to do so.  For example if we have two types of List such as an ArrayList and a LinkedList and we wanted to change between them at runtime, because they are encapsulated and have the same interface, derived from List, then we can easily switch between them.  If neither of these objects were encapsulated then the developer can code to a specific one and greatly tighter the coupling between the modules.  Then if we needed to change between them then some complex opertation might be needed which would be a performance hit.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						If we have a datastructure which is complex, say a set of objects which define and execute a set of algorithms such as a Maths library, then if it is managing its memory manually then it decides where to store certain items and when to remove these and free up system memory.  It is then very important that the methods which control the memory management are not interferred with from outside the algorithm.  Encapsulation can help with this by hiding the implementation of all the algorithms and allowing just the interface calls the algorithms to be visable.  If the code was not encapsulated then the pointers to the various stores for the algorithm could be open to external manipulation allowing the results to be returned wrong, the software can crash and memory leaks can occur.  The encapsulation must be extremely robust.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Where DbC is concerned the input to a call must satisfy a pre-condition and the output must meet a post condition. Let us say we have a method which goes off to a database and executes a store procedure with some variables and then returns a DataSet.  DbC would allow us to say that it the variables are legal then the method will return a legal DataSet containing the correct results.  With encapsulation we can see that with only the interface of this method call then we can only perform these functions, we do not know how it executes this code, how it connects to a data base or how it constructs the results.  These functions are implemented by other method calls inside the software component.  If this code was not encapsulated and we could see inside it then we could affect the outgoing results, eg we could change the variables to be passed to the database, connection strings and passwords etc.  This would have the effect of breaking the contract because incorrect results, or exceptions, could be returned.  The contract in effect becomes useless if we have the ability to alter how it is executed.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A Pattern of classes/objects which can be customised to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						We can use Composite Design in the following way.  If we consider the questions to be asked in this exam then there are many types of question, multiple choice, multiple answer, plain text etc.  We could therefore have one top level class Question and have others inherit from it.  Furthur more composite questions can have other questions nested inside it.  From this we can deduce that the structure of the questions will be tree like, eg Question 1b part ii.  The composite design pattern can be used to ensure that we treat all parts of this tree in a uniform manner, this can be achieved by dynamic binding.  If we declare an abstract method in a top level Question class and implement it in all subtypes of questions then a call to get marks for all questions would involve calling the same method on Question objects at every node of the tree.  Dynamic binding would then guarantee that the correct implementation of that method is used on the correct subtype of Question.
						One consideration to be wary of when using the Composite design pattern is that the correct data structure is implemtated for storing the objects, this of course depends on how the objects are being used.  The incorrect structure could lead to performance hits.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						Singleton Pattern using Factory Methods:
						The Singleton Pattern defines that only one object of each type is created.  This can be used in this software by having a factory method that creates a new student object with the students unique ID.  A factory method called getStudent(int studentID) will call the constructor on a student object with the ID.  The constructor of the Student object will then either create a new Object representing that student, or if that Student object already exists, will return it.
						Flyweight Pattern:
						During the exam it is highly unlikely that the questions, no matter what type will change, they are immutable.  Usually after they have been set they remain constant.  If the software created numerous instances on the server, one for each person taking the exam then it could take up large amounts of storage and could cause a performance hit as they need to be managed.  Instead create one instance of a Question object and use it mulitple times, the factory method could be used to ensure only a set number, or one, of these objects is created.  This will significantly reduce the storage needed.
						Strategy Pattern:
						This could be used in helping the marking system.  The strategy pattern could be used to define a set of rules, called the Abstract, which describe the basic mechanism for marking an exam.  A set of classes which inherit from the abstract class could then implement different versions of the marking algorithm to present the best possible strategy to the marker, these are called the Concrete Classes.
						Visitor Pattern:
						This pattern could be used when monitoring the applet software.  If the central server wanted to say check the status of every applet running then instead of invoking a check algorithm on every applet around the world (which means running the algorithms remotely) it could visit each one and run the algorithm on each applet itself.  This would keep all the main functionality of applets on the server and not distribute around the world to remote machines.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="75" examId="CS310105" timeTaken="7185" isSubmission="true" allImages="true">
		<compositea marksAwarded="44" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Footballers can play in different positions. They may even change position during a game. As Footballers train they can learn new positions. This is an example of a role played by relationship. A striker is a role played by a footballer.
						
						In this situation is is probably appropriate to model WaneRooney as a Footballer but not as a subclass of striker if this is to be used in a footballing context.
						
						public abstract class Footballer{
						/** store the positions played by this footballer */
						private List positions;
						...}
						
						public class Striker {...}
						public class Defender {...}
						public class WaneRooney extends Footballer {...}
						
						This is assuming that it is known at compile time what players are going to be in the system. This is probably a bad assumption. Better would be...
						public abstract class Footballer{
						/** store the positions played by this footballer */
						private List positions;
						/** Store the players name */
						private String name;
						/** get players name */
						public String getName() { return name; }
						/** Set players name */
						public void setName( String n ) { name = n; }
						...}
						
						public class Striker {...}
						public class Defender {...}
						
						Then to construct Wane Rooney
						
						waneRooney = new Footballer();
						waneRooney.setName( &quot;Wane Rooney&quot; );
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is a bad use of inheritance. A TrafficQueue uses an ArrayList it is not an ArrayList. Using implementation inheritance like this exposes all of the methods of ArrayList to the client. This allows the client to disrupt the properties of the queue by using the ArrayList methods directly.
						
						A better model is a TrafficQueue uses an ArrayList (or better an abstract class List so the implementation can be changed without changing all the code).
						
						Delegation is the sensible method of reuse here.
						
						public interface List { ... }
						public class ArralyList implements List {...}
						
						public class TrafficQueue {
						private List queue = new ArrayList();
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						A camera phone is a Mobile Phone that has a camera.
						
						This is a really messay inheritance tree (or graph as it actually is).
						
						PersonalElectronicEquipment
						/       \
						Mobile   DigitalCamera
						\       /
						CameraPhone
						
						MobilePhone and DigitalCamera both implement the methods in Personal Electronic Equipment. It is not clear which implementation should be used, or what it would manipulate.
						
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class CameraPhone extends MobilePhone {
						private DigitalCamera camera;
						public DigitalCamera getCamera(){ return camera; }
						… }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is reasonable use of Multiple Inheritance. Problems might occur if InformationSource also inherited from Copyable. This kind of operation should only apply to concrete classes. It would be better if it used builtin Language constructs for this operation or another class.
						
						A better alternative would be to have a class that copied Objects in a uniform mannor. A copier class could provide this service eg
						
						public class Copier {
						public Book copy( Book book ) { ... }
						public InformationSource copy( InformationSource is ) { ... }
						}
						
						public class book extends InformationSource { ... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						NoAnswerProvided is a redundant class. It would be better if the MCQAnswer and TextAnswer classes had a method to indicate if an answer had been given. NoAnswerProvided isn&apos;t an Answer
						
						It would also be better if NoAnswerRequired didn&apos;t exist and insted a List was made of all the answers that were required. NoAnswerRequired isn&apos;t an Answer.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design pattern is a general solution to a problem described in a specific context. It provides a &quot;best practice&quot; solution which can be applied in may different sitiations. The are used to convey Expert designs in a uniform language which can be used to discuss patterns and alternatives.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The Composite design pattern gives a method of implementing a tree structure.
						
						Various question types all inherit from an abstract class Question.
						
						A CompositeQuestion class represents questions that are made up from multiple questions (such as this one which is Quesion 3 and is composed of 3.1, 3.2 and 3.3). The CompositeQuestion class operates with a static type of the abstract class Question and by dynamic binding uses the concrete implementation of the Question. More types of Question can be added without changing CompositeQuestion as long as Question doesn&apos;t change. CompositeQuestion can be composed of CompositeQuestions (such as an Exam which may be thought of as a ComposteQuestion of CompositeQuestions).
						
						public abstract class Question {
						/** Return the number of marks avaiable for this question */
						public abstract int getMarksAvailable()
						... }
						public class AtomicQuestion extends Question {
						private int marks;
						public int getMarksAvaiable() { return marks; }
						... }
						public class MultipleChoiceQuestion extends Question {
						private int marks;
						public int getMarksAvaiable() { return marks; }
						... }
						pubic class CompositeQuestion extends Question {
						private List parts;
						public void addQuestion( Question q ) { parts.add( q ); }
						public Question getQuestion( int i ) { return (Question)parts.get( i ); }
						/** add all of the parts and return the marks available */
						public int getMarksAvailable() {
						int sum = 0;
						for ( int i = 0; i &lt; parts.size(); i++ ) {
						sum += getQuestion( i );
						}
						return sum;
						}
						
						The same pattern could be applied to a student&apos;s answers. The answer to any given question could be a number of different types of answer (multiple choice, text etc). The answer might also be composed of several answers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						Singleton:
						In the client application for the exam it would be necessary to ensure that there is only one instance of the exam at anyone time. The singleton patter could enforce this by preventing the exam from being constructed except via a trusted means. eg
						public class Exam {
						private Exam instance = null;
						// only allow one instance of the exam
						pubic static Exam getInstance() {
						if ( instance == null )
						instance = new Exam();
						return instance;
						}
						// private constructor no use from outside of class
						private Exam() { ... }
						}
						
						
						Factory for marking types of question
						The computer could mark multiple choice questions and Programs. A Factory could be used to generate the correct marking mechanism for the question. The marking mechanisms might include ComputerMultipleChoice, ComputerProgram, HumanText. The mechanisms would then determin how the question gets marked. The computer marking questions that it can mark whilst passing on questions it cant to the human operator
						
						
						RemoteProxy for communication with server.
						For communication between the client and the server the RemoteProxy pattern could be used to setup and manage the connection and make the remote procedure calls. The client uses the Proxy class which is an abstractation of the server methods as an interface to the server. The Proxy hides the client server implementation from both sides
						
						Observable for changes to question
						An observer could listen for changes to a text box (observable) on the client and send the answer to the question to the server once it has been answered. On the server the pattern could be used again to listen for completed questions. Once is recieves a message that a question is complete it would then store the answer.
						eg
						public interface Observer {
						public void doThing();
						}
						public interface Observable {
						public void registerObserver( Observer o );
						}
						public class TextBox implements Observable {
						private List observers;
						public void registerObserver( Observer o ){ observers.add( o ); }
						private void tellObservers() {
						for( int i =0; i &lt; observers.size(); i++ ) {
						Observer ob = (Observer)observers.get( i );
						ob.doThing();
						}
						}
						}
						pubic class TextBoxListener implements Observer {
						public void doThing() { ... // send message to server }
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<compositea marksAwarded="7" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts are obligations and benifits that bind a client to the method it is calling. The method has requirements for its arguments and environment and in turn it will provide a service to the client. The client expects a service from the method if it satisfies the methods requirements.
							Design-by-Contract is implemented using pre and post condidtions.
							
							The purpose of introducing contracts for any library is to ensure reliability and robustness for the library. It clearly defines what the client should expect from the library and what the library expects from the client.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The method SqRoot would have a check at the beginning of the method to check that the number that is to be square rooted is real and greater than or equal to 0. In the JavaDoc it would state that the expected return from the method is a real number that is greater than or equal to 0 and when squared equals the paramerter passed.
							
							The numbers involved here are all real because double doesn&apos;t allow imaginary numbers. The type of the argument and return ensure this part of the contract
							
							/**
							* @return Square root of number. return * return = number and return is real
							@throws IllegalArgumentException when the number is out of range */
							public double squareRoot( double number ){
							if ( number &lt; 0 ) {
							throw new IllegalArgumentException( &quot;number must be greater than or equal to 0&quot; );
							}
							// calcualte square root
							...
							return squareRoot;
							}
							
							The class Stack has two methods push and pop.
							Push has the requirements that the stack must not be full before calling and its argument is a number
							Push leaves the state of the stack modified with the last element being the item pushed.
							
							Pop has a requirement that the stack is not empty.
							Pop return the last number pushed onto the stack.
							
							Push ensures that it has a number by having it as the type of its argument. Pop ensures that it returns a number as it has its return type set as number
							
							Stack would have a method empty() which returns true if the stack is empty (false otherwise) and a method full() which returns true only when the stack is full.
							
							Before each Push the full() method would be called. If it returned true an exception would be thrown
							Before each Pop the empty() method would be called. If true an exception would be thrown
							
							public class Stack {
							/** @ return true if the stack is empty */
							public boolen empty() { ... }
							/** @return true if the stack is full */
							public boolean full() { ... }
							/** puts number on the top of the stack. number will be the next value poped. The stack must not be full.
							@throws StackFullException when the stack is full*/
							public void push( double number ) {
							if ( ful() ) throw StackFullException( &quot;Stack is full cannot push&quot; );
							... }
							/** The stack must not be empty
							*@return the last item pushed.
							@throws StackEmptyException when the stack is empty*/
							public double pop() {
							if( empty() throw StackEmptyException( &quot;Pop on empty stack&quot; );
							...}
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Stack ensures that only numbers can be stored in it and SqRoot only operates on numbers. It reduces the number of checks that need to be performed by the client code. The results can be guarenteed if the input is correct. Both classes use Design-by-Contract so they can be relied on.
						
						The program would look like this...
						
						Stack s;
						... // push some number to be square rooted
						Stack result = new Stack();
						while ( !s.empty() ) {
						try {
						double number = s.pop();
						double sqrt = SqRoot.squareRoot( number );
						result.push( sqrt );
						} catch ( StackEmptyException see ) { System.out.println( see ); }
						catch ( StackFullException sfe ) { System.out.println( sfe ); }
						catch ( IllegalArgumentException iae ) { System.out.println( iae ); }
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="76" examId="CS310105" timeTaken="5771" isSubmission="true" allImages="true">
		<compositea marksAwarded="13" isMarked="true">
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Making Striker and Defender subtypes of Footballer is sensible. As they will both want to inherit the properties a footballer has, but are 2 different types of footballer, so this allows reuse of code, but also individuality.
						
						However, making WayneRooney a subtype of striker is not so sensible. I would make an instance of striker and call it WayneRooney instead (even if he is a class of his own).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Basically you want an ArrayList called TrafficQueue. In this case I would just create a new arraylist called TrafficQueue
						
						ArrayList TrafficQueue = new ArrayList();
						
						etc
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						in this example, the CameraPhone uses multiple inheritence from MobilePhone and DigitalCamera.
						
						What I would do is make CameraPhone a subtype of MobilePhone and then just make instances of what you need out of DigitalCamera.
						
						You could also make CameraPhone a subtype of PersonalElectronicEquipment, and then just use instances from MobilePhone and DigitalCamera
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						As book is an information source it should be a subtype of InformationSource. But Book is not a Copyable, but is copyable.
						
						Therefore it shouldnt be a subtype of Copyable. instead, book should maybe have a boolean function in it indicating if it is copyable, and if so then the copyable function will pick up on this and copy it.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						There is no need to create new classes for all the different types of answer. They can all be contained within the original class Answer.
						
						As each type of answer above is almost identical, you can just use if statements inside the class Answer to distinguish and deal with the answer the right way.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</unanswered>
					<freeTextAnswer marksAwarded="0" isMarked="true">
						<answerString>
							the 2 classes, SqRoot and Stack would be defined publically, so they can be accessed externally. They would take the necessary numbers and do the necessary functions with them.
							
							The class SqRoot would take a value, find the square root (x/x) and return it.
							
							The class Stack would be made up of several objects. As it is to manage a stack of numbers, you need to be able to edit the stack, and read through it. If we treat the stack as a push/pop stack, IE using first in last out then all we need is an array, with a method to add numbers which will place the number into the first available position in the array, and a method to get the number out of the array starting at the end.
							
							If we call the add method addtostack. it can take an int and then looks for a null entry in the array, and places in the first available slot.
							
							if we call the remove method getfromstack, it can look for the last entry, read it, place null where it was and return it.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						You would have the class SqRoot (int x){
						if x=0 return(0);
						else{
						float ans = x/x;
						return ans; } }
						
						You would also have the class Stack, with functions addtostack to add a number to a stack, and getfromstack to get numbers off the stack. If the getfromstack returns NULL at the end of the stack, then in a main method, you can use the 2 above classes.
						Put some numbers in the stack, and create a loop that loops until NULL is returned from stack. In this loop it uses getfromstack to get the number off the stack, it then passes this number to SqRoot which finds the square root, and returns it. The number than then be printed on the screen.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="4" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A software component is a block of specially written software, broken up into seperate blocks to be reused and accessed by other applications. EG an DLL file. This contains pre compilled code which can be accessed by other programs so they dont need repeat code in them.
						
						There are many different sorts, eg JavaBeans, COM. They all serve a similar purpose
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The system would be best used if there is a host server, and each client remotely connects to this server. Of course security needs to be implemented.
						
						JavaBeans could be used to control the network access, ie network security.
						
						They can also be used to control a large database of all the books.
						
						of course these would be connected to the main program, and provide an interface of some sort over a remote connection to clients machines.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						There are a few reasons why JavaBeans components wouldnt be suitable for this application.
						
						- javabeans are rather slow, especially compared to the COM equivelent under C/C+
						- For this application custom made aplets to use in web browsers, which connect to a server would be more appropriate. Then you can hold the aplet on the Library web page which anyone can access, and log in if they have an account. etc
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="77" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="46" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In this case having striker and defender inherit from footballer seems like creating to many extra classes for not much gain, espescially if we want to be able to have a player change positions without creating a new object to represent them. A better  idea may be to have a concreate footballer class with a variable for position, set at construction and changed through get and set methods. A person also is not what their profession is but rather this is a role played by them so the Roony, Striker relationship would also be better represented using delegation and parameterisation.
						
						public class Footballer {
						string postion
						public  Footballer (position)
						}
						
						public class person {
						string name
						string job
						public person (name , job)
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is an  example of imlementation inheritance, the traffic que is not truley an Array list it just has similar properties. the problem with this is that it exposes the interface of arraylist to que clients which will include operations which do not make sense in terms of a traffic que.
						a better solution might be delegation:
						
						public class TrafficQueue{
						private ArrayList cars
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						In this class setup the problem is in having CameraPhone using multiple inheritance from phone and camera. this is likley to cause problems as they are in the same sector of the market and hae the common super calss PersonalElectronicEquipment they are likley to have similar variables leading to name clashes, multiple inheritance laso increases the dynamic binding overhaed and thus should be avoided if possible. An alternative implamentation could be to have the CameraPhone inherit just from phone and have a list of other functions including taking pictures.
						
						public class CameraPhone extends MobilePhone{
						public list otherFeatures;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The problem again here is the multiple inhertance, in this case the two classes   inherited from are far more disjoint conceptullay and thus are far less likley to have name  clashing problems so this is not such a bad idea. However the classes could be modeled differently by having either book just inheriting from copyable as this is a required operation and having a private varible  InformationSource. Or by implementing copyable as an interface instead of a concrete calss and having book inherit InformationSource and implemnet copyable which is less likley to cause problems.
						
						public interface Copyable {
						...}
						
						public class Book extends InformationSource implements Copyable { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a reasonable implentaion of an inheritance heirachy with all the sub classes passing the is-a test except perhaps the  NoAnswerRequired class which is likley to have quite a different implementation to the others which may cause problems, when using dynamic binding to add up test scores etc. as for example its given mark would be inapplicable as it could not be 0 as that would sujjest a wrong answer. This would mean we needed explicit testing for this case reducing the robutness and adaptablity that dynamic binding would give the program.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						a design pattern is a pattern of classes or objects representing a solution to a general design problem expressed in a specific context.  It comprises of a name for the pattern, examples of its use and its advantages and disadvantages .
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The composite design pattern makes good use of both inheritance and delegation techniques to give a neat flexible class strucute. It comprises of an abstract super class with two sub classes one atomic and the other composite which contains other objects of the superclass static type. This design pattern could be used in the online exam example to give a structure to the quetion types that may be in the exam with a superclass question with the sub classes atomic question and composite question that contains (deleagtes to) other questions. This would allow any possible depth of question heirachy as it allowds compostite questions to be composed of other composite questions. Below the composite and atmic question types are the actual concreate sub classes of each such as multiple choice question or definition question.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						To add security to the online nature of the exam we could use the proxy design pattern where  and intermediate object is put between the (online in this case) client and the class they think they are dealing with (the exam).
						The proxy object has exactly the same interface as the actual class so the user can not distinguish the two, it takes input from the user does any preprocessing neccesary on it (security checks in our case) and then delegates the work on to the underlying object (the exam) for processing.
						To have answer information displayed to the marker in different ways efficiently we could use the strategy design pattern. In this pattern alagorithms in our example data collating ones are packaged into classes so they can be instanciated and have the data input to them and provide a specific representation of it. This would allow us to easily swithch between representation  alagorithms at run time.
						Another desgn pattern that could be applied to this case is the  visitor design patteren as the style of exam questions is unlikley to change much from exam to exam but different alagorithms for helping to mark the data may be developed quite often  and need to be added to be tested or used. the vistior design pattern is used where alagorithms change faster than the class structure and are complex. It comprises of each data type in our case the questions having an accept method and which will take any incoming visitor alagorithm and let it execute on its data.
						We can then just define new alagorithms as visitor ones and have them visit all applicable questions. This means we only have to define our alagorithm in one place instead of each class we want to use it in.
						A final pattern that may be usesful in this system is the flyweight pattern which is used to improve storage efficiency in programs. It works by replacing lots of small objects by pointers to the same object. This could be used to reuce storage space for the exam answers by applying such and alagorithm to the text as there are unlikley to be and font or cloour changes in an exam script so letters could be represented by just 26 pointers plus punctuation. This is especially true as the answers will beimmutable once the test has finished.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design by contract is a system for introducing assertions into a program that must evaluate to true at the specified points. These consist of pre-conditions that must be true before a method starts executing to garuntee a correct result, post-condition which sould be true after a method has finished assuming its preconditions were met, and class invariants which should be true when ever the object is in an obseravable state ie. before and after each method call. These assertions allow us to express the required conditions for the class to perform correctly and the results you should expect in that case. In java we can add assertions to our code by using the keyword assert giving a boolean and a possible error message, or just  by having if statements inforcing preconditions on public methods (contract more likley to be broken here).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							public class SqRoot{
							
							public computeRoot(long n)
							{
							pre condition : n &gt;= 0
							...
							postcondition: nRoot = sqrt(n)
							return nRoot;
							}
							}
							
							this class has no persitant memory state so doesnt need any class invariants its compute method though requires the input to be a positive nuber so that the answer is not a complex number, and hasd the post-condition that it returns the correct squre root.
							
							public class stack{
							
							int pointer
							int [] stack
							
							invariant : 0&lt;=pointer &gt;= n
							
							public Stack()
							{
							pointer  = 0
							stack = int [n]
							}
							
							public push(int i){
							pre: pointer &lt; n
							..
							post: pointer updated, stack updated
							inv
							}
							public long pop()
							pre stack not empty
							..
							post stack and pointer updated
							inv
							}
							}
							
							This class has the invariant that the stack is never more than fulland the pointer is correct. Before a push operation the stack must not be full and must be updated correctly afterwards. The pre-condition of the pop operation is that the stack has something in it to remove and the post-condition that the stack has been properly updated.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						main ()
						{
						invariant: result &gt;= 0
						
						Stack myStack;
						long result = 0;
						long num;
						
						while (stack not empty)
						{
						num = myStack.pop;
						pre condition: num &gt;=0
						result += SqRoot(num)
						}
						postcondtion: result = sqrt(myStack)
						}
						The advantage here of using the SqRoot and Stack classes is that  is that they allready have the design by contract assertions built in so we know exactly what preconditions we need to meet and what output to expect given that, this tells us the exact conditions in which the program will work correctly. The program its self has the invariant that the result is allways greater than 0 as you can not have a negative sqare root and the post condition that the reult is the correct sum of the stacks roots.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="78" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="41" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This could be used.  It is a heirarchy that assumes a footballer can be split into various types, eg. a striker or a defender.  Also, these positions can be extended to different players.
						
						This is not the best way of doing this as it assumes that a player is always either a Striker or a Defender, and they can never change as the they inherit that position.  A better way to do this is to have a footballer class with component for the players name and position.  This could be specified in the parameters of the constructor of the footballer class.
						eg. new Footballer(&quot;Striker&quot;, &quot;Wayne Rooney&quot;);
						Another way of doing this if the striker class has some features you want to use is to have a striker object used in the parameters. The sort of relationship created is a footballer has a postion (superclass) which could be one of (Striker, Defender) (subclasses).  The roles (ie. position) can then be changed at runtime, which is a more accurate description of how people take on roles.
						eg. new Footballer(new Striker(), &quot;Wayne Rooney&quot;);
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is a good solution to this problem.  A a traffic queue is a particular type of ArrayList (therefore the IS-A test is okay).  It also allows extra information to be added about Traffic Queue otherwise not specified in ArrayList.  This is the whole point of inheritance when subclasses add build on features already implemented in their superclasses.  One slight concern is that a specifice type of List has been used, this will cause difficulties if the container class needs to be changed, eg. to a LinkedList.  A better way to code this would be to use the superclass of all these structures, ie the List class and use its interface to program the rest of it.  Any of the subclasses of List can then be used to implement the Traffic Queue.
						An alternative is to have the array list stored inside the traffic queue as a component (as an instance variable), ie:
						public class TrafficQueue()
						{
						private ArrayList listOfTraffic;......
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a good way to implement this scenario as long as multiple inheritance is allowed in the language used, in Java&apos;s case it is not legal.  The above states that a MobilePhone is a PersonalElectronicEquipment item, which it is, and that a DigitalCamera is also a PersonalElectronicEquipment item.  Futher more, using the multiple inhertance a CameraPhone is a MobilePhone and a DigitalCamera.  The only problem i percieve is that CameraPhone will inherit the variables from PeronsonalElectronicEquipment twice and so waste space and the important issue concerned the renaming of variables needs to be addressed.
						An alternative approach is to use parameters to specify what kind of item it is and have the constructor deal with how to implement it:
						
						public class PersonlElectronicEquipment(String type)
						{
						if(type == &quot;Mobile Phone&quot;) {.......}
						else if.........
						}
						
						However, the example used in the question is the approach i would use.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a not a good way to use the inheritance as you don&apos;t need to inherit the Copyable class, as the Clone method is already inherited from the superclass of all the classes, OBJECT.  There is a way to just change this method without having to create a new class and inherit that aswell.  All that is need is to override the clone() method with your own implementation of it.
						
						eg.
						public clone()
						{
						
						/* own imp here*/
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The way used here is not a very good way to model this as the NoAnswerProvided class is really different types of questions put into one class.  A better way to model this is just to have the text field for the answer to be empty if no answer was found. Therefore, get rid of the class NoAnwerProvided and have the other subclasses of Answer deal with that.
						eg. public abstract class Answer()
						{
						String answerText;
						boolean answered = FALSE;  /* Changed to TRUE if the user enters an answer. */
						boolean required;
						
						public Answer(boolean required)
						{
						this.required = required;
						}
						............
						.....................
						}
						Therefore, this allows a much neater way of finding out which questions a candidate answered.  This allows the marking to become a less complicated preceedure as a simple check on the boolean will avoid uneccessary calcuations.  The boolean for required also will eliminate another class (NoAnswerRequired) as this deals with whether or not the answer needs to be answers or not.  The only limitation on this is that if there are a lot of questions where no answer was needed, there would be a lot of wasted answer objects.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A design patten is a general way to program certain types of coding problems.  They can be applied to specific problems.  They are ways of improving how programmers code software as they are tried and tested ways of solving common problems associated with the design of Object Orientated systems.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						The composite design pattern could be used to model the different types of questions there are possible in the examination software.  The composite design pattern is ideal for these kinds of problems and is the reason why it is so widely used.  For instance, we have an abstract superclass called Question, then have two immediate subclasses called SingleQuestion and CompositeQuestion.  The SingleQuestion is also to be abstract as we can have lots of different types of question, such as MultipleChoiceQuestion and TestQuestion.  Therefore, Question will also be a superclass for these types of Question.  Meanwhile, CompositeQuestion can contain a Question or can actually contain another CompositeQuestion.  This allows the typical structure of question format in exams to be modelled correctly, as we can now have a kind of nesting of questions. eg. we can have Q1 being a composite question containing an (a) part and then a (b) part where this part has several sub-questions inside it (therefore it is a composite question, so can now have (b)(i), (b)(ii), etc.  The method for marking each type of question will be concrete only in each subclass of question, as each will be different due to the questions being of a different nature.  Composite question will also have a method for marking and it will just call each of the individual method for marking on each of its sub components, adding up the results as it goes.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						The Remote Proxy design pattern can also be used in this sofware.  This can be used as the software can be used anywhere in the world and the results stored in a central location.  As this is needed, a way of communicating between the remote computer and the central store is needed, this is where the Remote Proxy patterns comes in.
						
						The Observer design pattern could be used.  This splits certain areas of the code up into components that are Observables (ie. they have a state that changes when certain events occur) and Observers (ie. things that react to the Oberservables state changes if they are looking for that kind of change).  In the system this can be used to manage the Graphical User Interface (GUI).  The GUI will collect user input and create events, eg. a button click on &quot;NEXT PAGE&quot;. This is the Observables part of the pattern.  Once the event is fired, the parts of code listening for that event need to do what is neccessary.  These are the Observers, eg. in this case to move the GUI onto the next page as the user requested.
						
						The Strategy design pattern can also be used.  This pattern will contain several classes, each one with a different way of doing a certain task.  These classes will all be common to one superclass.  This superclass is what a client for the task will use in order to get the task done as it wants.  In the case of the software, this could be used to emply various strategies to present information for marking.  There could be a superclass called
						InformationStrategy, with abstract methods in order to simulate an interface.  From this there can be several different subclasses each containing a different way of implementing an information retrieval service.  eg. sub classes could include:  DetailedInfomationStrategy, MinimalInformationStrategy, etc.
						
						A final design pattern to be used is Singleton to reduce the number of object used.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The whole concept behind Design by contract is that it binds the provider of a certain function and the client calling it to a formal agreement as to what each must do in order for the code to function as intended.  Each of the library classes and in turn methods must only allow certain values to be given to them, ie. a function to compute the absolute value of an integer, need to be sent an integer (as specified in the method&apos;s signature (in its parameters)).  If a string value was sent to it, no sensible answer could be found via this method.  Thus, the client calling the method has failed to satisfy the conditions set out by the method.
							A contract contains a pre condition (specified by the provider) which has to be met by the client.  As long as this is met the provider promises to give a return result that satisfies it post condition.  In other words a contract ensures that if a call is made in a stable state, at the end of that call the system will still be in a stable state.
							In the libraries contracts are needed to make sure that they provide the correct (or at least the expected) results.  The contract would be defined by placing asserts (possibly is using the add on to Java) or just be placing if statements at the beginning and end of each method in the library.  This will specify the pre and post conditions for that method and ensure the contract is abided by.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							For the class SqRoot, it should just have one static mehtod that can be used by passing any double to it (could have another one method for float, int, etc.).  The preconditions should state what is allowed by the parameter and what is not, done using if statements.  If a precondition is not met, the method should just return a value specified to be an error (eg. -1) or throw an exception saying that the parameter preconditions have not been met.  Otherwise, a sensible result needs to be returned as long as it satisfies the postcondition.  In this case the post condition is that the result should be positive (only taking the positive root) and it should be of the type specified by the method return type.  Therefore, class SqRoot:
							public class SqRoot
							{
							public static double calculateSqRoot(Double value)
							{
							if(value &lt; 0) throw Execption;  /* Better to throw a specifc exception here, such as a parameter incorrect                                                              exception as it will be more accurate. */
							else
							{
							sqRootValue = ...........;
							}
							
							if(sqRootValue &lt; 0) throw Exception; /* Again better to throw a more meaningful exception that just the                                                                         general one. */
							else
							return sqRootValue;
							}
							}
							
							The class for Stack should be a full class with a constructor and methods.  The constructor should have a pre and post condition and also every method should.  It may also be useful to have a class invariant that is checked whenever the post condition is checked.  This ensures a state for the class is always stable, eg. the number of object on the stack should be positive.
							
							public class Stack
							{
							private static int leastNumberOfObjects = 0;  // Class invariant.
							
							public Stack()
							{
							/* pre condition here */
							
							/* ACTUAL CODE HERE */
							
							/* post condition here, along with class invariant condition satisfied*/
							}
							
							/* An example of the methods */
							public void &lt;method name&gt; ()
							{
							/* pre condition here */
							
							/* ACTUAL CODE HERE */
							
							/* post condition here, along with class invariant condition satisfied*
							
							}
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						This is where the benefits of doing the delegation of the tasks to separate components really pays dividend.  As each of the previous two classes (SqRoot and Stack) ensure that is the pre conditions are met they return a value that will satisfy their post conditions AND/OR they will return a state which is stable (ie satisfyting the conditions of the client calling them).
						Program:
						
						class SqRootStack
						{
						private Stack stack;
						
						public SqRootStack()
						{
						stack = new Stack();
						}
						
						public addValueToStack(double value)
						{
						stack.addValue(value);
						}
						
						public calculateSqRootsOfStack()
						{
						while(stack.next())
						System.out.println(&quot;SqRoot: &quot; + calculateSquareRoot(stack.getNext()));
						}
						}
						
						The program just creates a new Stack when its contructor is called.  The program can then add elements to the stack by calling a method in the stack class indirectly through a mehtod in this class.  To calculate the square roots of the elements on the stack and then print them out, just need to do a simple while loop using methods from the stack class to do all the hard work.
						The benefits of the two supplementary classes are that they are self contained and will always produce correct (or at least feasible) results if correct information is passed to them.  Also, the code is more resuable as if the implemention of the supplementary classes changes (eg. a different way to get elements from the stack), the classes using them will still work providing the pre conditions are equal or stronger and the post conditions are equal or weaker.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="79" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="52" isMarked="true">
			<compositea marksAwarded="18" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Passes is-a test, but &quot;is a role played by&quot;, rather than &quot;a kind of&quot;. An example of roles. e.g Defender &amp; Striker are both roles of Footballer.
						
						A better use would be:
						Public class PersonalDetails{}
						Public class FootballingRole{} //
						// Defender &amp; Striker are subclasses of FootballingRole
						public class Defender extends FootballingRole{}
						public class Striker extends FootballingRole{}
						
						public class Footballer{
						PersonalDetails personal Details;
						FootballingRole [] footballingRole; // has a number of footballing roles. Alternatively may just     // have a single main role (in which case it would be FootballingRole footballingRole)
						}
						
						WayneRooney should not be a class himself- he should be an instance of class Footaballer
						i.e. Footballer wayneRooney = new Footballer();
						To identify him could have a String name attribute in PersonalDetails and set this to be &quot;Wayne Rooney&quot;
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Doesn&apos;t really pass the is-a test (would take some ingenuiety). Is an exampe of implementation inheritance. This is bad as it exposes all of the underlying methods of ArrayList to clients of TrafficQueue, so that anyone that uses an instance of TrafficQueue can use any of the methods in ArrayList, even if you don&apos;t want them to (no way to &quot;hide&quot; them in Java). Also ArrayList is only likely to be a minor feature of a TrafficQueue as the class grows.
						
						A better representation would be to hide the implementation of ArrayList by using delegation.
						
						public class TrafficQueue{
						private ArrayList queue; // even better would be do have this defined as it&apos;s superclass, and initialised e.g. as an ArrayList when required, so it&apos;s easier to change the underlying data representation if required.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						An example of multiple inheritance. Passes is-a test (i.e. CameraPhone is a MobilePhone &amp; DigitalCamera). However generally should only use mulitiple inheritance if really required, and in this example alternatives are available. The use of multiple inheritance in this example is not ideal as both MobilePhone &amp; CameraPhone have the same common superclass, therefore you would have to deal with name clashes etc.
						
						A better alternative may be to use a combination of delegation and inheritance.
						Inheritance would still be used for the relationship between PersonalElectonicEquipment &amp; MobilePhone &amp; DigitalCamera.
						Delegation would be used to define the attributes of CameraPhone
						
						e.g. public class CameraPhone{
						PersonalElectronicEquipment [] personalElectronicEquipment;
						}
						// delegates to a number of instances of PersonalElectronicEquipment
						
						Note this is still not ideal as it doesn&apos;t specify that a cameraphone delegates specifically to ONE mobilePhone and ONE camera (so would allow e.g. for the array just to contain a digitalCamera, or if PersonalElectronicEquipment was expanded, to contain an instance of, for exampe, CDPLayer).
						
						INSTEAD the better implementation is to specify the exact subclasses it delegates to i.e.
						
						public class CameraPhone{
						DigitalCamera digitalCamera;
						MobilePhone mobilePhone;
						...
						}
						
						Another alternative is to use the Composite design pattern, but this is not as good as the last implementation given, as again it would allow CameraPhone to be made up of e.g. CDPlayer
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This should be implemented as Interface Inheritance, rather than Inheritance.  Copyable is only a (minor) feature of Book. Without seeing more code it is difficult to see whether InformationSource would be used as a major feature of book in this example (e.g. if this was a library system then it probably would be). I am therefore assuming it is (if it was only a minor feature like Copyable I would do the same &amp; implement it as Interface Inheritance).
						
						A better implementation would be
						
						public class Book extends InformationSource implements Copyable{
						
						public Object copy()
						{
						// code specific to book to do the Copying
						}
						}
						
						// and implement Copyable as an interface
						interface Copyable{
						
						public Object copy()
						{
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						This is a good use of inheritance. These all pass the is-a test.
						
						However NoAnswerProvided and NoAnswerRequired are open to debate. These may arguabely be subtypes of e.g. TextAnswer &amp; MCQAnswer (i.e. an answer to MCQAnswer may have no answer provided). However this would require  implementing multiple subclasses of NoAnswerProvided and NoAnswerRequired for each subclass of Answer (i.e. TextAnswer &amp; MCQAnswer), which is not ideal, especially if the application is expanded to include more types of Answer.
						
						Other possible implementations may be using delegation - an Answer may contain multiple types of Answers.
						
						e.g. public class Answer{
						private Answer [] answers;
						//With the subclasses implemented as they are in the example
						
						This would probably make the implementation too generic (e.g. can&apos;t ensure if it&apos;s just a MCQQuestion that it cannot also have a TextAnswer within it) than it needs to be, therefore in conclusion the implementation above seems to be the best use
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communicationg classes +/or objects which can be customised to solve a design problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						Composite design pattern could be used to represent the questions in the exam (i.e. as composite questions or basic questions). Composite allows the use of both inheritance (i.e. both composite questions and basic questions are kinds of Questions), and delegation (i.e. Composite questions contain Questions).
						
						It would involve having an abstract superclass: Question
						i.e. public abstract class Question
						{
						// which may contain some abstact methods that must be defined in the subclasses e.g. getMarksAvailable:
						public abstact int getMarksAvailable();
						}
						
						BasicQuestion &amp; CompositeQuestion would then be subclasses of this superclass i.e:
						
						public class BasicQuestion extends Question{
						private int marksAvailable;
						...
						public int getMarksAvailable(){ return marksAvailable};
						}
						
						
						public class CompositeQuestion extends Question{
						private Question [] questions; // contains an array of Questions
						...
						public int getMarksAvailable(){
						}
						int marks = 0;
						for(i=0; i&lt;questions.length; i++)
						{
						marks += ((Question)question[i]).getMarksAvailable(); // use dynamic binding to add up all of the marks
						} // for
						return marks;
						}
						
						Also, arguabley Exam itself may be a subclass of CompositeQuestion as it may contain much of the same operations etc as CompositeQuestion (e.g. getMarksAvaialble), therefore for simplification it may be easier to represent this relationship via inheritance rather than having to keep delegating to CompositeQuestion
						
						i.e. public class Exam extends CompositeQuestion{
						...}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						Proxy - Remote Proxy could be used do deal with the connection from the client to the central server
						
						Strategy - Could be use to present the information in different ways to the marker dependant on their requirements
						
						Observer - Could be used for the online exam software in dealing with events generated in the GUI (e.g. the &quot;submit&quot; button being pressed would notify it&apos;s listeners that this event has happened. The main GUI class may have registered with this object that it wishes to be notified if it&apos;s state changes. Therefore when the button is pressed the main GUI class will be informed, and can then call appropriate methods to e.g. submit the exam to the central server &amp; close down the online exam software.
						
						Singleton - Could be used to ensure that one student can only access &amp; submit a particular exam once. i.e. once an exam is submitted that is it, it cannot be submitted again.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Allow users of the library to know how to use the methods (i.e. what pre-conditions they need to fulfil), and is a guarantee to them that if they fulfil these preconditions then the postcondition (i.e. what the method is supposed to do) will be satisfied.
							
							The pre conditions would be mentioned explicity in the interface to the Object method. The postCondition is the description of what the method does and it&apos;s return value.
							
							The class invariant should hold for all observable states (assuming default values have been used on instance creation and the client satisfies the pre-conditions for any methods used) - therefore providing a guarantee to the client of the class that tje invariant will hold (for all observable states).
							Dealing with exceptions is also a kind of contract. i.e. library should throw no runtime exceptions (in Java) as these should have been removed in debugging, so there is a benefit for the user of the library. If any of the methods may throw any other kind of exception then the lmethod must explicitly state this (i.e. in method interface)so that the client can catch it and deal with (e.g. convert to an application specific exception and deal with).
							
							Contracts a way of proving the software does what it&apos;s supposed to (i.e. does what the library description i.e. &quot;specification&quot; says it does).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							class Stack{
							// class invariant: ((&gt;=0 index &lt; ArrayList.length()) &amp;&amp; (index&lt;capacity))
							// i.e. index is valid &amp; stack not full
							private int index;
							private int capacity;
							private ArrayList stack; // please note I can&apos;t remember the exact implementation of ArrayList but I hope that the
							// methods I have used (assumed) are fairly obvious
							
							public Stack(int size)
							{
							// pre: size is valid i.e. &gt;0
							// post: A Stack of the specified size is created
							index =0;
							capacity = size;
							stack = new ArrayList(capacity);
							}
							public void put (int number)
							{
							// pre: stack not full
							// post: stack updated, value added
							stack.add(index, number);
							index++;
							}
							
							public Object pop()
							{
							// pre: stack not empty
							// post: stack updated, value removed;
							stack.remove(index, number);
							index --;
							}
							
							public static class sqRoot{
							
							public static long getSqRoot(int no)
							{
							// pre: no is valid i.e. &gt;0
							// post: corresponding square root value is returned
							
							// code to calculate the square root using the Maths libaray or something equivalent
							}
							
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Public class squareRootStack{
						// Stack assumes that stack size &amp; index given is always valid, therefore need a variable to keep track of the size of the stack and it&apos;s current index, so don&apos;t put things on a full stack etc
						private int stackIndex;
						private int stackSize;
						Stack stack;
						public squareRootStack()
						{
						stackIndex = 0;
						// stackSize satisfies the pre cond on the Stack constructor that the value passed is an int &gt; 0
						stackSize = 20;
						stack = new Stack(stackSize);
						}
						
						public void useSqrRt(int noToFind)
						{
						// must check that noToFind is greater or equal to 0 before calling the method to find the Square Root in sqRoot
						//
						}
						
						Benefits of using the 2 classes is that the pre conditions mean that you know what you need to check before you a call a method (e.g. check that the stack isn&apos;t full), and that if these are fulfilled then the classes guarantee the right postcondition (i.e. if call the sqRoot method with a valid int will guarantee that you get the correct value back i.e. the square root).
						Also it guarantees there is no unchecked exceptions generated.Also guarantees return types etc to methods
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="80" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="44" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Although we could say that a striker is-a footballer it would be more accurate to say that striker is a role played by footballer. So for example w ewould have instead
						
						public class footballer
						{
						personal_details d
						position p;
						}
						
						public class personal_details
						{
						String name etc...
						}
						
						public abstract class position
						{
						}
						
						public class striker extends position
						{
						}
						
						This way a player who plays in more that one position can be represented.
						
						public class WayneRooney extends Striker { … }
						
						is wrong because WayneRooney is an instance of a striker.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						We should use delgation here rather than inheritance. So for example we would say
						
						public class TrafficQueue
						{
						ArrayList a;
						}
						
						This is so that clients of the TrafficQueue class cannot acces the array list directly. Also as TrafficQueue gets bigger and bigger in size the ArrayList become less important.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						
						These three I feel are good uses of inheritance as they pass the is-a test, i.e. everyinstance of mobile phonbe is a piece of personal electronic equipment.
						
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						
						Whilst this almost passes the is-a test, a CameraPhone will however probably not have all the features of a digital camera. I would therefore use delgation to get round this, also Java does not support mulitple inheritence so if we were implementing this system in Java we would need to change this.
						
						I would therefore use:
						
						public class CameraPhone extends MobilePhone
						{
						DigitalCamera DC;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						public class Book extends InformationSource, Copyable { … }
						
						This fails the is-a test. A book is not an instance of copyable. A book my simply be copied. Book is however an Information source so we would need to extend it. Therfore we would use delegation to make this code more sensible.
						
						public class Book extends InformationSource
						{
						Copyable c = new Copyable();
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public abstract class Answer { … }
						public class MCQAnswer extends Answer { … }
						public class TextAnswer extends Answer { … }
						
						These three are sensible uses of inheritence as they all pass the is-a test.
						
						public class NoAnswerProvided extends Answer { … }
						NoAnswerProvided, can technically be defined as an answer (i.e.this is the same as student wrtiing I don&apos;t know)so this would also be kept the same.
						
						public class NoAnswerRequired extends Answer { … }
						Again whilst this can still be regarded as an answer for implementation purpuses it may be better not to have this a subclass of answer, as for example is we decide to sum up all the marks from the instances of answer then we will end up using this class as well when in fact we wish to ignore it. There are of course ways to get around the problem but for simplicity sake it would probably be better to have this on its own
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design parttern is a generic solution to a design problem, e.g. if we were wondering how to implement a certain structure we would look at the corresponding design pattern to see what is the best way to do it, for example if we implemnted a Oredred Binary Tree we may wish to use the Null Object pattern to aid us in its creation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The composite design pattern is useful any time that we have a lot of sub-components and we wish to use them in a generic way. So in the above example we may have many different types of questions but we may wish to get their marks, i.e. apply the same operation to them all the different subtypes.
						
						public abstract class answers()
						{
						}
						
						public int class getMarks()
						{
						List answers;
						int marks = 0;
						for(int i=0;i&lt;questions.size;i++)
						marks += ((answers) questions.get(i)).getMarks();
						return marks;
						}
						
						As we can see the subcomponents of answers are all being treated the same. The end reult is then summed up and returned at the end.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						Singleton - Ideally you do not want to have two people marking the same exam, for example the marks of marker 1 may be overidden by the marks of marker 2. Therefore we would have some sort of MarkWriter variable that would only give the requester a MarkWriter if it was currently null i.e. not in use. For example we would have an method saying
						
						get MarkWriter()
						{
						if(markWriter ==  null) markWriter = new MarkWriter();
						}
						
						Factory - Sometimes we will not know what type of object we are sealing with till run-time, e.g. we don&apos;t know if we are dealing with an MCQ answer or a text answer. Therfore we use a Factory which will have a get method in it e.g. getAnswer(String s). This will get the type of answer we are dealing with and we can then use the corresponding methods accordingly.
						
						Proxy - a proxy is something that will have the same interface as the end-use component. It will sit between the object and its desired destination and effectively the object interacting with it will not know that is is interfacing to the proxy as it has the same intrerface with the component. For example a web browser will use a proxy cache which will return it pages that may already be chached so as to speed up web access. With regards to this example we may also use a proxy as a cache to act as a buffer between the students exam and the main server.
						
						Observable - this a reaction pattern, i.e. it will react to events. As this exam is bieng done on the computer we have to ensure that we don&apos;t lose data. Therefore everytime something changes e.g. the student types in a charachter we need to react to this and save it so that if the computer crahses he will at least not lose his answer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							We would introduce contracts as they are a way of guarenting pre and postconditions. For example if the client can guarantee that the method will only be called when the certain pre-condition is me then the supplier can guarentee the set of post conditions
							
							{p} A {q} where A is the mthod, p the pre-conditions and q the post-conditions.
							e.g. {x=9} x+2 {x=11} is a trivial example to illustrate the point.
							
							Contracts therefore delgate responsilblity for correctness. Pre-conditions are obligations on the client but a beneift to the supplier. Post-conditions are a obligation on the supplier and a benfit to the client.
							
							Contracts can be defined as obligations placed on both the supplier and client to guarnetee a &apos;right&apos; outcome given the required input.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							The stack would be implemented with the methods push and pop. Pseudo code given below
							
							public int pop()
							{return value at the top}
							public void push(int i)
							{put i at the top of the stack}
							
							For the method pop
							The pre-condition would be: stack not empty
							The post-condition would be: item at the top of the stack returned
							
							For the method push
							The pre-conditon would be: stack not full
							The post-condition would be: value stored on the top of the stack
							The invariant would be: number of items on the stack is not greater than the stack capacity
							
							The method I would use to find a square root would look somthing like the following
							
							real x = 0.0;
							real inputNumber; //This is the number passed to it.
							real SqRoot;
							While(x*x != inputNumber)
							{
							if(x*x != inputNumber)
							{
							x += 0.01
							}
							else if(x*x &gt; inputNumber){No Square Root found}
							else if(x*x == inputNumber){sqRoot = x; return sqRoot}
							}
							
							This method would be in the SqRoot Class.
							It would have the pre-conditions: the input is a real number and positive e.g. input &gt; 0
							It would then the give the post-condtion: that the answer is the square root (and the square root*-1 but as we have only been requested to find one square root we will ignore this)
							The invariant would be x*x cannot be greater than the inputNumber
							
							Therefore we have {real number} SqRoot (SqRoot}
							
							Any exceptions thrown during execution e.g. null pointer error are violations on the part of the supplier.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						In this program we would have a stack of numbers of which we would wish to find the sqaure roots of.
						
						The design contract would look as follows:
						{valid list o real numbers}Program{stack of the square root of the numbers}
						
						Using the classes outlined in the previous question we would be able to implement the method. If initally the methods were not already on the stack we would need to push them on ourselves. Then we would each number in turn and find its square root. We would need to keep a pointer of where we were on the stack. This pointer would have the invariant of never being less than zero or greater than the number of items that were on the stack.
						
						The benifits of using SqRoot is that it is already contractually ensured, we know that if the inputs are correct than the answer we get will be valid.
						
						Stack is a good representation for a list of numbers to be kept in as it easy to access them and check that invariants hold.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="81" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="29" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Although Class Striker and Defender will pass &apos;is-a&apos; test as they are all footballers,they are all roles played by people.And the roles can be changed.For example,a footballer can be a striker at one time and then according to the position he stands by,he can be a defender afterwards.So we can not implement these two classes as subclasses to Footballer.Rather, we could make Footballer as a concrete class which records name,age etc. properties of footballer and let Striker and Defender Class to delegate this Footballer class.For example:
						public class Footballer{..}
						public class Striker{Footballer fb=new Footballer();//etc}
						public class Defender{Footballer fb=new Footballer();//etc}
						
						Implementing WayneRooney as a separate class is not reasonable,because WayneRooney is a real person,we can not establish this person&apos;s class as then create an instance of that person.Rather we can let WayneRooney be a instance of the Striker class like:
						Striker wayneRooney=new Striker();
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						As for TrafficQueue class,it is better to be made it as a subclass of an abstract class rather than the class which has the detailed implementation within it.For example, we could make this class extends List:
						public class TrafficQueue extends List{..}
						One reason for that is it is easier when things are changed.For example,if we make this as a List(abstract class),when the user decides to change the type of the storing list to LinkedList or whatever.The programmer only need to modify a small bunch of code without affecting other arbitrary code.
						Second is that for the characteristics of traffic,we need to frequently remove the first element in the list and add new node to the end of the list.So it is better to implement TrafficQueue as a Queue.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This design is reasonable.For the first two classes,they can pass &apos;is-a&apos; test(a MobilePhone is a personalElectronicEquipment and a DigitalCamera also a PersonalElectronicEquipment).This design is with the context :&apos;CameraPhone is a PersonalElectronicEquipment which is the combination of a mobilePhone and a DigitalCamera.&apos;So we could make CameraPhone class to be a subclass of MobilePhone and DigitalCamera. Alternatively,if we change the context of the CameraPhone to be:&apos;a cameraphone is a mobilePhone with a DigitalCamera.&apos;Then we can use the following design:
						public abstract class PersonalElectronicEquipment{..}
						public class MobilePhone extends PersonalElectronicEquipment{..}
						public class DigitalCamera extends PersonalElectronicEquipment{..}
						public class CameraPhone extends MobilePhone{DigitalCamera dc=.... //etc.}
						Therefore the design of this could real alter according to the context of the CameraPhone.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						For Book class with above design,it cannot pass &apos;is-a&apos; test.Because a book is not a Copyable,but it is an InformationSource.Therefore we could not make class Book to be the subclass of Copyable.Rather,we can implement Copyable as an interface that other classes can use to implement.So it will be like this:
						public class Book extends InformationSource implement Copyable{..}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						We cannot make inheritance according to different standard of Answer Class.For example,an answer which the student failed to proved can be a MCQ question answer or a text question which student failed to proved.So we can not design this system like that.Rather,we make Answer an abstract class which is just like the above:
						public abstract class Answer{..}
						Then we can make two subclasses of Answer according to whether an answer is required or not.These two subclasses are:NoAnswerRequired and AnswerRequired.
						public class NoAnswerRequired extends Answer{..}
						public class AnswerRequired extends Answer{..}
						Then for the subclass of AnswerRequired,there can also be two subclasses which are:AnswerProvided(student provides an answer to a question no matter it is correct or not) and NoAnswerProvided(No answer was given by a student).
						public class AnswerProvided extends AnswerRequired{..}
						public class NoAnswerProvided extends AnswerRequired{..}
						Then for the subclass of AnswerProvided, there can be two subtypes which are: TextAnswer and NonTextAnswer.And MCQAnswer is the subclass of NonTextAnswer.
						public class TextAnswer extends AnswerProvided{..}
						public class NonTextAnswer extends AnswerProvided{..}
						public class MCQAnswer extends NonTextAnswer{..}
						With this design,the hierarchy of the classes within this system is very clear and then other type of answer can be added like the answer to which the question asks you to draw a diagram etc..It can be a subclass of NonTextAnswer.So this design is extensible.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="9" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						If there is an abstraction for telling the users what operations and services are available.There must be an encapsulation for implementing the actual operation that users chose.The combination of encapsulation and abstraction is as a software black box that hide the information from the users.For example,in java,the abstract class without any implementation is called interface that other classes can implement.
						interface Cloneable{public abstract clone()//etc...}
						public class A implements cloneable{public clone()//etc...}
						class A should have the implementation of the methods that interface Serializable have declared.And the compiler will change the correctness of it by examing whether class A has all the methods delared in interface Serializable.If there are notm then an error will occur.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Encapsulation is the technique for hiding the detailed implementation from the client.Encapsulation will reduce coupling between different modules.Large system is divided into bunch of modules that for performance reason,it must be cohesive and less coupling. Therefore, with encapsulation, the code within a module will not affect other part of the code in other modules in the same system.So when things are changed,it will only need recompiling,not recomputation.So it will be faster than without using encapsulation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Design by Contract asks the client to call the method with precondition saticfied.So,Precondition is the bind to the client and the post condition is the bind to the server.Therefore,the client only need to ensure that the precondition satisfied when calling that method without worrying what really happens in the server.The server will implement the operation  and this will produce the result that satisfied the postcondition.The client will give the specification to the programmer ,specification gives the rules that binds the communication between the client and the server.As the client only need to bind to the precondition,the detail of the implementation does not need to show to the client.Therefore Encapsulation is a prerequisite for hiding the information inside the server from the user.It only need to provide the correct postcondition.If user asks a program to calculate 64648/282764,then the user only need to ensure that the bottom part is not zero, and then the server will give the correct result to the user without user worrying the detail of how the server get the answer.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<compositea marksAwarded="0" isMarked="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Software component can not just be any block of software.Because as a component,it must have the following characteristics:
						1.Encapsulation
						A software component must encapsulate its implementation from the client,which is also called information hiding.It is for performance reason according to design by contract,which will reduce the coupling between different modules thus improve the performance.
						2.Use of interfaces
						A software component must make use of interfaces.The interfaces specifies what operations and services the component provides that the users can choose from.
						3.Reusable
						A software component must be reusable.It can be used to any other applications by just plugging it in without worrying about it.
						4.Rechangable
						A software compnent must be able to replaced by other software component.But the new software compnent must have a weaker precondition as to accept more than the previous one,and a stronger postcondition.
						5.Inter-operable
						A software component must be inter-operable.It must have the capacity of using in other operating system.
						Software componet must be independent.It can be existed on its own.For example,a constructor delaration is not a component.But a class,a procedure or a module are examples of software components.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						Cleary Enterprise JavaBean should be used for implementing this system.There should be three parts inside this library system--A home interface,a remote interface and the bean class.
						A home interface is the interface for clients to use,as for this library system,a home interface is the interface used by librarians and other users.Suppose we call this interface LibraryOnlineInterface that has method calls getUser(int userID) etc.
						A remote interface is the interface for actually doing the required tasks for uses.For this system,it would have the following method calls:boolean getBookAvailability(String name),void setBookAvailability(String name,boolean available);String getBookBorrower(String name);void setBookBorrower(String name,String bookName);getBookName();setBookName();getBookerAuthor();setBookAuthor() etc.
						And the bean class is the class that produce beans that are reusable and changable.For this library system,it will contain all the methods listed in the home interface and remote interface.
						User of this online system will pass parameters to the system to view the home interface.For example,user ID and user password.And then the instance of the bean will use component contract to call remote interface,and then the actually bean class will perform the tasks for the user.
						Alternative to this design, a session bean can be used by adding in another interface.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Java bean does not have different interfaces.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="82" examId="CS310105" timeTaken="9000" isSubmission="true" allImages="true">
		<compositea marksAwarded="36" isMarked="true">
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In this example of inheritance the is-a test is valid as:
						
						* a striker is a footballer
						* defender is a footballer
						* wayne rooney is a striker
						
						But this is also a roles played dilema, as these (striker and defender) are roles played by the footballers and they can change positions. Hence inheritance is not the best solution in this case, and delegation should be used instead; Therefore alternative iimplementation:
						
						public abstract class Footballer
						{
						Position[] position;
						private Footballer( Position  playerPosition)
						{
						position = {playerPosition};
						}
						}
						
						Now looking at: public class WayneRooney exrends Striker{}
						The is-a test again passes for this but his role might change and might change poisitions therefore delegation is used again. Solution:
						
						public class WayneRooney extends Footballer
						{
						public WayneRooney()
						{
						super();
						Position position;
						}
						
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is-a-kind-of test passes in this case as TrafficSimulation is a king dof ArrayList. But the problem with this implemantation is that it is a Implemantation Inheritance problem, as by extending ArrayList the method sof the array list will become visible to the client as the TrafficQueue class does not hide the (methods) implemenations provided in the ArrayList, hence the client will be able to manipulate the methods of ArrayList which is not desirable.
						In addition another thing is that as methods (fiuntion) os the class increases the importance of ArrayList becomes more minor hence it wont be the only thing needed in the class, hence explicitly inheriting it will not be the right option in that case.
						The solution to this problem is that instead of inheriting the ArrayList, you should make sure that the methods of ArrayList are encapsulated in the TrafficQueue class, so clients cannot see it.
						Solution:
						
						public class ArrayList {}
						
						public class TrafficQueue
						{
						ArrayList arraylist;
						//now use the methods by delegating to ArrayList by using the instance created of it.
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						
						These both pass the is-a test  as both Mobilephone and Camera phone are Personal Electronic equipment.
						
						But
						
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						
						As multiple inheritance(MI) is used here, you will try best to avoid using MI only use it if really nessesary. As it causes compications, for example it variable name consistancies (handling variable name duplication) as well as complcates the relationship between classes.
						
						Look at the line of code above, this shows a composition problem as a CameraPhone is composed of a Mobilephone and a DigitalCamera . hancein this case to avoid MI we use delegation. So there will be PersonalElectronicEquipment with two subclasses MobilePhone and DigitalCamera, and class Camera Phone which delegatres to these to sub classes, as shown below:
						
						public class CameraPhone()
						{
						MobilePhone mobilePhone;
						DigitalCamera digitalCamera;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this case multiple inhertiance is used again, so we will try to avoid it due to the reason given in Question1.3.
						
						Looking at:
						
						public class Book extends InformationSource, Copyable { … }
						
						the first part passes the is-a test as Book is a Information sourse, but the seconf one which is Book is a Copyable obviously doesnt pass the is-a test, hence another implementation structure is required.  So what u do here is that you keep the Book class as a subclass of InformationSource but copyable need to be delegated instead. Solution
						
						public class Book extends InformationSource()
						{
						Copyable copyable;
						copyable.copy();
						}
						
						This also garantees that there are no implementation onheritance problems as Copyable method are encapsulated in the Books class.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						In this example all the is-a test pass as they are all different types of Answers. So as this test passes it is possible to represent this problem in this way. BUT inheritance manner is not necassary in this case (as inherttiance is last option after parameterisation and delegation).
						
						As these are different types of the same thing (different types of quesitons), this is a parameterisation problem as all the different answers could be represented coherently (sepretely0 by adding a few parameters that distinguish between different types of trees of the class tree. Therefore al these trees should be representedin one class calleed tree  and they wiill be distinguished by parameters.
						
						Solution:
						
						public abstract class Answer ()
						{
						//constructor with all the parameters sent to it
						public Answer(Boolean provided, Boolean required, Boolean mulitpleChoice)
						{
						}
						}
						
						The boolean parameters provided, required and multipleChoice allows u to differenciate between all type of questions for example NoAnswerprovided has pamarmeters required = true, provided = false and mulipleChoice = false.
						
						Hence Parameterisation is more efficient touse in this case .
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design Pattern shows a way the relationships between Classes and/or object could be defined, so that they solve (or optimise) a design phase problem, with in context of the problem. Design patterns can be used on may different platforms and it is stores the knowledge and style of an extern Software designer and lets other use it to there advantage.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Composite design pattern, is used when data is represented in a tree data struture. What Composite design pattern does is that it makes all the different data object be represented uniformly, allowing them to be ditinguiseh sepretely. So there is a abstact superclass that they are all sub classes of but the each subclass depending to what it represents can implement what is appropiate. In this case for example you have the central server has all the coutries around the world, where the exam was taken.  In this case each countires exams will need to be uniformly represented, because different functions need to be carried out on the exam papers in each country. As for example the exams are in different languages in different countries so different methods may need to be applied.
						So the soultion to this prblem would be that a superclass CentralServer would have subclasses for all the different countries so that each of the counteis can apply there methods. The superclass can hold any methods that are which are applicable (used be all of them) to all.
						Composite pattern could also be used in a similar manner to the question and verious types of answered defined uniformly.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						Proxy pattern - could be used in this software as it acts as a intermidiate between a clients and server (classes).
						A client delegates methos to the prxy and then the proxy deals with the problem by adding extra funtions if needed. In this case remote proxy could be used student somewhere in the world send the exam over by delgating to the remote proxy which deals with the transaction problem and then it arrives central server. the remote proxy has the same interface as the client (cental server) so the student can method like its talking to the server.
						
						Flyweight pattern - As the this problem has a tree like data structure(central server -&gt; country -&gt;exams papers -&gt; answers), this pattern can be used to minimise the number of small object created. This can be done in this case be making sure that any questions that are the same does not have to be created again for every paper, once it has been created once you just refer to that one everytime as may times as you want,
						
						Observer pattern - This pattern works on reactrive systems so in the case it will observe if any changes have occured in the information being presented (obserable) to the marker and when it does notice a difference the observer execute (carries out ) the appropiate action on the type of imformation prvided.
						
						Startegy Pattern - This pattern encapsulates the various algoritms (strategies) available hence allowing the program to switch between stratigies when needed. in this case when switching between different startegies to present the information effciently to the marker.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							YOu would introduce contracts, because this is the only way of making sure there is trust bettween classes within a library. Cointract defines a relaitonship between class and its client by referring to both parties rights and obligations. Contracts are defined by using assertions pre condition, postcondition and invariants.
							Pre and post conditions are logical predicates.
							
							{P} S {Q}
							
							S: statement
							P: pre condition is what needs to satisfied before for the statement is executed (statement dont execute if pre condition not satisfied)
							Q: post codition is what needs to be satifies after the statement is benn executed with the coreect re condition
							
							pre and post condition define the property of the single statement being executed.
							
							now need assertion I inveriant
							
							This defies the properyies of all the variable s used within a class and these instances need to hold at everyu observation state (creation, before and after statement)
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							You  would define the pre condition explicitly as the method are public and then the post cond as an assert prior to return of variable and then implicitly the invariants.
							
							pre conditions: number &gt; 0 (so no error due to squre ruting zero or negative numbers)
							post conditions: sqrRootNumber = maths.sqrRoot(number)
							invariants: sqrRootNumber = number * number
							
							public class SqRoot
							{
							public sqrRootMethod
							{
							float number;
							if(number &gt; 0)//pre condition explicit as it is public method
							{
							number = maths.sqrRoot(number);
							assert(sqrRootNumber = number * number);
							}
							}
							}
							
							**********************
							When adding to stack
							pre conditions: stackNumber &lt;= stackCapacity
							post conditions: stack is updated stackCapacity = stackcapacity - 1
							
							when removing for a stack
							pre condition: stackNumber != 0
							post condition; stack is updated stackCapacity = stackcapacity + 1
							
							invariants: 0 &lt; stackNumber &amp;&amp;  stackNumber &lt;= stackCapacity
							
							public class Stack
							{
							public add(number)
							{
							if(stackNumber  &lt;= stackCapacity)
							{
							add .(number);
							assert(stackCapacity = stackCapacity +1)
							}
							}
							
							public remove(number)
							{
							if(stackNumber != 0)
							{
							remove.(number);
							assert(stackCapacity = stackCapacity - 1)
							}
							}
							}
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public  class  findMethod ()
						public method ()
						{
						for(int i = 0; i &lt; stack.size(); i++)
						{
						math.sqrRoot(stack.get(i))
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="83" examId="CS310105" timeTaken="5638" isSubmission="true" allImages="true">
		<compositea marksAwarded="38" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is an example of the roles problem. Defender and Striker are both roles a footballer can have, but many Footballers can change Role throughout a game. A clearer way to represent this may be to have a Footballer class containing a data structure of their current role.
						
						public class Footballer
						{
						Role roles [];
						}
						
						And then have the Roles class represent the Defender, Midfielder and Striker Roles.
						Whether WayneRooney needs a seperate class is also disputable, it would depend on what extra features WayneRooney would have compared to other Strikers,it may be possible to parameterise these as attributes, then have WayneRooney as an instance of striker with particularly high attributes.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is inflexible if you ever want to change the implementation of the dataStructure. It would be more sensible to encapsulate the Structure inside the class, and better still access it as a List rather than the specific ArrayList:
						
						public class TrafficQueue
						{
						private List queue;
						
						public addToQueue(Car c)
						{  //add to end of Queue
						}
						
						public removeFromQueue()
						{  //remove from front of queue
						}
						}
						
						The actual structure is made private so that its particular methods can&apos;t be accessed directly. So accessor / mutator methods are provided to add items to the queue in the proper manner.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This example produces a graph type inheritance hierachy, which is harder to handle by a compiler and may end up with data from the PEE class being duplicated. It depends on what particular features you need to model, and althought this hierachy is sensible in real-life it may not be in a computer program.
						You could model the camera phone primarily as a type of MobilePhone, which has-a camera.
						ie.
						
						public class CameraPhone extends MobilePhone
						{
						private DigitalCamera camera;
						}
						
						The instance here is made private so that the cameraPhone class can provide the accessor / mutators to any (or fewer) of the methods provided. The cameraPhone then delegates to the DigitalCamera when necessary.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I wouldn&apos;t expect all the data that a book contains to be stored in a single book class. A Book could be broken down as a tree of chapters -&gt; paragraphs -&gt; actual text. When performing the shallow copy, these subobjects may not be copied.
						
						I would implement the copy method to copy the actual data as well as the higher level Book object. The particular implementation would depend on how the data was stored in the Book class.
						
						One way of doing this would be to have the book conatin a Tree of chapter objects, which themselves contain a List of paragraph objects. Then make the Chapter and Paragraph classes also Copyable. Then in the Books copy method, recurse through the tree calling the copy on each chapter and paragraph.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						In this example it may be possible to parameterise some of the features modelled by this hierachy. For example a question for which no answer was provided could have been any type of question to begin with, so it doesn&apos;t seem necessary to change the type of the object to a new class. Parameterisation cuts down the overheads of handling whole new classes. It may be a better idea to have a simple boolean in the top level class Answer which simply shows whether an answer has been given or not:
						
						public abstract class Answer
						{
						private boolean answered;
						private boolean required;
						}
						
						Similarly I have used a boolean to model the fact that particular answers may be required .
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a reusable and customisable method of arranging classes/objects usually for some performance/storage benefit.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The composite design pattern could be used to model the tree like nature of an exam, which breaks down into a certain number of questions, which break down into a number of sub-questions and so on. Using the composite pattern allows you to have an unlimited amount of nesting of questions. You would require a general question class, and a class to represent a composite question, which contains some data structure of general questions:
						
						public abstract class Question{}
						publc class CompositeQuestion extends Question
						{
						List subQuestions;
						}
						
						Then an Exam could be modelled as a specific type of Composite question with some bits added (E.g. the rubric)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						The Proxy design pattern could be used to handle communication between applet clients and the server. This pattern introduces a Proxy server that inherits the interface of the actual server and then delegates to the server when necessary. by handling some transactions at a Proxy level (E.g retrieving a cached examquestion) you can take some load of the main server.
						
						The Visitor pattern may be useful when marking the exam papers. If some questions are multiple choice it may be easy to automate exam marking via some algorithm. Since exam papers are all structured differently, the visitor object could quickly runthrough and visit the nodes of the tree ( subquestions of the exam ) and attempt to apply its marking algorithm to relevant questions, before the Human marker looks at the other questions.
						
						The singleton pattern could be utilised in this example. This pattern ensures that a single instance of a particular object exists by making its constructor method private and having a seperate method to control object instanciation. In this example you would want to restrict the number of objects that represent the central server to one.
						
						For the applet interface, the Observer pattern is appropriate. The interface will contain buttons, all of which need to perfom some action when pressed. The way this is implemented is by having one class as a listener to the button. This class maps the event that occurs to the particular method that should be performed when the button is pressed.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts allow you to reason about your code and possibly prove its correctness. They also make interacting classes/methods more cohesive, by guaranteeing a method will give a particular output, another method could be proved to funtion correctly given that same input. DbC abstracts the actual implementation of methods from their required functionality, expressed in terms of their pre/postconditions and invariants, which means different elements of a system can be coded seperately. The precondition is the required state before execution of a method/block of code. The postcondition is the state that the system will be in on termination of a method/block. Invariants specify factors that should not change e.g. when executing a loop, or system wide invariants limiting the number of objects in a database for example.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							The required precondition for the SqRoot method is that the given input should be a postive number. (unless you wish to represent complex numbers) and the postcondition would be that the output is the sqroot of the input as required:
							
							public double root(double n)
							{
							assert n&gt;=0;  //The precondition
							
							//code to do the sqroot
							
							assert (n*n)==finalValue; //The postcondition
							
							return finalValue;
							}
							
							By placing the assert just before the return, this guarantees (in a non-concurrent environment) that when the squareRootMethod does determinate, that the correct answer will be given.
							
							
							The important invariants of a stack are that the number of values in it are &lt;= to its max capacity, and &gt;= to zero (you can&apos;t have a negative number of items in a conventional stack). So the add and remove methods must uphold these invariants. I&apos;ll assume the stack contains integers.
							
							public int pop()
							{
							assert noOfItems&gt;0;  //This ensures that noOfItems &gt;= 0 as required, once the pop has occured
							//return popped value;
							}
							
							public push(int i)
							{
							assert  noOfItems&lt;maxCapacity;  //This ensures that noOfItems &lt;= maxCapacity once the push is executed
							//push the value on the stack
							}
							
							These methods ensure the stack is maintsained correctly. We also need to ensure that the stack invariant holds when the structure is first created. This could be simply achieved by creting the stack empty in the constructor and setting the values noOfItems=0 and maxCapacity as required. We would also have to ensure the internal data structure that stores the values is private, so that its own add and remove methods couldn&apos;t be accessed externall to this method.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						/** method whoch returns a stack of square rooted numbers given a stack as the argument **/
						public Stack rootsOfStackMethod(Stack input)
						{
						Stack output = new Stack();
						while(!input.empty())
						{
						output.push(SqRoot.root(input.pop()));
						}
						return output;
						}
						
						The benefits of using SqRoot and Stack are that I can verify my program with respect to the pre and postconditions. This means I can deploy my code guaranteeing that it will work correctly with the library methods for SqRoot and Stack.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="84" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="35" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Striker and Defender are implemented as subclasses of Footballer, but these are really roles played by a footballer rather than meeting the a is-a Footballer relationship as a footballer can play in more than one position for instance, and should not be implemented as separate classes. Instead the Footballer class should include a parameter which can be set to define the role of the instance at a particular time.
						Then Wayne Rooney will be an instance of Footballer, rather than a subclass of Striker, his role can be passed as a parameter to the constructor.
						
						public class Footballer {
						String role;
						
						public Footballer(String _role) {
						role = _role;
						}
						}
						
						public class Test {
						Footballer wayneRooney = Footballler(&quot;Striker&quot;);
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						TrafficQueue does not really match the is-a ArrayList relationship. This is an example of implementation inheritance. Here, the TrafficQueue class has been made a subclass of ArrayList for convenience reasons. Whilst the TrafficQueue class only requires a few of the available features (methods) which the ArrayList class supplies, all of the ArrayList class features are implementable. This can be inappropriate in some circumstances such as having the ability to remove vehicles from the middle of the traffic queue, when this should not be possible in reality.
						
						Rather than implementing the TrafficQueue class as a subclass of ArrayList, the TrafficQueue class should become a client of ArrayList, delegating functionality to the ArrayList instance when required.
						
						For example:
						
						public class TrafficQueue {
						ArrayList array;
						//initialise ArrayList object in constructor.
						
						// delegate functionality to the ArrayList instance
						public addToQueue(Object o) {
						array.add(o);
						}
						
						}  // TrafficQueue
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						It is important to note that Java does not implement multiple inheritance, and that
						public class CameraPhone extends MobilePhone, DigitalCamera { … }
						would not be valid, as CameraPhone would be a subclass of MobilePhone and DigitalCamera.
						
						The CameraPhone class would have to override many of the features inherited from MobilePhone and DigitalCamera, and is not best suited to this structure. The relationship between CameraPhone and the MobilePhone and DigitalCamera classes is more of a has-a relationship than a is-a relationship specified here. A better implementation would be to make CameraPhone a client of MobilePhone and DigitalCamera.
						
						public abstract class PersonalElectronicEquipment { … }
						
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class CameraPhone {
						MobilePhone mobile;
						DigitalCamera camera;
						
						// methods
						}  // CameraPhone
						
						Here, an instance of the CameraPhone class can delegate functionality to instances of MobilePhone and DigitalCamera.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Book is-a InformationSource, and is-a Copyable object. But these two classes are totally foreign to each other.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Using 4 classes in this example is overkill, especially in the case of the NoAnswerProvided instance, where this could be an instance of MCQAnswer of TextAnswer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="6" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Abstraction attempts to separate the implementation of an operation, from the behaviour and attributes of the operation. Encapsulation fundamentally hides information, which is a complementary concept to what is trying to be achieved using abstraction. Abstraction can be implemented in a number of ways, one of which being the use of interfaces (in such programming languages as Java). An interface allows a client to see what they can perform using the interface in question, without showing them how this is implemented. This works on a &apos;need to know&apos; basis and is a very useful implementation of abstraction. This use of encapsulation means that the client has more freedom, as they do not need to consider how an operation is implemented and the effects of this.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Because encapsulation hides information, runtime performance can be improved using dynamic binding. This allows a compiler to look at static objects and deal with them, and only at runtime are the dynamic versions of these objects actually implemented. This is much better than stating the exact type, as it allows for different implementations to be performed without altering the code massively.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Design by Contract requires encapsulation as it requires a client and a supplier to agree to provide states in which preconditions and postconditions are met when the client performs an operation for the supplier. Neither the client or the supplier need to know how the operation (usually a method) is implemented, just that the method provides a solution matching the postcondition when given an input in a state which abides the precondition. The contract needs to be implementation independant, and encapsulation hides the implementation from the client and supplier as it should not be a factor that needs to be considered.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design by Contract ensures that a client and supplier have an agreement between each other about what will be supplied and the obligations of the client. This relationship is expressed using preconditions and postconditions. A supplier is obliged to supply an input that meets preconditon &apos;p&apos;, which is a benefit for the client. The client is obliged to meet the postcondition after performing the action (possibly a method) in question, this is a benefit for the supplier.
							{ p } method { q }
							This method creates &apos;trust&apos; which is very important when an application is built on a scale as large as a class library. It ensures that aslong as a state matching the precondition is supplied, then any operation performed using this state will return a state matching the postcondition state required.
							
							A subclass inherits these contracts from its parent class and uses these, along with its own defined contracts. In the case of preconditions, the subclass and/or the parent class preconditions must be met. In the case of postconditions, the subclass and parent class postconditions must be met.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							The SqRoot class requires Design by Contract to ensure that the method performs the function it is expected to. This is done by creating a suitable specification stating the precondtions and postconditions required. In this case it is important to state the precondition that the value supplied to an instance of the class should not be null or negative. The postcondition should ensure that the result is less than the number passed to the constructor, or a better postcondition would be to ensure that the returned value multiplied by itself equals the initial number inputted into the method.
							
							The preconditions can be checked within the methods of the class before an operation is performed by using either the &apos;assert&apos; command or by using a boolean expression such as num &gt;= 0 (for instance from the SqRoot class), to check a variable value is greater than or equal to 0;
							
							The postconditions should usually be checked using an assert command, such as &apos;assert stackSize &lt; maxSize&apos; in the case of the Stack class.
							
							public class SqRoot {
							float number, root;
							
							public SqRoot(float num) {
							if(num &gt;= 0)
							number = num;
							}  // Constructor
							
							public float rootOfNumber() {
							root = number / number;
							return root;
							}  // rootOfNumber
							
							}  // SqRoot
							
							Design by Contract can be used to implement s Stack class effectively by ensuring that preconditions and postconditions are met so that the stack performs as expected. In this case, a precondition to ensure that the stack is not already full before another object is added to the stack, and the stack is not empty before a push is attempted. This will ensure that the Stack does not throw an exception. The postcondition can be set to ensure that the stack size is not greater than the max size, and the pushed value is not null.
							
							public class Stack {
							// implement push and pop methods
							
							assert stackSize &lt; maxSize;
							}  // Stack
							
							Design by Contract will ensure that these classes are implemented in such a way as to produce an expected state matching the postconditions when a method is performed within them, aslong as the state before the method is implemented matches the state specified by the contract preconditions.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						/* SQROOT CLASS */
						public class SqRoot {
						float number, root;
						
						public SqRoot(float num) {
						if(num &gt;= 0)
						number = num;
						}  // Constructor
						
						public float rootOfNumber() {
						root = number / number;
						return root;
						}  // rootOfNumber
						
						/* TEST PROGRAM */
						public class TestProgram {
						SqRoot sqRoot;
						Stack stack;
						float [] x;
						
						public TestProgram(Stack s) {
						if(s != null)
						stack = s;
						x = [100];
						}  // Constructor
						
						public float[] getRoots() {
						while (!stack.empty()) {
						float num = (float) stack.pop();
						x.add(sqRoot.rootOfNumber(num));
						} // endwhile
						}  // getRoots
						}  // TestProgram
						
						/* STACK CLASS */
						public class Stack {
						// implement push and pop methods
						
						// implement not empty method
						
						assert stackSize &lt; maxSize;
						}  // Stack
						
						The benefits of using the SqRoot and Stack classes is that due to the contracts that bind them via Design by Contract, we know we will get the correct results as each value is popped off the stack and then its root calculated, aslong as the suitable assertions are in place.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="85" examId="CS310105" timeTaken="3061" isSubmission="true" allImages="true">
		<compositea marksAwarded="16" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Although the is-a test may pass for here, the problem is the is-a-role problem. Stricker and defender are types of footballers rather than specific ones. The role of a player may also change if his position is swaped and a player may not play his whole career in one position. A call containing role of any player could solve this.
						
						public absract class Footballer {
						
						Role role;
						}
						
						public abstract class Role extends Footballer{
						
						Striker WayneRooney;
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The relation here is a TrafficQueue has-an ArrayList. Here we should use delegation instead of the inheritence.
						
						public class TrafficQueue {
						
						ArrayList []
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The multiple inheritance, although not allowed in java, assuming it works would cause a case of implementation inheritance. The is-a test is passes on all occassions. However, CameraPhone class is trying to inherit from two classes which are both subclasses of the same superclass PersonalElectronicEquipment.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						(MI not allowed in java, assuming this was ok) Again the is-a test passes as Books is an information source and Book is copyable. The Copyable class should probably be abstract and it is just a clone mechanism.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						All the types of answers are Answers and so the is-a test is past. One could argue that NoAnswerRequired is not actually an answer but rather a random selection of any question. It does what a blank answer so it like a null Answer.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Abstraction is about the modelling the behaviour of a module. Encapsulation is about hiding the implementation of the module. For abstraction you need a conceptual interface which is in essence the abstraction. To achieve this interface requires encapsulation.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Encpasulation hides the code which is not required after compilation. This cuts down on the code that need to be checked during run time.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Encapsulation can be used when using heap memory. It allows for data to be sent to specific memory blocks.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Design by contract (DbC) is used to define the relationships (contract) between the client and the supplier (class) and the obligations/rights each has. It can be done by having pre-conditions and  post-conditions. The pre-conditions are an obligation to be met by the client and in return the supplier gurantees that the post-condtions will be met. The code has to be encapsulated from the client.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
				<compositea marksAwarded="0" isMarked="true" notSelectedForMarking="true">
					<unanswered marksAwarded="0" isMarked="true">
					</unanswered>
					<freeTextAnswer marksAwarded="0" isMarked="true" notSelectedForMarking="true">
						<answerString>
							and invariants
						</answerString>
					</freeTextAnswer>
				</compositea>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="5" isMarked="true">
					<answerString>
						For a software to be classed as a software componet it has to be:
						Encapuslated - the code should be hiden from the client
						User Interface - has to be able to interact with the world
						Rechangable - to allow other developers to use it must be rechangeable
						Replaceable - Has to be able for it to be replaced by other components
						Inter-operable - has to be able to used on different platforms within the world
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						I think it could be more suitable to use COM as it can be used by the librarians on top of a standard MS Windows. The java beans would not have this same effect.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="86" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="40" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is a typical a-role-played-for problem.
						The relationships between Striker and Footballer and Defender and Footballer are right. Because  Footballer captures the common features of both Striker and Defender.
						The is-a test between WayneRooney and Striker is OK. However class WayneRooney should not inherit Striker class, even he is in real world. But the striker is just a role for him in the football field. Does not apply to all his daily life. It should use delegation. The class should be changed to
						public class WayneRooney{
						ArrayList Roles = .... //have a list of roles he play
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is also typical implementation Interface problem.
						Because this would expose the encapsulation of ArrayList class to client. Also the methods belong to ArrayList are callable in client that leads to perform some unwanted functions.
						The TrafficQueue class should have a variable of ArrayList as delegation.
						public class TrafficQueue{
						ArrayList arraylist = ..
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The fist two inheritance relationship,Mobile and PersonalElectronicEquipment and DigitalCamera and PersonalElectronicEquipment,is right. However the third has some problem. It is a typical MI problem.
						CameraPhone in fact is a mobile phone with digital camera functionality. The main focus is still the mobile phone. Also the class could be changed to
						public class CameraPhone extends MobilePhone{
						DigitalCamera, dCamera = ...
						}
						MI inheritance would be so easy to be misused and make layout of the object in store more complicated. It is not suggested here.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						If Book is really Copyable, this MI looks sensible and right. Book is a subtype of InformationSource sine InformationSource captures the commom features. Inheritance relationship with Copyable incidate the extra functionality with Book. The book is-a tests passed.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						I think using Composite technique would be more appropriate since all those answer from exam would be collected together correspond to each individual students. If composite used here, it is much easier to manage all the answers and perform uniform functions on them together.
						So who have a atomic answer as sub class of Answer and a composite answer as sub class of Answer too.
						public AtomicAnswer extends Answer{}
						then MCQAnswer, TextAnswer, NoAnswerProvided and NoAnswerRequired are sub classes of Atomic Answer.
						public class MCQAnswer extends AtomicAnswer {}
						public class MCQAnswer extends AtomicAnswer {}
						public class NoAnswerProvided extends AtomicAnswer  {}
						public class NoAnswerRequired extends AtomicAnswer {}
						then composite.
						public class CompositeAnswer extends Answer(){
						List lsit;
						//some functions need to perform on all its Answers included in List arriable,
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="16" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communicating classes and objects which could be customized to solve a design problem in particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The Composite design pattern applies to the design of exam question.
						
						The exam can have a top abstract class as ExamQuestion. It captures the common features of all the exam questions. The commom features can be the question itself, marks allocated for the question, etc,. The ExamQuestion class also defines some accessor and mutator methods to access and modife the variable. Some of those could be declared as abstract methods leave for sub classes to implement for particular needs.
						
						Then it is AtomicQuestion as sub class of ExamQuestion class. It implements all the abstract methods from ExamQuestion class. It is the basic unit of the exam question. Following, there would be some classes such as MCQExamQuestion, GraphicExamQuestion, etc, as the sub classes of AtomicQuestion. They define more specific features respectively.
						
						All the questions can be integrated into a larger component, the CompositeExamQuestion. It is sub class of ExamQuestion. It has a List to includes lots of different AtomicExamQuestion and AtomicExamQuestion&apos;s sub classes. It can perform some uniform functions on its included questions.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="10" isMarked="true">
					<answerString>
						First, Proxy pattern would be used here since allow remote login and access. The Proxy objects accept calls on behalf of another object, which they have same interface. The clients delegate the work to Proxy objects. Remote Proxy used here to hide the details of communication. Access Proxy used here to increase the safty since it is online exam. Also the proxy could be used to as cache that reduced the network traffice since most exam questions would be same.
						
						Second, Observer Pattern would be used here. Observer pattern used to observe some objects which their states would change unpredictablely, and then perform the desired functions. Because the exam would be invigilated via Central server. It is good to have center server as observer and eletronic exam paper as observable objects. When eletronic exam paper is activated or handed in, the center server would be triggered to perform desired functions.
						
						Third, the strategy pattern would be used here. Strategy pattern provides a way to switch different algorithms on same data structure. In the specification of this online exam system, different presences of the information are allowed to choose by markers. Each of them would have different perferences. Some of them like all the answers to be displayed vertically, some of them perfer dislplaying horizontally. So the different algorithm would be needed on the same data structure.
						
						Fourth, the object creation pattern would be used here. Accordingly to physical resources, probably only a fixed number of objects are allowed to be instantiated, like connection objects. The limitation of objects are good for cooperating with centre server and reduce the workload for center server. Also for security reason. If only 150 students take the exam. There should be only 150 connections.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Design by Contract describes the relationship of caller and supplier as a formal aggreement. It describes the rights and obligation of caller and supplier. Through such a contract, we can attain a siginicant degree of trust in the sytem we design and implemention.
							
							Design by Contract consists of precondition, postcondition and invariant.
							
							The preconditon expresses the contraints under which the fucntion would perform correctly. Therefore, the precondition states the condition for the caller to follow. The using of the class library must satisfy the preconnection specified. Also the classes should never execute the call to method that does not satisfy the precondition. The precondition offers the obligation for caller and benefit for supplier.
							
							The postcondition expresses the properties of the state resulting from the function execution. Therefore, the postconnection states the condition for the supplier. It states my class library would deliver the result satisfies the postcondtion that assumes the precondition of the called method is satisfied. The postcondition offers the benefit for caller and obligation for supplier.
							
							The class invariant describes the global invariant of all the instances of the class should preserve.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							For the square root class, the precondition, poscondition and invariant need to be declared here.
							The precondition would specify the input number needs to be bigger and equal to zero since we only concerns about the real square root.
							The postcondition would find the correct square root of the input number.
							The invariant would be input_number &gt;= 0.
							
							public double sqroot ( double input_number){
							if(input_number &lt; 0){
							throw new NegativeInputNumberException();
							}
							else{
							return sqroot_of_theinputnumber;
							}
							}
							
							The caller must satisfy the precondition. Then it perform the method. Finally get the square root. Those are obligation and benefit of caller.
							
							The supplier must satisfy the postconndition. Then it finds the square root and return it. It assumes the precondition is satisfied. Those are obligation and benefit of supplier.
							
							The stack class.
							The precondition would be the stack must not be full when perform the put(x) function.
							The postcondition would be put the x on the top of the stack and update the stack.
							The invariant would be nunber_of_items &gt;=0 and number_of_items &lt; stack_capacity.
							
							public void put(x){
							if(stack is full){
							throw new StackFullException();
							}
							push(x);
							update();
							}
							
							The precondition is making sure the stack is not full when put an item x on top of stack. The result is stack get updated.
							The postcondition is push the stack with item x and update the stack. It is simpler to process since it assumes the precondition is satisfied.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The precondition has taken account for both Stack and SqaureRoot. First the number of items in Stack must be bigger and equal to one. Second all the numbers stored in the stack must be bigger and equal to zero. Note the stack size versus stack capacity is not concerned here, because it is concern in push(x). It is precondition of push() function.
						
						The postcondition would be a collection of correct square root nubmers of the number in the stack.
						
						The invariant would be number_item &gt;= 1  and all_number &gt;= 0;
						
						public List sqroot_stack(){
						if(stack.size&lt;=0){
						throw new NoInputNumberInStack()// if in the stack, there is no number inside.
						}
						int size = stack.size();
						List list =...;
						int inputnumber;
						for(int i=0; i&lt;size; i++){
						inputnumber = stack.push();
						if(inputnumber&lt;0){
						throw new NegativeInputNumberException(); // if any number in the stack is smaller than zero throw an exp.
						}
						else{
						list.add(inputnumber);
						}
						List result =...;
						for(int i= 0; i&lt; list.size; i++){
						result.add(sqroot_of(list.get(i));
						}
						return result;
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="87" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="33" isMarked="true">
			<compositea marksAwarded="11" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						All of these pass the is-a test. However, too many classes are declared for different positions. The optimisation is that use a variable to describe the position. So one class is sufficient.
						
						public class Footballer
						{
						String role;
						public Footballer (String role)
						{
						role =striker;
						etc...
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is typical implement inheritance problem. After implementing the TrafficQueue&apos;s method, the class still has all the ArrayList methods. The opitmisation is using encapsulation.
						
						public class TrafficQueue
						{
						ArrayList al;
						//Constructor
						public add (Car c)
						{
						al.add(c);
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The first two inheritance pass the is-a test. So to some extent, MobilePhone &amp; DigitalCamera are properly defined. However, the CameraPhone doesn&apos;t pass the is-a test. It is just a combination of some of the properties of the two classes it extends. So the optimisation is use delegation rather than multiple inheritance.
						
						public class CameraPhone
						{
						MobilePhone mp;
						DigitalCamera dc;
						public CameraPhone ()
						{
						mp = new MobilePhone();
						dc = new DigitalCamera();
						}
						//then
						// mp.method() &amp; dc. method();
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						In convention, the properties like clonable is using interface rather than a class. Although Copyable does the shallow copy, the better way is define it as an interface. So all the classes want to do shallow copy can implement this. So the implemation is done in the InformationSource class.
						when the Book class inherits the InformationSource class, the shallow copy method is also inherited.
						public interface Copyable { .........//copy();}
						abstract public InformationSource implements Copyable() {// copy() with body;}
						public class Book extends InformationSource implements Copyable {....};
						
						We might also treat the informationSource plays a role as Book. That makes the  Book class the client of InformationSource  by delegation.
						public class Book
						{
						InformationSourceDetails isd;
						.......
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Firstly, NoAnswerProvided is might be a kind of MCQAnswer or TextAnswer, not simply a subclass of answer. Also for the NoAnswerREquired class, and this class is different from the others. It doesn&apos;t have the properties of marking the answer to be correct or wrong.
						So for NoanswerRequired class, better use delegation. Also similar to the NoAnswerProvided class.
						public class NoAnswerRequired
						{
						ArrayList a;
						// then fill the arraylist using instances of different types of questions by randomly selecting;
						add(Question q)
						{
						a.insert(q);
						}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="5" isMarked="true">
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						In most of the case, the user doesn&apos;t want to know the detail implementation of the class and methods, but only interacts with the interfaces. Abstraction provides the interface, and encapsulation hides the implementation details.
						Like in JDBC, user is not interested in DB socket connection and the details query. So we can hide the SQL quey bit and provide a more readable interface to the user.
						
						public boolean insert(Person p) //user only call insert method to insert person&apos;s details
						{
						//connecting to server,
						//Statement s = connection.execute(&quot; insert ....//sql query bit);
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						When the class needs to create a lot of small objects, better hide them by encapsulation and make a
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						e.g. A normal stack can just use push and pop which works on the top of the stack. However, we can encapsulate it by using another data structure like arraylist in case that something inside of the stack goes wrong. then we can access in the middle of the stack and modify it.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						Because the client side provides the pre-condition of the methods. However, the user might not know the details of how the method will be implemented. That makes it hard to specify the pre-condition. If the class hides the details of the implemation, and let the user understand the method format. Then the pre-condition will be easier to make and the post-condition will be readable by the user.
						
						e.g. implementation of finding the two roots of an equation.
						the pre-condition will be set to having a normal equation. Inside the implementation, the square root must be concerned and also diving by 0 case. However, the user is only  interested in the final result. So the getRoot method using the Math class methods is encapsulated.
						public Pair getRoot(Exp e)
						{
						// -b +/- Math.sqr(b*b - 4*a*c) then divide by 2*a to find the roots. etc.
						// return (root1, root2); return result pair
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Desine by Contract views the relationship between the class and its client as a normal agreement. Because the precondition binds the client, so if the client wants to make a method call of the class, the procondition must be satisfied. The postcondition binds the class. It means the return result must be satisfied. so we can determine which side breaks the contract in order to ensure the correctness. Additionally, the class invariant is the global property of the instance of the class and it must be preserved for all the methods.
							For example, in java, the pre&amp;post conditions are defined by the &quot;assert&quot; key word followed by the boolean expressions which are conditions.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							(1) SqRoot class:
							public class SqRoot
							{
							private double x, y;
							public static double getSR(double x)
							{
							.......
							return y;
							}
							}
							for the getSR method,
							the pre-condition is x &gt;= 0 &amp;&amp; x is real. Otherwist we&apos;ll get a complex number or whatever which we don&apos;t concern.
							the post-condition is y&gt;=0 &amp;&amp; y*y = x &amp;&amp; y is real. So we get a sensible result. Not possible to get negative or complex numbers. Also, the computation must be correct.
							The class invariant in this case is x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x is real &amp;&amp; y is real.
							
							(2) Stack class
							public class Stack
							{
							private int stacksize;
							private int currentsize;
							public void push(double value){...}
							public double pop(double value){...}
							}
							for push method:
							pre-condition is (0 =&lt; currentsize &lt;= stacksize - 1); otherwise can&apos;t push into a full stack. value is sensitive number.
							post condition is currentsize &gt; 0. otherwise, pushing is failed.
							for pop method:
							pre-condition is (stacksize &gt;= currentsize &gt;= 1), otherwise there is not element to pop. also, value must be a sensitive number.
							post-condition is 0&lt;=currentsize&lt;stacksize. otherwise poping might fail.
							The class invariant is (0=&lt; currentsize &lt;= stacksize) (might concern that stacksize &gt; 0 as well, but doen&apos;t matter).
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						public class StackSquareRoot
						{
						Stack sour;
						Stack des;
						SqRoot sr;
						public StackSquareRoot(Stack source)
						{
						des = new Stack();
						sour = source;
						sr = new SqRoot();
						}
						public Stack srstack()
						{
						for(int i = 0; i&lt;source.getSize(); i++)
						{
						des.push(SqRoot.getSR(sour.pop()));//pop from source and get square root then push into destination
						}
						return des; //return the final result stack
						}
						
						For using the source stack class, we can guarantee that the value passing into the getSR method is a sensitble number. Because it is poped from  a stack. After the number is squared, we can also guarantee that the return value is sensible, because the post condition of the getSR method. So the result can be pushed into the destination stack safely. Also, the itoration number of for loop is the same size as the source stack. That can guarantee the size of the destination stack not exceeds the Max size of the stack.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="88" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="34" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						It is possible to describe the classes as shown here, it is not quite a good use of inheritance. If we apply the is-a rule, we would prefer to say that a striker is-a-role-played-by a footballer. The reason for this is that while we get some people who are just strikers and some who are just defenders, we find that many people play in various positions.
						Therefore in this case we may find it a better idea to use parameterisation, to have a class Footballer and have their position as a parameter or list of parameters.
						
						public abstract class Footballer {...}
						
						public class PlayerX extends Footballer {
						private boolean Striker;
						private boolean Defender;
						...
						}
						
						In the constructor or in an accessor method we can then set whether PlayerX is a striker, defender etc.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						While we could say a TrafficQueue can be modelled by an Array, it is not really true that it is an Array. In a case like this it is better to use delegation to perform the ArrayList operations in the following way.
						
						public class TrafficQueue {
						private Object.List TrafficList; //Don&apos;t specify what type of list we have here
						
						public TrafficQueue() {
						TrafficList = new ArrayList();
						}
						... }
						
						Using this, if we decide at some point that we want to model TrafficQueue as a different type of structure, we can easily change it by altering the constructor as opposed to having to alter the entire class by changing the inheritance.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Multiple Inheritance (as used here in the CameraPhone) is very difficult to use properly. If we have some methods from both MobilePhone and DigitalCamera that have same names but different implementations which do we use? Therefore it is usually better to avoid multiple inheritance.
						Since at any point we would like to think of a CameraPhone as either a phone or a camera we might like to think of the CameraPhone as playing a role, therefore we could have a class OtherEquipment which has a list of the different type of equipment it could be used as.
						
						public class OtherEquipment extends PersonalElectronicEquipment {
						private List RolesEquipmentCanPlay []
						...
						}
						
						In the constructor we would then add MobilePhone and DigitalCamera to our list and we can then access the appropriate methods (at the appropriate time) through our list.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is not a good use of inheritance. While it is true that a Book is-a InformationSource, it is not true that a Book is-a Copyable. In this case it would probably be a better idea if we had copyable as an abstract interface that an object could implement.
						
						public class CopyableInfoSource extends InformationSource, implements Copyable { ... }
						
						We can then implement the the Copyable by overriding the methods that Copyable says we will implement.
						Book can then inherit from this CopyableInfoSource().
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I do not believe that this is a good use of inheritance. How would the system distinguish between NoAnswerProvided and NoAnswerRequired? For both of these objects the answer to the question would be left blank and therefore there will be ambiguity as to which should be created (or if our system is not correct maybe both will be).
						While the subclass NoAnswerRequired is acceptable, in the case of NoAnswerProvided i believe it would be better simply to supply a blank answer fot TextAnswer or MCQAnswer.
						When an operation is done on this e.g. marking, the operation will be done on a blank answer and therefore the result will be correct (e.g. no marks).
						
						Alternatively since there is no answer for both of these two things, why do we need both of them. We create a new class NoAnswer which inherits from Answer, which then states whether it was not provided or not required.
						
						public class NoAnswer extends Answer {
						private boolean NoneRequire;
						private boolean NoneProvided;
						... }
						
						We just need to specify an invariant that only one of these booleans can be true.
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A pattern is a specific description of a solution to a problem. A design pattern is a pattern describing the solution to problems that are with to do with the design phase.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						The composite design pattern is used when we wish to view both individual parts of something and the whole of it. In this case a we compose an exam of many questions.
						
						public class Question {
						...
						//The question gets marked and the following method returns that mark
						public int GetMark() { ... }
						... }
						
						public class Exam {
						private Object QuestionList[]; //Some object such as a list containing the questions on the exam
						...
						public int GetMark() {
						for(int i = 0; i &lt; Object.QuestionList.length; i++) {
						mark += QuestionList[i].getMark();
						}
						...}
						}
						
						Using the composite pattern we can treat each question seperately (so different people can mark different questions etc), however we can also do operations on the whole exam such as the GetMark method above which simply calls the appropriate methods in the basic parts.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="8" isMarked="true">
					<answerString>
						1. The first pattern that we would use in this software is the proxy pattern. Since this exam could be taken anywhere in the world we would use a remote proxy. A proxy is a program which helps us to communicate with another program by sharing (some of) its interface.
						In this pattern our proxy program sets up a local server (which our exam applet can talk to) which then communicates with the remote server in the central server.
						
						2. Another pattern that we could use in this software is the factory pattern. In the factory pattern we have an abstract class with methods. We then inherit these methods in our concrete classes, saving us from having to implement them many times.
						
						public abstract class Question {
						...
						public int CalculateMarks(String AnswerToQuestion) {
						// some implementation here which works out how many marks our answer is worth
						}
						}
						
						public class MCQuestion extends Question { ... }
						
						In our subclass we do not need to override the CalculateMarks() method, the compiler will detemine (at run-time) what type of question is calling the method and behave appropriately . If we wish to add a different type of question we no longer need to implement CalculateMarks() we just need to add a new class (and the marking scheme).
						
						3. The flyweight pattern could be used here to cut down on the amount of data that we need to store. In this pattern we have a factory which will create an instance of the class only if one has not already been created, if it has it returns it. For example, if a question class is simply a class with text in it (i.e. the question), then for each exam script we get back there may be a copy of the exact same question many times (e.g. in this exam question 1 is compulsory therefore in everyone&apos;s exam there will be a copy of this question.
						
						public class QuestionFactory {
						private List QuestionList[];
						
						public Question GetQuestion(int QuestionNumber) {
						// if it doesn&apos;t exist return create it
						if (Question(QuestionNumber) == null) { return new Question(QuestionNumber)); }
						// else simply return it
						else { return Question(QuestionNumber); }
						}
						... }
						
						This way there will only be one copy of a question but it can be in many places.
						
						4. Finally since we will need to store the exam scripts, results etc there will probably be a database at the central server. We want to use the Singleton pattern to ensure that only one thing can write to the databse at any one time. The singleton pattern ensures that more than one thing cannot write to the database by declaring the constructor to the DBwriter private and having a method that returns the writer only if one has not already been created.
						This could also be used when communicating with the central server. If a mistake occurs when two exam scripts are sent to the server at the same time (e.g thread switch half way through sending information) we may end up with half someone&apos;s exams and half someone elses (assuming that network protocols allowed this). Therefore we could have a Singleton pattern for ServerAccess and have a queue of people waiting to get this ServerAccess, only getting it when the other client has finished with it.
						
						public class ServerAccess() {
						private ServerAccess instanceOfSA;
						private ServerAccess() { .... } //private constructor
						
						public GetServerAccess () {
						if (instanceOfSA == null)
						return new ServerAccess();
						} // only return an instance if there is one there already
						... }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="11" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							The purpose of using Design by Contract is to ensure that if we call a method using appropriate inputs, we will get the answer that we expect. A contract is something that ensures that there classes will behave as we expect them to. We define a contract using pre and post-conditions, which satisfy some specification for our system.
							
							A pre-condition gives the method the guarantee that however it is called, we do not need to check the input since if the system is correct, the input will satisfy the pre-condition and therefore I will be able to run without any problems.
							
							A post-condition gives the method calling the class the guarantee that if it calls the method with the appropriate output, the result it gets back will be correct according to my post-condition.
							
							For example if we have a program that adds two numbers together, a pre-condition may be that the two numbers supplied are integer numbers. A post condition may be that the result returned is the two numbers added together. Both the client and the server benefit from the contract because the addition will not have to check the numbers are integers, and the client will not have to check that the addition is correct.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							There are two possible methods for implementing Design by Contract in Java, the first is to use the assert statement to code in what the pre and post-conditions should be, the second is to perform explicit checking on these conditions.
							
							1. SqRoot class, pre-conditions may be that the number is positive and post-condition is that the number returned is the square root. x &gt; 0 {R} x&apos; = root(x)
							class SqRoot() {
							...
							public void Maths() {
							...
							if (number &gt; 0) { number = root(number); }
							else ( number = -1; )
							}
							
							}
							Here we have made our pre-condition explicit by stating that we will only call the method if the number is greater than 0 (satisfying our pre-condition). Our post-condition is satisfied explicitly because we calculate the root of the number and then return it.
							
							2. For a stack there are several methods that will be useful, for example the push-pop operations. If we say say for the push method the pre-condition is that we supply a number and the post-condition is that our number is pushed to the top of the stack.
							
							public boolean PushNumber(int number) {
							#assert number != null;
							...
							if ( .. ) //number added to top of stack
							return true;
							else { return false; }
							
							#assert return = true;
							}
							
							Here i have used two assert statements to ensure our pre and post- conditions are enforced. The problem with these in Java though is that assertions can be disabled if someone wants to, therefore explicitly stating pre/post conditions may be a better method to ensure that DbC is successful.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Now when we call the methods in SqRoot and Stack we have a contract with these classes. We will check our variables beforehand ensuring that the pre-conditions are obeyed.
						Because of our contract we know the the answer that we recieve from these methods will be correct which is the biggest benefit.
						
						Anothe benefit is that we no longer need to check for exceptions as we may have had to do before. The reason for this is because a correct system, if supplied with correct input will give us a correct answer and therefore the program will not crash etc. This means that we will not need to do explicit exception checking.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="89" examId="CS310105" timeTaken="7195" isSubmission="true" allImages="true">
		<compositea marksAwarded="51" isMarked="true">
			<compositea marksAwarded="15" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of inheritance here seems valid, but not entirely. A striker is-a footballer, but is a role played by a footballer. So the change rule comes into affect, as the role of each footballer could change. Because of this should use delegation and hold the current role of a footballer as an instance variable. Along with this, generalisation can be used to simply have the name of a footballer as an instance variable (but could be a constant).
						
						public class Footballer
						{
						private String currentPosition;
						private String name;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The TrafficQueue class is inheriting from ArraryList simply for the use of its implementation rather than to help classify the TrafficQueue class. This is called implementation inheritance and is bad because the operations of the ArrayList (ie its methods) are visible to the clients of the class, thus breaking encapsulation. A better solution would be to use delegation to say that a TrafficQueue has-a ArrayList rather than is-a ArrayList. Also the static type of the List should be programmed to the interface List rather than to the explicit definition of ArrayList. Any collection that implements the List interface can now be assigned at runtime.
						
						public class TrafficQueue{
						private List queue;
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This example uses multiple inheritance to classify the CameraPhone object. This example seems to pass the is-a-kind-of test, as a CameraPhone is a MobilePhone and a DigitalCamera. However i still would not use MI here. The reason for this is that the combination of MobilePhone and DigitalCamera make an entity in CameraPhone that is not clearly defined. A MobilePhone will have lots of functionality that a DigitalCamera will not, and this will affect performance of the use of this classification. Interface inheritance could be used here, so that the CameraPhone implements both a MobilePhone interface and a DigitalCamera interface. Or, a new classification could be made that is simply a CameraPhone that only extends PersonalElectronicEquipment. This would lose some of the reuse gained through inheritance, but would represent a clearly defined entity.
						
						public abstract class PersonalElectronicEquipment { … }
						public class MobilePhone extends PersonalElectronicEquipment { … }
						public class DigitalCamera extends PersonalElectronicEquipment { … }
						public class CameraPhone extends PersonalElectronicEquipment { … }
						
						-----OR-----
						
						public abstract class PersonalElectronicEquipment { … }
						public interface MobilePhone { … }
						public interface DigitalCamera { … }
						public class CameraPhone extends PersonalElectronicEquipment implements MobilePhone, DigitalCamera { … }
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The use of Multiple Inheritance again seems valid, as both InformationSource and Copyable pass the is-a-kind-of test. However, as the Copyable class does not contain any instance variables I would make it an interface rather than an extendable class. The decision is marginal, but I believe that implementing a Copyable interface rather than extending a class would better represent the classification of a Book.
						
						public interface Copyable {
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable {
						//provide implementation of copy()
						public Object copy(){
						...
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						I believe that this example is overkilling the use of inheritance. Firstly, the NoAnswerRequired class represents information that should really be related to a question rather than an answer. Secondly the NoAnswerProvided class shouldn&apos;t be required. A class that is dealing with answers to questions could be generalised to handle a case where no answer has been provided. I do believe the there should be a distinction between MCQAnswer and TextAnswer though. The reason for this is that there will most probably be code that differs for the marking of a textual answer and a Multiple choice answer. These two classes are correct to extend an abstract Answer class. This is because an abstract mark() (or similar) method could be provided as abstract. Dynamic binding could then be used at runtime to determine which type of Answer is present, and therefore how to mark it.
						
						// The class representing answers in an online exam system
						public abstract class Answer {
						public abstract int mark();
						}
						
						// An answer to a multiple-choice question
						public class MCQAnswer extends Answer {
						...
						public int mark(){ //code for marking MCQs}
						}
						
						// An answer consisting of text
						public class TextAnswer extends Answer {
						...
						public int mark(){ //code for marking Text Answers}
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="19" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A pattern of communicating classes and/or objects that can be customised to solve a general design problem in a particular context.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="6" isMarked="true">
					<answerString>
						The composite design pattern allows a composition of objects of a type to be sent the same messages as an object of the same type that exists on its own. We want to be able to distinguish between the types of object through dynamic binding rather than through If staements. For an exam system we would want to be able to have the different types of questions and answers all understand the same messages so that a collection of each (say exam) could be processed uniformly. Obvious abstractions for the classification of the system would be an abstract Question class and an Abstract answer class. On each of these abstract data types an abstract method would be defined to perform marking or get marks allocated - in general, an operation that will be required of all different types of Question and similar for Answer. Using question as an example, the system should be able to handle questions that have subquestions. For this, a CompositeQuestion type could be defined. This would hold a collection of Question objects that represent the sub questions. As the CompositeQuestion would extend the Question abstraction its collection of objects would have the same type as itself. As each subtype of Question will implement the common abstract operation, dynamic binding can be used with recursion to examine each subquestion one by one and choose the correct implementation of the getMarksAllocated operation for each question in the list. Because of this, it would be possible to have an infinite number of levels of subquestions, and we don&apos;t have to deal with different type of question differently. They all understand the same message so there would be no need for explicit selection of question type by conditional statements.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						The system could use the Proxy design pattern to simplify the client-server communication between the applet and the central server. The applet would require to send the information of answers to the server. The proxy object could share the same interface as the server object, so that the applet can be coded as if it were interacting directly with the server. However the proxy object handles the setting up of communication betweeen the client/server without knowlegde of the applet, allowing the communication calls that are required of the applet to be simple.
						
						The strategy design pattern could be used to help with the display of information to the marker. An abstract strategy of display could be defined with subclasses that define each different method of displaying results to the marker. The marker could choose between strategies and the code to deal with each strategy would not need to be altered as all strategies employ the operations of the abstract strategy.
						
						The singleton design pattern could be employed to ensure that only one instance of the applet can appear at each computer being used to take the exam. The singleton instance of the applet could also be created depending on whether the current user has begun an exam (identification of each instance by library card number).
						
						The observer pattern could be used for the system. I say this because the server is a reactive system and will not generally know how many instances of the applet are active at any one time. The server would register its interest in the events of each applet being used to take the exam. When an event occurs on each applet (such as submitting answers for marking) the server would be notified by the applet of the event along with the actual event data. The server would then handle the event as it sees fit (eg store answers for marking).
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<compositea marksAwarded="15" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							A contract is used to ensure the correctness of a piece of software - its ability to perform according to its precise specification. The contract would be introduced between the clients of each class in the library and the library class itself. The contract would state that as long as each call to the library class is of a particular state, the library class would guarantee that it will return a value in a particular state. To establish a contract between a class and its clients, preconditions and postconditions are used. A precondition defines the values (state) that a call to a method must comply with before the method is executed. The client is obliged to meet the requirements of the precondition when calling the method. If the method is called in the correct state then the library class will guarantee to produce a resulting state (value) that falls within the bounds of a postcondition. The postcondition is the set of states that will be produced by a method, given that its precondition is met. The postcondition is an obligation for the library class. This establishes the contract between a class and its clients by saying informally &quot;if you promise to call method with a state matching its precondition, the method guarantees to return a state that complies with its postcondition.
						</answerString>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="10" isMarked="true">
						<answerString>
							For the stack class there would be a class invariant that the stack is not over filled after each push. It should also check that the stack is not empty after each pop. In java the only way to check the invariant of the class is to use an assert statement before and after the execution of each method, that checks the invariant properties of the stack class. As the methods of the Stack class outlined below are public, there preconditions should not be defined using assert staements. As they interface to the client using the stack class any exceptions that occur should be returned as a specific type of exception rather than the AssertionError type. Assertions in java should only be used on private methods. The preconditions of both the push/pop methods should be implemented as specific argument check that returns a specific error if required. The postcondition of the pop method would be that the next element from the top of the stack is returned. The postcondition of the push method would be that the stack is updated with the pushed object at the top.Post conditions for push/pop could be implemented using the assert keyword in java.
							
							public class Stack{
							private ArrayList stack;
							
							//pre condition that stack is not full before popping. Should be checked through conditional argument checks.
							public void push(Objects toPush){
							assert checkInvariant();
							...
							assert checkInvariant();
							}
							
							//precondition that stack is not empty before popping next element. Should be checked through argument chcks not assert.
							public Object pop(){
							assert checkInvariant();
							...
							assert checkInvariant();
							}
							
							private boolean checkInvariant(){..} //invariant method to check after each method that stack isn&apos;t full/empty
							
							} //Stack
							
							As the SqRoot class contains no properties, only an operation, there is no need to have a class invariant for it. The precondition of the getSquareRoot method would be that the number is non negative. Again, this would have to be implemented as an argument check rather than an assert statement as the method is public and would require specific exceptions to be returned. The postcondition of the method would be that the number passed to be square rooted would be square rooted and its new value returned.
							
							public class SqRoot{
							
							public float getSquareRoot(float numToRoot){...}
							
							}  //SqRoot
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						By using the SqRoot and stack classes defined with Design by contract, clients of these classes (eg the Java program) would be guaranteed a performance that conforms to the specification of the library classes. Therefore the program that uses these library classes is by implication going to perform to specification (ie be correct) with respect to this area of its operation. The program would also be easier to implement as there would be no need to perform detailed error checking on the results of the library methods. This is because the classes are guaranteed to perform according to specification, and that gurantee is enough.
						
						public class GetSquareRoots
						{
						private Stack stack;
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
	<answerPaper studentId="90" examId="CS310105" timeTaken="7173" isSubmission="true" allImages="true">
		<compositea marksAwarded="35" isMarked="true">
			<compositea marksAwarded="8" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The only difference between a Stricker and a Defender is their position(or job), and WayneRooney is acctually not a type of footballers, we can archieve the same goal by generalise the class Footballer with parameterisations!!
						
						public class Footballer(string position, string name)
						{
						priviate string name, position;
						priviate int height, weight, age;
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						TrafficQueue is not acctually a subtype of ArrayList, it only has some charactors of ArrayList and can be implemented in same way, so we can use implementation inheritance here rather than interface inheritance
						
						public class TrafficQueue()
						{
						public TrafficQueue()
						{
						ArrayList queue = new ArrayList();
						...
						}
						...
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						This is good use because CameraPhone inherite attributes from MobilePhone and DigitalCamera (we wont strictly consider all the possible functoinalities of a DigitalCamera)
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="0" isMarked="true">
					<answerString>
						The Copyable class is used to copy Java objects, however, a book as an information source which can be copied doesnt have the same meaning. It&apos;s more like copy a book physically. Thus we can not use interface inheritance here.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						NoAnswerProvided and NoAnswerRequired both refers to a black answer to a question, neither of them counts when calculating the final marks, so basically they have exactly same functionalities, we can have only one subclass of Answer to represent the 2 situations
						
						public abstract class Answer { … }
						
						public class MCQAnswer extends Answer { … }
						
						public class TextAnswer extends Answer { … }
						
						public class NoAnswer entends Answer { ... }
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Design Pattern is a pattern of communicating classes and/or objects, which is a solution for solving certain design problems, explained in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The aim of composite design pattern is to treat all nodes types in a tree structure in a uniform manner. In this case, we&apos;ll need a tree structure for questions
						
						abstract class question is the super class for all kinds of questoins to inherit, it has the basic functionalities and attributes that a question has, eg, each question should have a mark value allocated to it
						
						public abstract class Quesion
						{
						privite int allocatedmarks;
						
						protected int getMark() {return allocatedmarks}
						}
						
						Atomicquestion is the smallest unit of questions that can form a composite question
						
						public class Atomicquestion extends Question
						{
						private allocatedmarks;
						private Atomicquestion(int mark)
						{ allocatedmarks = mark; }
						}
						
						public class Compositequestion extends Question
						{
						private ArrayList components;
						private int total;
						private Compositequestion(...) {...}
						protected int getMark()
						{
						total = 0;
						for (i = 0 to components.length(); i++)
						{
						total = total + (Question)components[i].getMark();
						}
						}
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						Proxies
						
						If two objects are on different machines, it&apos;s impossible to let them send and receive messages to and from each other in the normal way. However, it&apos;ll be much easier if we can arrange for it to appear as if that&apos;s what&apos;s happening. So proessing of remote messages is belegated to a sepearate proxy object, which in turn belegate the message to remote objects. This parttern is offen used on network application. Since our exam is taken from anywhere in the world on internet via appliets, proxies would be useful in our software
						
						observer
						
						Observation pattern is about description of relationship between 2 objects. One is observable, which has a state that changes at an unpredictable time(when a button is clicked, etc), and the other is observation, which is interested in that change. It register this interest, and is informed when that change happens. As this is an online exam software, it&apos;ll be needed to deal with various events during the exam, eg click a button, enter a new window/stage etc, thus observer pattern could be used in this software
						
						strategy
						
						strategy pattern is to treat algorithms as objects rather than methods, thus to change strategyies at runtime is possible. As in our software, it employs different strategies to present the information efficiently to the marker and enhance consistency, strategy pattern could be used to archieve this feature.
						
						singleton
						
						Sometimes we may only want to create a limited amount of objects of a class, or we even want only one instance to be created when we need, we can use singleton pattern to archieve this. In our software, we may use a ExamSave class to store the the exams that the students have input every time when they click &quot;save answer&quot;, thus a instance of ExamSave is only needed when the &quot;save answer&quot; button is clicked, we wont need it at any other time and we would never need more than one of them, this can be archieved with the singleton pattern
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="10" isMarked="true">
				<compositea marksAwarded="6" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Design by Contract view the relationship between a class and its clients as formal agreements (contract), expressing each party&apos;s right and obligation. Only through a precise definition of each party&apos;s claims and responsibilities can we attain a significant degree of trust in large software system.
							
							So Design by Contract is all about specifying and proving. As in our case, a class library is developed for being reused frequently in the object-oriented programming language. It&apos;s very important to use design by contract to build this significant degree of trust, otherwise there will lots of errors and exceptions in programming with this language.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="4" isMarked="true">
						<answerString>
							We have a strict priconditoin for SqRoot is that the input number must be positive, and the postconditoin is the result must be positive as well, as a negative number doesnt have a square root
							
							public class SqRoot
							{
							public SqRoot() {}
							public real getRoot(real input)
							{
							real result = 0
							if (input &gt; 0)
							{
							...
							}
							return result;
							}
							}
							
							A stack class has methods like store() and remove() for maintianing numbers, it has a strict preconditoin for the store() is that the stack cant be full, this can be tested by using method isFull(), and a strict precondition for remove() and getNum() is that the stack cant be empty, this can be tested by the method hasNext();
							
							public class Stack()
							{
							public Stack(int size) {...}  // to create a stack of given size
							public int getSize() {...}  // to return the size of given stack
							public store(real n) { ... }  // stores n on top of the stack
							public remove() {...}  // remove the top element of the stack
							public boolean hasNext() {...}  //to judge is the stack is empty, if has more elements to deal with
							public boolean isFull() {...}  //to judge if the stack is full
							public real getNum() {...} //get the number on top of the stack
							}
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						It&apos;s more flexable by using the predefined SqRoot and Stack, coz if we want to change any functionality, we only need to change SqRoot and Stack rather than bother with the whole program. SqRoot and Stack can also be used in any other programs. When reusing SqRoot and Stack we dont need to worry about the variants coz they&apos;ve all been handled when declaring SqRoot and Stack. In this way, we can build a system larger and larger without much trouble and it&apos;s easy for mantainance.
						
						public class SqRoots
						{
						Stack result, source;
						SqRoot sq =new SqRoot();
						
						public SqRoots() {...}
						
						public Stack getRoots(Stack input)
						{
						source = input;
						result = new Stack(source.getSize());
						While (source.hasNext())
						{
						result.store(sq.getRoot(source.getNum()));
						source.remove();
						}
						return result;
						}
						}
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="91" examId="CS310105" timeTaken="5996" isSubmission="true" allImages="true">
		<compositea marksAwarded="44" isMarked="true">
			<compositea marksAwarded="13" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						well a striker &quot;is-a&quot; footballer, and a defender also &quot;is-a&quot; footballer.(see later for revision of this statement) WayneRooney &quot;is-a&quot; striker (I hear) however he should not be extending into a &quot;class of his own&quot;.
						More likely a Footballer will have a name ie:
						public abstract class Footballer{
						public string FirstName;
						public string LastName;
						}
						Also I would think that there is not much difference in the methods that a Defender or Striker invoke - they both kick the ball, run around, get sent off. so perhaps an altrnative is to make footballer look more like this:
						public abstract class Footballer{
						public string FirstName;
						public string LastName;
						public string Position; // as in striker/ defender
						public void KickBall(vector tothisplace);
						public void MoveTo(vector tothisplace);
						} I.e they are more &quot;is-a-type-of&quot; than &quot;is-a&quot;
						I don&apos;t know much about football but this seems fairly right to me.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						There is a clear need for some delegation (has-a) here rather than inheritance, as although a trafficque can be represented as an array list it is likely there are other attributes or methods that are involved.
						
						alternative:
						public class trafficqueue{
						private Arraylist ThisQueue;
						public void alterqueue_in_some_way();
						...
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						A mobile phone&quot;is-a&quot; Personal Electronic equipment, OK.
						Same for DigitalCameras.
						
						However CameraPhone more like &quot;Has-a&quot; Phone and Camera built in. So:
						
						public class CameraPhone extends PersonalElectronicEquipment{
						/*package*/ MobilePhone PhonePart;
						/* package*. DigitalCamera CameraPart;
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						public class Copyable { ...
						}
						
						This should be an interface rather than a class. Then Book can extend InformationSource, and implement copyable.
						Alternative:
						publc interface Copyable{...}
						
						// A book is an information source which can be copied. public class Book extends InformationSource, Copyable { … }
						It&apos;s true that a book is copyable, however if the above is done (implement an interface) there is no need to try and do MI
						public class book extends InformationSource implements copyable
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						public abstract class Answer { … } I think this should have some attributes built in that eliminate the need for some of the other classes, namely NoAnswerProvided and NoAnswerRequired. E.g
						public abstract class Answer {
						/*package*/ boolean AnswerProvided;
						/*package*/ boolean AnswerRequired;
						}
						TextAnswer and MCQAnswer make sense to be different classes as they will have different methods for storing the answers. However they can both make use of the above flags to whether the answer was provided and/or required
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="17" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						I think i forgot this! It&apos;s something like &quot; A formal solution to a given problem in a specific context&quot;. If it&apos;s not that, I think that&apos;s a pretty good definition anyway.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						The whole point of the composite pattern is to allow different nodes on a tree (here the differing exam questions) to be treated uniformly. Say as an example we have a question type called Question:
						public class Question{
						/*protected*/ int Mark;
						public int GetMark(){return Mark};
						}
						We can make sure that getMarks can be used across all questions (say some that have a list of questions like this:
						public class CompositeQuestion extends Question{
						public arraylist SubQuestions;
						/*protected*/ int Mark;
						public int getMark(){
						int totalmarks=0;
						for (int i = 0; i&lt;SubQuestions.Size;i++){
						totalmarks += (Question)(SubQuestions[i].getMark());
						}
						}
						Here a call to the getMark Function of both a single question and a Composite Question work equally well.
						I know this is the same as in the notes (I hope!) but the question is pretty similar to the example...
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="12" isMarked="true">
					<answerString>
						Proxy design pattern would likely be used to manage network traffic. Clients will probably have some kind of proxy set up so that to them it looks like they are talking to the central server, when in fact the proxy will be doing that for them.
						
						Strategy design pattern could be used to manage the &quot;various strategies&quot; used to present the information to the marker. In the strategy pattern the each algorithm is given it&apos;s own extension of an abstract class covering all strategies, making it easier to switch between them at runtime. The idea behind this pattern is to try and encapsulate all the nasty goings on that occur when using algorithms which use a lot of methods from other objects.
						
						The user interface and operating system will likely be using the observer pattern, which is where systems need to be able to react (to the marker moving windows around, clicking on buttons in the applet for example). In this pattern, there is defined an abstract listening (or Observer) interface, which is implemented in a listener (Observer) class. When an event occurs, a method in the Listener (observer) class is passed an Event object (or observable object)
						The idea behind Observer is that new Observer objects can register themselves as listeners - so this could also be useful in terms of the (presumed) clients that markers will be running - these need to observe the central server, as well as be observed by it.
						
						Assuming that the central server is going to store its data in a database somewhere for persistance, the singleton pattern will be used to make sure that there is only one object ever writing to the database. This is achieved by making sure that the constructor of the object in question is private, and is called by a public method, which checks to see if this object has already been instantiated (via an instance variable of the same class). The singleton pattern may also be used to make sure that only one person is marking a particular persons exam at a time, dependant on the way the data structure is organised. If there is a seperate object for each exam for each person that is. Which probably wouldn&apos;t happen, if you were using another pattern like flyweight to keep track of marks...but that would be 5, so I shall stop now
					</answerString>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<compositea marksAwarded="10" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts set out clear obligations for classes, ie what is expected of them, and in doing so mean that classes using their methods can be sure to get a valid result (which is a benefit), as long as they meet their own obligations.
							The purpose of contracts is to be able to prove correctness. Ie. that it is possible by introducing pre and post conditions, and class invariants, that it is possible for a classs to state : &quot;if I recieve inputs to my methods conforming to my pre-conditions, I guarantee that 1) my class invariants will hold on completion of the method, and 2) that My post-conditions for this method will hold)&quot;
							I would define my contracts by setting out clear pre and post conditions, as well as any class invariants that are required. This would depend on the language re: actual implementation, but in general something like this:
							
							Class MyClass
							Instance Variables:
							int Max
							Methods:
							int MethodA(int FirstInput):  preconditions: FirstInput&lt; Max
							: post conditions: result &gt; 0
							Invariants: Max &gt; 0
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							public static class sqroot	//don&apos;t want to havve to instantiate it
							Class invariant:
							long real Tolerance = 0.000000000000...etc..1
							Methods:
							long real getsqrt(long real value, long real tolerance) {...}
							pre conditions: value &gt; 0		// ie that the input value is valid
							post conditions: sqrtv &gt; tolerance	// don&apos;t return a tiny number
							I would actually implement the pre and post conditions using asserts, i.e in the method body something like this:
							{
							long real result;
							assert (value &gt; 0)
							result = sqrt(value);
							assert (result &gt; tolerance)
							return result
							}
							
							Secondly Stack:
							
							public Class Stack:
							Class Invariants:
							
							Instance variables:
							Private ArrayList Stack
							Methods:
							public void Push(int v) : 	Preconditions: Stack not full
							
							//I would make it up to this class to ensure that the stack is not full, and otherwise throw an error message. It //should not be up to the caller of the stack to do this in my opinion. Similarly all following conditions are checked // in this stack class.
							
							Postconditions: Stack updated OK
							public int Pop(): 	Preconditions: Stack not empty
							Postconditions: Stack updated OK
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Obviously I have some main() class which will call the methods as required. Say we have some stack of numbers being input by the user, in this case each time a number is input, the push method of our instantiated stack is called. Here the Stack object checks it&apos;s precondition itself, and will let the user know if the stack becomes full.
						Then our sqrt class can be used to start sqrting the stack - a simple Sqroot.getsqrt(Stack.Pop()) should suffice. Here Sqroot checks that the value being popped in the stack is valid, with no extra need to check.
						Depending on the way we&apos;ve written the stack empty/notempty responses, we could keep popping until we get an error (We have no way of knowing the stacks size at the moment.)
						The obvious benefits are that there is no need for exernal validation of input (checked errors) as these are carried out by the classes themselves.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="92" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="32" isMarked="true">
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The classes Striker and Defender determine the roles of a particular player. They are roles that can change during runtime, and therefore WayneRooney should extend Footballer instead of Striker, and Striker will be stored as the currentRoles attribute during instantiation.
						
						Another class FootballerPositions should be introduced which acts as a superclass to Striker and Defender, so that there is no confusion between actual footballers and types of positions
						
						A solution is to have a currentRole variable in the Footballer class, and each instance of Footballer will adjust this variable accordingly:
						
						public abstract class Footballer{
						private abstract FootballerPositions currentRole;
						}
						
						public abstract class FootballerPositions{...}
						
						public class Striker extends FootballerPositions { .. }
						public class Defender extends FootballerPositions { .. }
						
						public class WayneRooney extends Footballer {
						currentRole = new Striker()
						}
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						This is an &quot;implementation inheritance&quot; problem where TrafficQueue extending ArrayList exposes the methods available in ArrayList directly to client classes of TrafficQueue. Also, TrafficQueue may have more methods involved in operations not related ArrayList, therefor it is inappropriate to inherit from the class.
						
						The interaction with ArrayList should be encapsulated, ie, by creating an instance of ArrayList within TrafficQueue, and the operations on ArrayList will be called using accessor methods:
						
						public class TrafficQueue {
						private ArrayList queueList = new ArrayList();
						// instance of arraylist
						
						public void addNewElement(Object o)
						{
						queueList.add(o);
						} // accessor method to add element
						public void getElementAt(int index)
						{
						queueList.elementAt(index);
						} // accessor method to get element according to index.
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The is-a test for CameraPhone succeeds. However, since the operation of MobilePhone and DigitalCamera are mostly independant of each other, it can be viewed as a composite object that HAS both components MobilePhone and DigitalCamera.
						
						CameraPhone should therefor inherit from PersonalElectronicEquipment, and contain an instance of each of MobilePhone and DigitalCamera:
						
						public class CameraPhone extends PersonalElectronicEquipment
						{
						MobilePhone phone = new MobilePhone();
						DigitalCamera camera = new DigitalCamera();
						
						...
						// other methods
						}
						
						Where &quot;other methods&quot; are methods that access the operations of each instance, and act as a bridge between them for operations such as sending pictures taken by by the camera
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						class Book should not inherit Copyable. The function of Copyable would be clearer as an interface that class Book implements. Book would then have to provide implementation that copies its own information (the current way of inheriting the shallow copy() method is not specific enough in that it does not deal with information relevant to instances of book)
						
						public interface Copyable{
						public Object copy();
						}
						
						public class Book extends InformationSource implements Copyable{
						...
						public Book copy() { ... }
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						class NoAnswerProvided should be seen as a property of types of answers.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="13" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contracts bind the operations of the library to a set of requirements. Contracts of the operations are defined through pre-conditions and post-conditions (assertions), and is a specification for future users of the library to adhere to.
							
							Pre-conditions is the requirements of state (in the form of a logical predicate) that a user must be able to provide before a particular method in the library is carried out, and is the obligation of the user to fulfil those requirements.
							
							Post-conditions is the guarantee of a particular correct state that the method must be in when the operation is complete, GIVEN that the pre-conditions are met.
							
							Another form of assertion is Invariants, which is a contract on the class, ensuring that every stable state of the class is an acceptable state.
							
							Different programming languages have different ways of defining such assertions, eg, Eiffel uses the keywords &quot;require&quot; for pre-conditions, &quot;ensure&quot; for post-conditions and &quot;invariant&quot; for invariants.
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="8" isMarked="true">
						<answerString>
							SQROOT:
							
							The single method in SqRoot should have a pre-condition that the value being input is NOT a negative number. Since this method has to be public it should implement this as an &quot;if&quot; statement that checks for INVALID input, at the beginning of the method:
							
							if(inputValue&lt;0)
							throw new illegalArgumentException();
							
							There are two results of this operation, the positive root and the negative root. A set of post-conditions should be used to ensure these values are valid. The guaranteed values must be:
							1) for the positive root, it must be greater than or equal to 0 AND less than or equal to inputValue. (0 and inputvalue must also be valid for the case where input value is 0, then its result is also 0)
							2) for the negative root, it must be equal to the negative of the positive root.
							
							these can be implemented as an assertion at the end of the method, with composite logical predicates (exception is thrown if the predicates are not met):
							
							assert ((positiveRoot &gt;=0 &amp;&amp; positiveRoot &lt;= inputValue) &amp;&amp; (negativeRoot == -positiveRoot))
							throw new assertionError();
							
							
							STACK:
							
							To ensure the contract of the class, there has to be an invariant which says that at ANY one (stable) state of the class, the number of elements stored must not be less than 0 and must not be greater than a maximumCount.
							
							Methods which add elements to the class will have to have the pre-condition that there is still at least one empty space available before proceeding to add the element. (again it is a public method therefore an if statement is used)
							
							if (numberOfElements &gt;= maximumCount) // if illegal values
							throw new illegalArgumentException();
							
							Methods which remove elements from the class will have to have the pre-condition that the stack is not already empty.
							
							if (numberOfElements == 0) // if illegal values
							throw new illegalArgumentException();
							
							Both add and remove methods must end with an assertion checking the above invariant:
							
							assert (numberOfElements &gt;=0 &amp;&amp; numberOfElements &lt;= maximumCount);
							throw new assertionError();
							
							Methods which access the data (e.g. elementAt(int index) ) will require a precondition that the index does not point beyond the numbers stored in the stack: (the below example assumes numbers are stored in an array)
							if (numbers[index] &gt; numberOfElements - 1)
							throw new illegalArgumentException();
							
							and a postcondition that the retrieved value is not null:
							assert (retrievedValue != null)
							throw new assertionError();
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Through the contracts defined by each class, Java program can ensure that correct calculations are made provided that it supplies the required values that satisfies the preconditions of the methods in each class. The Java program must therefore ensure that arguements to Sqroot are all positive values, and it must also keep track of the count numbers in the stack to ensure that it does not violate the invariant of stack.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="3" isMarked="true">
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Some, but not all &quot;blocks of software&quot; fulfil the criteria of a software component. The current criteria include that the block is encapsulated, interfaced, reusable, replaceable and interoperable (in the form of compiled binary code).
						
						Encapsulation is a desirable concept in OO programming therefor is implemented in many types of software. But components must ensure this is STRICTLY adhered to
						Many software abstractions are not interfaced as they serve a particular purpose.
						many software abstractions not interoperable and is not in the form of executable binary code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<unanswered marksAwarded="0" isMarked="true">
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="93" examId="CS310105" timeTaken="7047" isSubmission="true" allImages="true">
		<compositea marksAwarded="39" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Class Footballer is abstract, which is correct as you don&apos;t want to be able to instanciate it.
						Defender is a concreate class, which adds functionality not avalible in the basic Footballer, so it makes sence to have it as a specilised sub class of Footballer.
						WayneRooney should be an instance, rather than a seperate class. If extra functionality is needed over the basic class then it could be added by paramertisation
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						This is very poor use of inheritance. The user does not need to know what the underlying data structure is for two reasons:
						1) It provideds the user with access to the underlying data structure, which may well break the class if the user directly alters data in the TraficQueue.
						2) If the internal representation chanages to something other than an ArrayList, to (say) a Stack then not only will the method header change, but if any users have coded directly to ArrayList then there code will break
						The ArrayList instead should be done via delegation. And if possible of java.util.List so if need be the structure can change
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						CameraPhone currently uses multiple inheritence, which can lead to problems.
						If this case if PersonalElectronicEquipment had .getBatteryLife() and .setBatteryLife() methods then what would happen if you carried this out on myCameraPhone.
						CameraPhone should properbly extends PersonalElectronicEquipment, and deligate to MobilePhone and DigitalCamera. It would need to override most (if not all) the methods in PersonalElectronicEquipment so it can forward the calls to both the MobilePhone, and DigitalCamera.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Here the programmer should have made Copyable an interface which Book implements, in a similar fashion that it could implement serailized.
						Or another possible solution would for Information source to have a method called clone(). Though if not all objects should support it, make it abstract and ones that do want to use it can just call doClone() which could be a private helper method in InformationSource. This would allow you to offer the functionality if it was needed, or not, without adding more than 1 line of code.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The Answer and MCQAnswer seems to be a good use of inheritance.
						However, there seems no real point ot the classes NoAnswerProvided, and NoAnswerRequired.
						These should be implemented via paramerisation of Answer, such as including a method in Answer called isAnswered() which returns a boolean.
						if NoAnswerRequired is required it would look like a mistake in the design, as there is no need for an exam to know about questions that don&apos;t need answers. This is because they should only exist in the question bank, and only the ones that are selected for the personilised exam are added to myExamPaper.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<feedback>
					&lt;html&gt;
					&lt;head&gt;
					
					&lt;/head&gt;
					&lt;body&gt;
					&lt;p style=&quot;margin-top: 0&quot;&gt;
					
					&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</feedback>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						A design pattern is a description of how a possible task can be carried out, that is, it&apos;s a &quot;best practice&quot;. It does not take a formal structure, but it normal has specific sections such as why it is needed, a few example of its useage, as well as its advantages and disadvantages.That said it may not be the best solution for the particular task at hand, that is why it&apos;s advantages and disadvantages are listed. Like everything else in the world, it&apos;s a trade off (between eas of coding, maintainness, time and space complexity)
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						The composite design pattern tells us how to combine different objects into one section.
						For example you could have an abstract class called Questions, with subclasses
						MCQuestion (for multiple-choice questions), TextAnswers (for standard written answers) and DiagramAnswers (for drawn answers).
						Since the exam is made up of many questions we need to be able to combine the questions, in a specific order. To do this we use the Composite Design Pattern
						We make a class called
						Public CompositeQuestion extends Question() {
						private Questions[] questions()
						Public Question getQuestion(int i) {...}
						Public void addQuestion{...}
						}
						The class extends question as it is a question (as a collection of questions is a question). We make the list of questions private so they can only be accessed through the controlled interface (getQuestion, addQuestion).
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="11" isMarked="true">
					<answerString>
						If the exam questions for a particular users exam were stored as a tree then we could use the null object pattern when designing the tree structure. The advantage of this is that we don&apos;t have to check for &lt;nulls&gt; when traversing the tree. This is usefull as it reduces the chances of bugs, as checks are done automaticaly. The down side of this however is that it requires extra objects (as rather than a null, we have now have an object). However this will not be an issue for the end users (exam candidate) as the will only be send a few questions (5 questions, made up of upto 5 subparts) so the memory requirements are low.
						
						Depending how much invigulation is needed when each exam is running it could be watched by one of many invigulators so that they can monitor the progress of the candidates perform checks (users are still connected (having problems loging in &amp; out, network problems); what there progress is through the exam; are backups still been performed at a regular intervul). This can be implemented by using the Observer Pattern. Each candiates exam will add a listener to one of the exam supervisors. This will allow the supervisor to huck into register that it wants to be notified about events that occur.
						
						If multiple exam questions are needed you could use a factory to generate them. You would need to pass a discriminator, which could be what exam, and which section of the exam it is (e.g. passing CS1081 and Section Al) would return a random multiple choice Java question. Though care would be needed to make sure that the same questions are not generated more than once for each candidates paper. So you might need some extra sub catogries, such as Inheritence, MVC, Object, so you could say &quot;generate 3*inheritence, 2*MVC, 4*Object&quot; questions, which would also allow a greater spread of questions to cover more grounds.
						
						Access Proxy Pattern could be used to make sure that exam candiates client software can only access the questions they have been given. The proxy acts as a middle layer between the two peices of Java. The Proxy could also be used to restrict exam status to an exam supervisor, and people exam answers to the setter of the exam (after x hours that the exam has finished). Even though the exam system is closed software the extra level of protection offered by the proxy is still usefull as it adds an extra layer of checks and security, which is a must for exams.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="13" isMarked="true">
				<compositea marksAwarded="9" isMarked="true">
					<freeTextAnswer marksAwarded="2" isMarked="true">
						<answerString>
							Contracts allow extra checks to be made by the compiler. Or it they are just JavaDoc comments they inform the user about the correct range an of values/states that can be passed to the method. By doing this we are reducing the chance of the program getting into an illigal state. We use them mainly in private methods, since we have control over what is been passed to them if there is an error we don&apos;t want the program to continue (which could happen if we threw an Exception). We want this to happen as if there is a error it is because of a bug in our code, rather than something that can be recovered from
							
							private float calcSpeed(float distance, float time){
							Assert ((distance &gt;= 0) &amp;&amp; (time &gt;= 0));
							...
							
							Assert (ret &gt;= 0);
							return ret;
							}
							
							If the above code is called with a negitive distance then the program will display the assertion message and exist
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							In the following code I have designed the system so that there are implicit contracts in the JavaDocs informing the user what there responsibilities are, and what the class will guarentee. Also I have used &lt;Assert&gt;&apos;s where when the error is in my code, and &lt;Exceptions&gt; when they have not honered there contact.
							
							/**
							Class to calculate square roots of &lt;i&gt;positive&lt;/i&gt; numbers
							Static Implementation
							**/
							Public Static Class SqRoot{
							
							/**
							Calculates the square root of a &lt;i&gt;positive&lt;/i&gt; number
							@Param Float - possitive number to find the root of
							@Returns Float - the root of the number
							@Requires number &gt;= 0
							@thrown PossitiveNumberRequiredException
							**/
							public static Float calcRoot(Float n)
							//Since this is a public class we should use exceptions for errors with params
							If (n&gt;=0) thrown new PossitiveNumberRequiredException (&quot;Can not find the square of a negitive number. This version doesn&apos;t deal with imagionary numbers&quot;);
							...
							//perform calculation
							...
							//Assertion as if there is an error it is an error with our code, which should not be recoverable
							Assert (ret&gt;=0);
							return ret;
							}//calcRoot
							
							}//Class: SqRoot
							
							
							Public Class Stack{
							private java.util.List theStack //Private
							private int currentSize, capacity; //Private - use accessor/mutator methods
							/**
							Add the passed number to the stack
							@Param Float - the number to be added to the stack
							@Requires number =/= nul
							@thrown NullPointerException if param == null
							**/
							public void push(Float f)
							{
							//Since this is a public class we should use exceptions
							if (f == null) throw new NullPointerException(&quot;Can not add &lt;null&gt; to the stack&quot;);
							if (currentSize == capacity)  throw new Exception(&quot;Can not add to the stack, stack is full&quot;);
							int oldSize = currentSize;
							...
							
							//Assertion as if there is an error it is an error with our code, which should not be recoverable
							//The size of the stack should have increased by exactly one
							Assert ((oldSize == (currentSize+1)) &amp;&amp; (classInvarient)) ;
							}//push
							
							/**
							Returns the top item from the stack
							@Requires stack not to be empty
							@thrown Empty StackException if stack is empty
							**/
							public float pop()
							{
							//Since this is a public class we should use exceptions
							if (currentSize == 0) throw new EmptyStackException();
							int oldSize = currentSize;
							...
							
							//Assertion as if there is an error it is an error with our code, which should not be recoverable
							//The size of the stack should have decreased by exactly one
							Assert ((oldSize == (currentSize-1)) &amp;&amp; ()classInvarient);
							
							}//pop
							
							private boolean classInvarient(){
							return (currentSize &lt;=capacity)
							}//classInvarient
							
							}//Class: Stack
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Since we now have to components, SqRoot and Stack which we know work, assuming the are given the correct parameters, which is our responsibility we can write a program that finds the root of a stack of numbers.
						Public Class MyFunProgram{
						private Stack stack();
						Public void doIt()
						{
						Float thisNumber;
						while (More User Input)
						try{
						thisNumber = Float.fromString(thisLine);
						//If we have got this far then we know we have a number
						//and therefor it is not null, which forfills out part of the contract
						stack.add(thisNumber)
						//get user input
						}
						catch{NaNException e } (System.out.println(&quot;Sorry, that wasn&apos;t a number try again, or hit &lt;enter&gt; after a new line to exit&quot;));
						}
						
						//Display Results
						
						Float thisItem;
						System.out.println(&quot;Entered Value:Square Root&quot;);
						while (!stack.empty()) //Using this guartees that stack is not empty
						{
						thisItem = stack.pop(); //Guarteed to get a result
						System.out.println(thisItem + &quot;:&quot; + SqRoot.calcRoot(thisItem));
						
						}
						}//Class: MyFunProgram
						
						
						As you can see from this code there is very few things that we need to check as the majority of the code is based on existing code (Stack and SqRoot) which we know do what they are designed to, as it is specified in there contract. The only responsibility of this class it to make sure that it performs correctly
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<feedback>
				&lt;html&gt;
				&lt;head&gt;
				
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p style=&quot;margin-top: 0&quot;&gt;
				
				&lt;/p&gt;
				&lt;/body&gt;
				&lt;/html&gt;
			</feedback>
		</compositea>
	</answerPaper>
	<answerPaper studentId="94" examId="CS310105" timeTaken="7200" isSubmission="true" allImages="true">
		<compositea marksAwarded="41" isMarked="true">
			<compositea marksAwarded="12" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						Bad Use of inhritance.  WayneRooney will probably be better as an instance, because it is unlikely you will want to have many WayneRooney Objects. Although strictly speaking isA test passes in all three cases.
						
						So in a class it might be more sensible to say
						
						Striker wR = new Striker(WayneRooney);
						
						or something simmilar.  Another point to consider is that the role of Wayne Rooney may change eg in 3 years time perhaps it is decided he is better as a midfielder so becomes a midfielder. so the code given will not be suitable in this case.  Also if the WayneRooney class evolves, the fact that it is a striker may be a minor feature of it.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="4" isMarked="true">
					<answerString>
						Bad, as it is a classic case of implementation Inheritance.  It exposes the Interface of ArrayList to its client TrafficQueue.  In reality may only want to use some of the operations from ArrayList.
						Delegation will be a better technique. Want a hasA relationship.
						eg
						public class TrafficQueue{
						ArrayList aR = new ArrayList();
						//use instance ar now to perform the operations
						}
						
						This code will be more robust as it prevents access to the interfact of ArrayList-this is a good use of encapsulation.  Will be Even Better if we use List instead of ArrayList as we may in the future want to change this to a Vector for example so it will be easier to carry out this change.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						isA test passes in first 2 cases. The CameraPhone Class is not as clear cut.  Will be better to use delgation since a CameraPhone has a DigitalCamera but still is a MobilePhone.  Have to remember that its major feature is the fact that it is a mobile phone its mir feature is the fact that it has a digital Camera. Its an unnecessary use of MI.
						
						so this may be a better solution
						
						public class CameraPhone extends MobilePhone{
						DigitalCamera dc =  new DigitalCamera();
						
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="1" isMarked="true">
					<answerString>
						Again its overkill on how much actually needs to be inherited, despite isA test being just about ok.  For example Book extends Copyable is not really necessary as it is only one feature of the Book class, and as The class develops it may turn out that the fact that it is copyable is a minor feature of it. Better to parameterise.
						
						will be better to have
						public class Book extends InformationSource
						{
						Copyable c = new Copyable();
						//use c
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						isA test passes in first 2 cases but not for the NoAnswerRequired class and  NoAnswerProvided as these are not  Answers.  will be better to parametrise, and have this as a feature within a class.  For example it might be better if they are boolean variables.
						eg
						
						public class MCQAnswer extends Answer {
						Boolean NoAnswerProvided = false;
						Boolean NoAnswerRequired = false;
						//other code
						}
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
			<compositea marksAwarded="14" isMarked="true">
				<freeTextAnswer marksAwarded="2" isMarked="true">
					<answerString>
						A Pattern of communicating classes/objects that are customised to solve a design problem in a particular context.
					</answerString>
					<feedback>
						&lt;html&gt;
						&lt;head&gt;
						
						&lt;/head&gt;
						&lt;body&gt;
						&lt;p style=&quot;margin-top: 0&quot;&gt;
						
						&lt;/p&gt;
						&lt;/body&gt;
						&lt;/html&gt;
					</feedback>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						Composite pattern enables you to treat each of the differnt node types uiformly.(in a tree structure).  The exam will have structured composite questions containing subquestions and you will want to treat them unifomly.  It can make use of dynamic binding and recursion perform certain operations.  For example adding all the mark for the paper, you would add all the marks for both AtomicQuestions and the SubQuestions.  The Composite Pattern will make use of inheritance, as both AtomicQuestions and SubQuestions will inherit from a common superclass.  It will also make use of delgation as a Question may contain a list of SubQusetions.
					</answerString>
				</freeTextAnswer>
				<freeTextAnswer marksAwarded="9" isMarked="true">
					<answerString>
						Observer Pattern can be used.-They allow flexible connections between observables and observers and can change at runtime.  They adapt to change.  The Software is in the form of an Applet.  For example when a button is clicked ie a state is changed unpredictably, an Obsever will be interested in this change in state, and subsequent code can be carried out in response.
						
						Proxy Pattern can be used- these can act as inbetween objects and handle communication.  Since the test can be carried out worldwide communication between the server and the computer is dealt with using a proxy.
						Remote Proxy is used to handle the communication to the far away object, Access Proxy can be used to control access ie it can be a security feature.  The proxy can contain  a local copy of the information from a far away object.(server in this case).
						
						Stategy Pattern can be used.  It provides a convienient way of switching between different alternative algorithms that are encapsulated with the same interface.  Hence the software can use this technique to determine which version of an algorithm can be used to present the information efficientlyto the marker and enhance consistency.
						
						Factory Method Pattern can be used.  Since the type of question to be marked may be unknown at compile time, rather than using the discriminator approach, using if&apos;s to determine the type of question, we can use Factory Method Patterns.  It will make use of Dyamic Binding and it means the Abstract marking class will never change when we want to extend the system.  All we do if say for example we introduce a new type of question is introduce a new subclass. (This will be used by the computer marker).
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="15" isMarked="true">
				<compositea marksAwarded="12" isMarked="true">
					<freeTextAnswer marksAwarded="5" isMarked="true">
						<answerString>
							Contract are needed as a formal agreement between clients and the class.   It enables one to formally specify and perhaps prove software components.  They  are used and needed to help define the rights and obligations of both clients and classes.  It is only through this can we establish some trust between software components of this system.
							Contracts are defined by specifying preconditions, post conditions and invariants. Preconditions and postconditions are logical predicates.  Preconditions ensure a system will never execute in a state not satisfying it, and postconditions ensures a system will gaurantee a state satisfied by it if the code is executed.  The precondition binds the client and they ar obliged to meet its requirement and the class benefits as it does not have to test the input.The postcondition binds the class and they ar obliged to meet its requirement and the class benefits as it can gauratee a suitable state.  An invariant is a property that  is true and holds throghout for all instances of a class that is in an observable state.(before and after method calls, and object creation).
						</answerString>
						<feedback>
							&lt;html&gt;
							&lt;head&gt;
							
							&lt;/head&gt;
							&lt;body&gt;
							&lt;p style=&quot;margin-top: 0&quot;&gt;
							
							&lt;/p&gt;
							&lt;/body&gt;
							&lt;/html&gt;
						</feedback>
					</freeTextAnswer>
					<freeTextAnswer marksAwarded="7" isMarked="true">
						<answerString>
							//SqRoot Preconditions and Postconditions and invariant;
							Attributes val: float, root;float
							method SquareRoot
							pre: val&gt;=0
							post root&gt;=0
							invariant val&gt;=0 and root&gt;=0
							
							//Stack PreConditions and PostConditions and Invariant
							Attribute numOfElements:Integer,  Capacity : Integer
							method: push
							pre: numOfElements&lt;Capacity
							post: Stack updated (numOfElements++)
							method: pop
							pre: numOfElements&gt;0
							post: Stack updated (numOfElements--)
							
							invariant numOfElements&gt;=0 and numOfElements&lt;=Capacity
							
							One SquareRoot method in SqRoot Class pre and post conditions and invariant  are specified for the code to work correctly. Two methods in Stack Class(push and pop) pre and post conditions and invariant  are specified for the code to work correctly .  Also Attributes used for both classes shown.
						</answerString>
					</freeTextAnswer>
				</compositea>
				<freeTextAnswer marksAwarded="3" isMarked="true">
					<answerString>
						The stack class will be used to provide a means for a data structure for the set of numbers.  Numbers to find the root of will be assembled and placed on the stack using the push method.  Each will be taken off the stack usin the pop method and the square root function will be applied. eg
						for(int i = 0; i&lt;Capacity  ;i++)
						{
						float rootValue = SqRoot.SquareRoot(pop());
						//do stuff with root
						}  Using stack is good as it is a  dynamic data structure that grows and shrinks so dont need to know beforehand how many numbers you will be using.  You wont be able to use more numbers than its capacity though so as this is a precondition.  (therefore upplimit defined).  It is good to use the SqRoot class as it is reusable in other situations, but more importantly restricts one from using invalid numbers, ie less than zero.  So it gaurantees a reult if the precondition is met.
						
						The code must satisfy the preconditions, postconditions and invariants for the Stacka and SqRoot class in order to execute, and provide correct results.
					</answerString>
				</freeTextAnswer>
			</compositea>
			<compositea marksAwarded="0" isMarked="true">
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
				<unanswered marksAwarded="0" isMarked="true">
				</unanswered>
			</compositea>
		</compositea>
	</answerPaper>
</setOfAnswerPapers>
